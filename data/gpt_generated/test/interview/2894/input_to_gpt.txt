The life goes up and down, just like nice sequences. Sequence t_1, t_2, ..., t_{n} is called nice if the following two conditions are satisfied:   t_{i} < t_{i} + 1 for each odd i < n;  t_{i} > t_{i} + 1 for each even i < n.  For example, sequences (2, 8), (1, 5, 1) and (2, 5, 1, 100, 99, 120) are nice, while (1, 1), (1, 2, 3) and (2, 5, 3, 2) are not. Bear Limak has a sequence of positive integers t_1, t_2, ..., t_{n}. This sequence is not nice now and Limak wants to fix it by a single swap. He is going to choose two indices i < j and swap elements t_{i} and t_{j} in order to get a nice sequence. Count the number of ways to do so. Two ways are considered different if indices of elements chosen for a swap are different. 
tl;dr: Sequence t_1, t_2, ..., t_{n} is called nice if the following two conditions are satisfied:   t_{i} < t_{i} + 1 for each odd i < n;  t_{i} > t_{i} + 1 for each even i < n.  You have a sequence of positive integers t_1, t_2, ..., t_{n}. This sequence is not nice now and you want to fix it by a single swap. Count the number of ways to do so. Two ways are considered different if indices of elements chosen for a swap are different. 

The objective of this Kata is to write a function that creates a dictionary of factors for a range of numbers. The key for each list in the dictionary should be the number. The list associated with each key should possess the factors for the number. If a number possesses no factors (only 1 and the number itself), the list for the key should be `['None']` The function possesses two arguments (`n` and `m`). Where `n` is the starting number and `m` is the ending number. For example: All factors for 2 (`n`) through to 6 (`m`) with the number being the key in the dictionary: ```python {2: ['None'], 3: ['None'], 4: [2], 5: ['None'], 6: [2, 3]} ``
tl;dr: Given starting number and the ending number, creates a dictionary of factors for all numbers. If a number possesses no factors , the list for the key should be `['None']` For example: All factors for 2 (`n`) through to 6 (`m`) with the number being the key in the dictionary: ```python {2: ['None'], 3: ['None'], 4: [2], 5: ['None'], 6: [2, 3]} ``

Given an integer, take the (mean) average of each pair of consecutive digits. Repeat this process until you have a single integer, then return that integer. e.g. 
tl;dr: You are given an integer, take the average of each pair of consecutive digits. Repeat this process until you have a single integer, then return that integer. If the average of two digits is not an integer, round the result up. 

Rainfall is measured in millimeters. The rain is collected in a vertical transparent tube with millimeter markings, and once the rain has stopped falling, one can check the height of the water in the tube. In our problem, the tube unfortunately has a leak at height $L$ millimeters (mm). If the water level is above the leak then water drains from the tube at a rate of $K$ millimeters per hour (mm/h). We want to figure out how much rain fell during a particular rainfall. We assume that the tube is high enough that it does not overflow. We also assume that rain falls at an (unknown) uniform rate during a rainfall, and that water does not evaporate from the tube. The height of the leak itself is also negligible. 
tl;dr: