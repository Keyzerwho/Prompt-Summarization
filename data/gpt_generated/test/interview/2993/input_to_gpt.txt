Given two strings representing two complex numbers. You need to return a string representing their multiplication. Note i2 = -1 according to the definition. 
tl;dr: Write program to return a string representing the multiplication of given two  strings of complex numbers. 

Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B. (A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)   
tl;dr: Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.   

# Task  Consider the following algorithm for constructing 26 strings S(1) .. S(26): ``` S(1) = "a"; For i in [2, 3, ..., 26]: S(i) = S(i - 1) + character(i) + S(i - 1).```  For example: ``` S(1) = "a" S(2) = S(1) + "b" + S(1) = "a" + "b" + "a" = "aba" S(3) = S(2) + "c" + S(2) = "aba" + "c" +"aba" = "abacaba" ... S(26) = S(25) + "z" + S(25)``` Finally, we got a long string S(26). Your task is to find the `k`th symbol (indexing from 1) in the string S(26). All strings consist of lowercase letters only. # Input / Output  - `[input]` integer `k`   1   k < 2^(26)  - `[output]` a string(char in C#)   the `k`th symbol of S(26
tl;dr: # Task  Consider the following algorithm for constructing strings S(1) .. S(26): ``` S(1) = "a"; For i in [2, 3, ..., 26]: S(i) = S(i - 1) + character(i) + S(i - 1).``` Your task is to find the `k`th symbol (indexing from 1) in the string S(26). # Input / Output  - `[input]` integer `k`   1   k < 2^(26)  - `[output]` a string(char in C#)   the `k`th symbol of S(26

Arithmetic coding is a method to represent a message as a real number $x$ such that $0 \leq x < 1$. We will assume that the message consists only of uppercase  A s and  B s. The two letters have associated probabilities $p_ A$ and $p_ B = 1 - p_ A$ such that $0 < p_ A < 1$. The current interval $[a,b)$ is initially set to $[0,1)$ and we will update this interval one letter at a time. To encode a letter, the current interval is divided into two subintervals as follows. Let $c = a + p_ A(b-a)$. If the next letter is  A , $[a,c)$ becomes the current interval. Otherwise, the current interval is now $[c,b)$. This process is repeated for each letter in the message. If $[k,\ell )$ is the final interval, the encoded message is chosen to be $k$. For example, if the original message is  ABAB  and $p_ A = p_ B = 0.5$, the sequence of intervals encountered in the algorithm is\[ [0,1) \xrightarrow {A} [0, 0.5) \xrightarrow {B} [0.25, 0.5) \xrightarrow {A} [0.25, 0.375) \xrightarrow {B} [0.3125, 0.375). \] The encoded message is therefore 0.3125, or 0.0101 in binary. Given the length of the message, the probabilities, and the encoded message, determine the original message. 
tl;dr: