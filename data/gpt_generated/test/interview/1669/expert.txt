 You are given a graph of $n$ nodes and $m$ bidirectional edges. For each node $p = 1, 2, \dots, n$, you need to find a minimum spanning tree. Then output the minimum cost required to travel between node $1$ and node $p$.  

-----Input----- The first line of the input contains a single integer $n$ ($0 \le n \le 40$) — the number of reserved tokens. The second line of the input contains the list of reserved tokens separated by spaces without repetitions in the list. Each reserved token is at least one and at most 20 characters long and contains only characters with ASCII codes from 33 (exclamation mark) to 126 (tilde) inclusive, with exception of a hash character ('#' code 35). The third line of the input contains a single integer $m$ ($1 \le m \le 40$) — the number of lines in the input source code. Next $m$ lines contain the input source, each source line is at most 80 characters long (counting leading and trailing spaces). Each line contains only characters with ASCII codes from 32 (space) to 126 (tilde) inclusive. The source code is valid and fully parses into a sequence of tokens. -----Output----- Write to the output a single line that is the result of the minification process on the input source code. The output source line shall parse to the same sequence of tokens as the input source with the correspondingly renamed words and shall contain the minimum possible number of spaces needed for that. If there are multiple ways to insert the minimum possible number of spaces into the output, use any way.  -----Examples----- Input 16 fun while return var { } ( ) , ; > = + ++ - -- 9 fun fib(num) { # compute fibs   var return_value = 1, prev = 0, temp;   while (num > 0) {     temp = return_value; return_value = return_value + prev;     prev = temp;     num--;   }   return return_value; } Output fun a(b){var c=1,d=0,e;while(b>0){e=c;c=c+d;d=e;b--;}return c;} Input 10 ( ) + ++ : -> >> >>: b c) 2 ($val1++ + +4 kb) >> :out b-> + 10 >>: t # using >>:  Output (a+++ +4c )>> :d b->+10>>:e