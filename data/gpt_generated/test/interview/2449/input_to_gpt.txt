A tree is a graph with n vertices and exactly n - 1 edges; this graph should meet the following condition: there exists exactly one shortest (by number of edges) path between any pair of its vertices. A subtree of a tree T is a tree with both vertices and edges as subsets of vertices and edges of T. You're given a tree with n vertices. Consider its vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to v_{i}. In one move you can apply the following operation:  Select the subtree of the given tree that includes the vertex with number 1.  Increase (or decrease) by one all the integers which are written on the vertices of that subtree.  Calculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero. 
tl;dr: You're given a tree with n vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to v_{i}. In one move you can apply the following operation:  Select the subtree of the given tree that includes the vertex with number 1.  Increase or decrease by one all the integers which are written on the vertices of that subtree.  Calculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero. 

Create a function with two arguments that will return an array of the first (n) multiples of (x).  Assume both the given number and the number of times to count will be positive numbers greater than 0.  Return the results as an array (or list in Python, Haskell or Elixir). 
tl;dr: Create a function with two arguments that will return an array of the first n multiples of x. Assume both the given number and the number of times to count will be positive numbers greater than 0.  

Complete the function that takes an array of words. You must concatenate the `n`th letter from each word to construct a new word which should be returned as a string, where `n` is the position of the word in the list. For example: ``` ["yoda", "best", "has"]  -->  "yes"   ^        ^        ^   n=0     n=1     n=2 ``` **
tl;dr: Given an array of words, you must concatenate the nth letter from each word to construct a new word which should be returned as a string, where n is the position of the word in the list. 

You are given an integer m. Let M = 2^{m} - 1. You are also given a set of n integers denoted as the set T. The integers will be provided in base 2 as n binary strings of length m. A set of integers S is called "good" if the following hold.   If $a \in S$, then [Image].  If $a, b \in S$, then $a \text{AND} b \in S$  $T \subseteq S$  All elements of S are less than or equal to M.  Here, $XOR$ and $\text{AND}$ refer to the bitwise XOR and bitwise AND operators, respectively. Count the number of good sets S, modulo 10^9 + 7. 
tl;dr: