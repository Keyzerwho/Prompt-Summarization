Consider a sequence [a_1, a_2, ... , a_{n}]. Define its prefix product sequence $[ a_{1} \operatorname{mod} n,(a_{1} a_{2}) \operatorname{mod} n, \cdots,(a_{1} a_{2} \cdots a_{n}) \operatorname{mod} n ]$. Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1]. 
tl;dr: Consider a sequence [a_1, a_2, ... , a_{n}].  Let's define its prefix product sequence as $[ a_{1} \operatorname{mod} n,(a_{1} a_{2}) \operatorname{mod} n, \cdots,(a_{1} a_{2} \cdots a_{n}) \operatorname{mod} n ]$. Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1]. 

You are given an array $a$ of $n$ integers. You want to make all elements of $a$ equal to zero by doing the following operation exactly three times:  Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment (added integers can be different).  It can be proven that it is always possible to make all elements of $a$ equal to zero. 
tl;dr: You are given an array $a$ of $n$ integers. You want to make all elements of $a$ equal to zero by doing the following operation exactly three times:  Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment.  It is always possible to make all elements of $a$ equal to zero. 

A Fenwick Tree (also known as a Binary Indexed Tree) is a data structure on an array which enables fast ($O(\log n)$) updates and prefix sum queries on the underlying data. For this problem, implement a Fenwick Tree to support operations of two types: (a) increment an element in the array or (b) query the prefix sum of a portion of the array. 
tl;dr: