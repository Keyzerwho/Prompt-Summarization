Chef is good at making pancakes. Generally he gets requests to serve N pancakes at once. He serves them in the form of a stack. A pancake can be treated as a circular disk with some radius. Chef needs to take care that when he places a pancake on the top of the stack the radius of the pancake should not exceed the radius of the largest pancake in the stack by more than 1.  Additionally all radii should be positive integers, and the bottom most pancake should have its radius as 1. Chef wants you to find out in how many ways can he create a stack containing N pancakes. Input First line of the input contains T (T <= 1000) denoting the number of test cases. T lines follow each containing a single integer N (1 <= N <= 1000) denoting the size of the required stack. Output For each case the output should be a single integer representing the number of ways a stack of size N can be created. As the answer can be large print it modulo 1000000007. 
tl;dr: Find the number of ways in which a stack of circular disk can be arranged in such a way that radius of disk on the top of the stack should not exceed the radius of the largest disk in the stack by more than 1.  The bottom most disk should have its radius as 1. Input First line of the input contains T (T <= 1000) denoting the number of test cases. T lines follow each containing a single integer N (1 <= N <= 1000) denoting the size of the required stack. Output For each case the output should be a single integer representing the number of ways a stack of size N can be created. As the answer can be large print it modulo 1000000007. 

The only difference between easy and hard versions is constraints. Now elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you. There are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free. Moreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \rightarrow {1, 5} \rightarrow {1, 2, 3, 5} \rightarrow {1, 2, 3, 4, 5}$. Calculate the minimum number of coins you have to spend so that everyone votes for you. 
tl;dr: There are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free. Calculate the minimum number of coins you have to spend so that everyone votes for you. 

Your slightly pointy-bearded boss has assigned you to write software to find the best songs from different music albums. And the software should be finished in an hour. But don t panic, you don t have to solve the problem of writing an AI with good taste. At your disposal is the impeccable taste of a vast horde of long-tailed monkeys. Well, at least almost. The monkeys are not very communicative (or rather, you re not sure which song  Ook!  is supposed to refer to) so you can t ask them which songs are the best. What you can do however is to look at which songs the monkeys have listened to and use this information to deduce which songs are the best.  At first, you figure that the most listened to songs must be the best songs. However, you quickly realize that this approach is flawed. Even if all songs of the album are equally good, the early songs are more likely to be listened to more often than the later ones, because monkeys will tend to start listening to the first song, listen for a few songs and then, when their fickle ears start craving something else, stop listening. Instead, if all songs are equal, you expect that their play frequencies should follow Zipf s Law. Zipf s Law is an empirical law originally formulated about word frequencies in natural languages, but it has been observed that many natural phenomena, such as population sizes and incomes, approximately follow the same law. It predicts that the relative frequency of the $i$ th most common object (in this case, a song) should be proportional to $1/i$. To illustrate this in our setting, suppose we have an album where all songs are equally good. Then by Zipf s Law, you expect that the first song is listened to twice as often as the second song, and more generally that the first song is listened to $i$ times as often as the $i$ th song. When some songs are better than others, those will be listened to more often than predicted by Zipf s Law, and those are the songs your program should select as the good songs. Specifically, suppose that song $i$ has been played $f_ i$ times but that Zipf s Law predicts that it would have been played $z_ i$ times. Then you define the quality of song $i$ to be $q_ i = f_ i/z_ i$. Your software should select the songs with the highest values of $q_ i$. 
tl;dr: