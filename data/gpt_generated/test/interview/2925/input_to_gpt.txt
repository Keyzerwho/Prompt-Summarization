You are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order. Sorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places. Every element of the sequence must appear in exactly one subsequence. 
tl;dr: You are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order. The numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places. Every element of the sequence must appear in exactly one subsequence. 

Catherine received an array of integers as a gift for March 8. Eventually she grew bored with it, and she started calculated various useless characteristics for it. She succeeded to do it for each one she came up with. But when she came up with another one   xor of all pairwise sums of elements in the array, she realized that she couldn't compute it for a very large array, thus she asked for your help. Can you do it  Formally, you need to compute $$ (a_1 + a_2) \oplus (a_1 + a_3) \oplus \ldots \oplus (a_1 + a_n) \\ \oplus (a_2 + a_3) \oplus \ldots \oplus (a_2 + a_n) \\ \ldots \\ \oplus (a_{n-1} + a_n) \\ $$ Here $x \oplus y$ is a bitwise XOR operation (i.e. $x$ ^ $y$ in many modern programming languages). You can read about it in Wikipedia: https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation. 
tl;dr: You are given an array of integers. You need to compute the bitwise XOR of all pariwise sums. 

You may have already known that a standard ICPC team consists of exactly three members. The perfect team however has more restrictions. A student can have some specialization: coder or mathematician. She/he can have no specialization, but can't have both at the same time. So the team is considered perfect if it includes at least one coder, at least one mathematician and it consists of exactly three members. You are a coach at a very large university and you know that $c$ of your students are coders, $m$ are mathematicians and $x$ have no specialization. What is the maximum number of full perfect teams you can distribute them into   Note that some students can be left without a team and each student can be a part of no more than one team. You are also asked to answer $q$ independent queries. 
tl;dr: A entity can have some specialization: A or B. She/he can have no specialization, but can't have both at the same time. You need to form a team. So the team is considered perfect if it includes at least one A, at least one B and it consists of exactly three entities. You know that $c$ of the students are specialised in A, $m$ are in B and $x$ have no specialization. What is the maximum number of full perfect teams you can distribute them into   Note that some students can be left without a team and each student can be a part of no more than one team. You are also asked to answer $q$ independent queries. 

Your slightly pointy-bearded boss has assigned you to write software to find the best songs from different music albums. And the software should be finished in an hour. But don t panic, you don t have to solve the problem of writing an AI with good taste. At your disposal is the impeccable taste of a vast horde of long-tailed monkeys. Well, at least almost. The monkeys are not very communicative (or rather, you re not sure which song  Ook!  is supposed to refer to) so you can t ask them which songs are the best. What you can do however is to look at which songs the monkeys have listened to and use this information to deduce which songs are the best.  At first, you figure that the most listened to songs must be the best songs. However, you quickly realize that this approach is flawed. Even if all songs of the album are equally good, the early songs are more likely to be listened to more often than the later ones, because monkeys will tend to start listening to the first song, listen for a few songs and then, when their fickle ears start craving something else, stop listening. Instead, if all songs are equal, you expect that their play frequencies should follow Zipf s Law. Zipf s Law is an empirical law originally formulated about word frequencies in natural languages, but it has been observed that many natural phenomena, such as population sizes and incomes, approximately follow the same law. It predicts that the relative frequency of the $i$ th most common object (in this case, a song) should be proportional to $1/i$. To illustrate this in our setting, suppose we have an album where all songs are equally good. Then by Zipf s Law, you expect that the first song is listened to twice as often as the second song, and more generally that the first song is listened to $i$ times as often as the $i$ th song. When some songs are better than others, those will be listened to more often than predicted by Zipf s Law, and those are the songs your program should select as the good songs. Specifically, suppose that song $i$ has been played $f_ i$ times but that Zipf s Law predicts that it would have been played $z_ i$ times. Then you define the quality of song $i$ to be $q_ i = f_ i/z_ i$. Your software should select the songs with the highest values of $q_ i$. 
tl;dr: