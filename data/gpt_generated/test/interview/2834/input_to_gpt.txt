Genos recently installed the game Zuma on his phone. In Zuma there exists a line of n gemstones, the i-th of which has color c_{i}. The goal of the game is to destroy all the gemstones in the line as quickly as possible. In one second, Genos is able to choose exactly one continuous substring of colored gemstones that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again. What is the minimum number of seconds needed to destroy the entire line  Let us remind, that the string (or substring) is called palindrome, if it reads same backwards or forward. In our case this means the color of the first gemstone is equal to the color of the last one, the color of the second gemstone is equal to the color of the next to last and so on. 
tl;dr: You are given a line of n gemstones, the i-th of which has color c_{i}. The goal is to destroy all the gemstones in the line. In one second, exactly one continuous substring of colored gemstones is chosen that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again.  What is the minimum number of seconds needed to destroy the entire line  

In this Kata you need to write the method SharedBits that returns true if 2 integers share at least two '1' bits. For simplicity assume that all numbers are positive For example int seven = 7;    //0111 int ten = 10;     //1010 int fifteen = 15; //1111 SharedBits(seven, ten);     //false SharedBits(seven, fifteen); //true SharedBits(ten, fifteen);   //true - seven and ten share only a single '1' (at index 3) - seven and fifteen share 3 bits (at indexes 1, 2, and 3) - ten and fifteen  share 2 bits (at indexes 0 and 2) 
tl;dr: You need to write the method that returns true if 2 integers share at least two '1' bits. Assume that all numbers are positive For example int seven = 7;    //0111 int ten = 10;     //1010 int fifteen = 15; //1111 SharedBits(seven, ten);     //false SharedBits(seven, fifteen); //true SharedBits(ten, fifteen);   //true - seven and ten share only a single '1' (at index 3) - seven and fifteen share 3 bits (at indexes 1, 2, and 3) - ten and fifteen  share 2 bits (at indexes 0 and 2

# Task  "AL-AHLY" and "Zamalek" are the best teams in Egypt, but "AL-AHLY" always wins the matches between them. "Zamalek" managers want to know what is the best match they've played so far.    The best match is the match they lost with the minimum goal difference. If there is more than one match with the same difference, choose the one "Zamalek" scored more goals in.    Given the information about all matches they played, return the `index` of the best match (`0-based`). If more than one valid result, return the smallest index. # 
tl;dr: # Task  The best match is the match "Zamalek" lost with the minimum goal difference. If there is more than one match with the same difference, choose the one "Zamalek" scored more goals in.    Given the information about all matches "AL-AHLY" and "Zamalek" played, return the `index` of the best match (`0-based`). If more than one valid result, return the smallest index. # 

Digits $4$ and $7$ are lucky, while all others are unlucky. An integer is lucky if it contains only lucky digits in decimal notation. We would like to know the $K$-th lucky positive integer. 
tl;dr: