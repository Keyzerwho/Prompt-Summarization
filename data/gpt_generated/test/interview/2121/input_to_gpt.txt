Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom  note can be constructed from the magazines ; otherwise, it will return false.  Each letter in the magazine string can only be used once in your ransom note. 
tl;dr: Given two strings a and b return true if a can be constructed from string charecters in b else false Each letter in the b string can only be used once in your a string. 

You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane.  Return the maximum number of points that are within or lie on any circular dartboard of radius r.   
tl;dr: you are given a list. each element represent a 2D point. Return the maximum number of points that are inside a circle of radius r. 

Let's say take 2 strings, A and B, and define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings `abc` and `abd` is 2, while the similarity of strings `aaa` and `aaab` is 3. write a function that calculates the sum of similarities of a string S with each of it's **suffixes**. ```python string_suffix('ababaa') => returns 11 string_suffix('abc') => returns 3 ``` Explanation: In the first case, the suffixes of the string are `ababaa`, `babaa`, `abaa`, `baa`, `aa` and `a`. The similarities of each of these strings with the string `ababaa` are 6,0,3,0,1,1 respectively. Thus the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11. For the second case, the answer is simply 3 + 0 + 0 = 3. Note : Each string will have at least one character - no need to check for empty strings :
tl;dr: Write a function that calculates the sum of similarities of a string with each of its suffixes. 

For his computer science class, Jacob builds a model tree with sticks and balls containing n nodes in the shape of a tree. Jacob has spent a_{i} minutes building the i-th ball in the tree. Jacob's teacher will evaluate his model and grade Jacob based on the effort he has put in. However, she does not have enough time to search his whole tree to determine this; Jacob knows that she will examine the first k nodes in a DFS-order traversal of the tree. She will then assign Jacob a grade equal to the minimum a_{i} she finds among those k nodes. Though Jacob does not have enough time to rebuild his model, he can choose the root node that his teacher starts from. Furthermore, he can rearrange the list of neighbors of each node in any order he likes. Help Jacob find the best grade he can get on this assignment. A DFS-order traversal is an ordering of the nodes of a rooted tree, built by a recursive DFS-procedure initially called on the root of the tree. When called on a given node v, the procedure does the following:   Print v.  Traverse the list of neighbors of the node v in order and iteratively call DFS-procedure on each one. Do not call DFS-procedure on node u if you came to node v directly from u.  
tl;dr: