Consider a sequence [a_1, a_2, ... , a_{n}]. Define its prefix product sequence $[ a_{1} \operatorname{mod} n,(a_{1} a_{2}) \operatorname{mod} n, \cdots,(a_{1} a_{2} \cdots a_{n}) \operatorname{mod} n ]$. Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1]. 
tl;dr: Consider a sequence [a_1, a_2, ... , a_{n}].  Let's define its prefix product sequence as $[ a_{1} \operatorname{mod} n,(a_{1} a_{2}) \operatorname{mod} n, \cdots,(a_{1} a_{2} \cdots a_{n}) \operatorname{mod} n ]$. Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1]. 

A transaction is possibly invalid if: the amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city. Each transaction string transactions[i] consists of comma separated values representing the name, time (in minutes), amount, and city of the transaction. Given a list of transactions, return a list of transactions that are possibly invalid.  You may return the answer in any order.   
tl;dr: You are given a list of strings where each string in format of "A,B,C,D". where A,D are strings and B,C are numbers. A string is possibly invalid if: the C exceeds 1000, or; if two strings have same A and different D and the difference between C is greater than or equal to 60. return list of strings which are possibley invalid in any order 

You may have heard of the  maximum subarray problem  from your university s undergraduate algorithms course. The problem goes like this: You are given an array $A$ of $n$ integers, and the task is to find a contiguous subarray of $A$ whose sum is maximum. For example, in the array below:\[ \texttt{A := [-2, 3, 5, -7, 8, 13, -20, 14, 1]}, \] the solution is the subarray from the second index (the number $3$) to the sixth index (the number $13$), with total sum $22$. The problem can be solved via divide and conquer, in $O(n \log n)$ time, or dynamic programming, in $O(n)$ time. Being a strong student in algorithms yourself, you are of course familiar with both approaches, so we won t bother explaining them here. However, your classmate Steve, a not-so-strong student in algorithms, has been bragging to you about the maximum subarray problem. He claims that not only can he solve the maximum subarray problem in linear time, he can even solve what he calls the  $k$-maximum subarray problem,  ALSO in linear time! What is the  $k$-Maximum subarray problem,  you ask  In a condescending tone, Steve explains: It is the natural generalization of the maximum subarray problem. Given an array $A$ of $n$ integers, you must find $k$ disjoint, contiguous subarrays of $A$ so that their total sum is maximum. You re not at all confident that Steve knows how to solve the  $k$-maximum subarray problem  in linear time, let alone that there even exists a linear time solution. You have gone to every algorithms lecture, however, a near-infinite improvement on Steve s attendance, and so you believe if anyone is to be the authority on the problem, it probably should be you. You decide to write a program to solve the  $k$-maximum subarray problem.  You can use this to verify Steve s likely-incorrect algorithm. To simplify things, you make the program just output the value of an optimal solution. You can modify it later if you want the solution itself. Furthermore, you decide your algorithm is sufficiently efficient as long as its running time is bounded by a small polynomial in $n$ and $k$. You think coming up with an actually-correct linear time solution would probably take you awhile, and you ve decided you only want to spend, say, a maximum of five hours on your code. 
tl;dr: