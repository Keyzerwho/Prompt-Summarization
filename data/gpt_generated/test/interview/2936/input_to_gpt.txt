A spoonerism is a spoken phrase in which the first letters of two of the words are swapped around, often with amusing results. In its most basic form a spoonerism is a two word phrase in which only the first letters of each word are swapped: ```"not picking" --> "pot nicking"``` Your task is to create a function that takes a string of two words, separated by a space: ```words``` and returns a spoonerism of those words in a string, as in the above example. 
tl;dr: Your task is to create a function that takes a string of two words separated by a space, and returns a spoonerism of those words in a string. 

$Neha$  is given a number $N$. She always looks for special thing , this time she is looking for $Special$ $Number$ and $Partial$ $Special$ $Number$. A $Special$ $Number$ is a number whose product of its digits is equal to number itself i.e. $N $, and in this number there is no digit $1$. $Partial$ $Special$ is a number having all the condition same as $Special$ except that it can also have digit $1$ in it .Neha have to count the number of $Special$ and $Partial$ $Special$ $Numbers $for a given  $N$ . She is not so good in programming , so go and help her. 
tl;dr: You have to find a $Special$ $Number$  and a $Partial$ special number for a number N.Special Number are those product of its digits is equal to number itself and there is no digit $1$. $Partial$ $Special$ is a number having all the condition same as $Special$ except that it can also have digit $1$ in it. Print the count of the $Special$ and $Partial$ $Special$ $Numbers $for a given  $N$ .  

You are given a rectangular parallelepiped with sides of positive integer lengths $A$, $B$ and $C$.  Find the number of different groups of three integers ($a$, $b$, $c$) such that $1\leq a\leq b\leq c$ and parallelepiped $A\times B\times C$ can be paved with parallelepipeds $a\times b\times c$. Note, that all small parallelepipeds have to be rotated in the same direction. For example, parallelepiped $1\times 5\times 6$ can be divided into parallelepipeds $1\times 3\times 5$, but can not be divided into parallelepipeds $1\times 2\times 3$. 
tl;dr: You are given a rectangular parallelepiped with sides of positive integer lengths $A$, $B$ and $C$.  Find the number of different groups of three integers $a$, $b$, $c$ such that $1\leq a\leq b\leq c$ and parallelepiped $A\times B\times C$ can be paved with parallelepipeds $a\times b\times c$. 

You may have heard of the  maximum subarray problem  from your university s undergraduate algorithms course. The problem goes like this: You are given an array $A$ of $n$ integers, and the task is to find a contiguous subarray of $A$ whose sum is maximum. For example, in the array below:\[ \texttt{A := [-2, 3, 5, -7, 8, 13, -20, 14, 1]}, \] the solution is the subarray from the second index (the number $3$) to the sixth index (the number $13$), with total sum $22$. The problem can be solved via divide and conquer, in $O(n \log n)$ time, or dynamic programming, in $O(n)$ time. Being a strong student in algorithms yourself, you are of course familiar with both approaches, so we won t bother explaining them here. However, your classmate Steve, a not-so-strong student in algorithms, has been bragging to you about the maximum subarray problem. He claims that not only can he solve the maximum subarray problem in linear time, he can even solve what he calls the  $k$-maximum subarray problem,  ALSO in linear time! What is the  $k$-Maximum subarray problem,  you ask  In a condescending tone, Steve explains: It is the natural generalization of the maximum subarray problem. Given an array $A$ of $n$ integers, you must find $k$ disjoint, contiguous subarrays of $A$ so that their total sum is maximum. You re not at all confident that Steve knows how to solve the  $k$-maximum subarray problem  in linear time, let alone that there even exists a linear time solution. You have gone to every algorithms lecture, however, a near-infinite improvement on Steve s attendance, and so you believe if anyone is to be the authority on the problem, it probably should be you. You decide to write a program to solve the  $k$-maximum subarray problem.  You can use this to verify Steve s likely-incorrect algorithm. To simplify things, you make the program just output the value of an optimal solution. You can modify it later if you want the solution itself. Furthermore, you decide your algorithm is sufficiently efficient as long as its running time is bounded by a small polynomial in $n$ and $k$. You think coming up with an actually-correct linear time solution would probably take you awhile, and you ve decided you only want to spend, say, a maximum of five hours on your code. 
tl;dr: