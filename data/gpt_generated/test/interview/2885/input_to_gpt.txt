In this Kata, you will be given a string and your task is to return the most valuable character. The value of a character is the difference between the index of its last occurrence and the index of its first occurrence. Return the character that has the highest value. If there is a tie, return the alphabetically lowest character. `[For Golang return rune]` All inputs will be lower case.  ``` For example: solve('a') = 'a' solve('ab') = 'a'. Last occurrence is equal to first occurrence of each character. Return lexicographically lowest. solve("axyzxyz") = 'x' ``` More examples in test cases. Good luck
tl;dr: Given a string and your task is to return the most valuable character. The value of a character is the difference between the index of its last occurrence and the index of its first occurrence. Return the character that has the highest value. If there is a tie, return the alphabetically lowest character. `[For Golang return rune]` All inputs will be lower case.  ``` For example: solve('a') = 'a' solve('ab') = 'a'. Last occurrence is equal to first occurrence of each character. Return lexicographically lowest. solve("axyzxyz") = 'x' ``

Create a function that takes a string and returns that string with the first half lowercased and the last half uppercased. eg: foobar == fooBAR If it is an odd number then 'round' it up to find which letters to uppercase. See example below.     sillycase("brian")       //         --^-- midpoint       //         bri    first half (lower-cased)       //            AN second half (upper-cased
tl;dr: Create a function that takes a string and returns that string with the first half lowercased and the last half uppercased. If it is an odd number then 'round' it up to find which letters to uppercase.  

Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 
tl;dr: