Consider a game, wherein the player has to guess a target word. All the player knows is the length of the target word. To help them in their goal, the game will accept guesses, and return the number of letters that are in the correct position. Write a method that, given the correct word and the player's guess, returns this number. For example, here's a possible thought process for someone trying to guess the word "dog": ```cs CountCorrectCharacters("dog", "car"); //0 (No letters are in the correct position) CountCorrectCharacters("dog", "god"); //1 ("o") CountCorrectCharacters("dog", "cog"); //2 ("o" and "g") CountCorrectCharacters("dog", "cod"); //1 ("o") CountCorrectCharacters("dog", "bog"); //2 ("o" and "g") CountCorrectCharacters("dog", "dog"); //3 (Correct!) ``` ```python count_correct_characters("dog", "car"); #0 (No letters are in the correct position) count_correct_characters("dog", "god"); #1 ("o") count_correct_characters("dog", "cog"); #2 ("o" and "g") count_correct_characters("dog", "cod"); #1 ("o") count_correct_characters("dog", "bog"); #2 ("o" and "g") count_correct_characters("dog", "dog"); #3 (Correct!) ``` The caller should ensure that the guessed word is always the same length as the correct word, but since it could cause problems if this were not the case, you need to check for this eventuality: ```cs //Throw an InvalidOperationException if the two parameters are of different lengths. ``` ```python #Raise an exception if the two parameters are of different lengths. ``` You may assume, however, that the two parameters will always be in the same case
tl;dr: Write a method that, given the correct word and the player's guess, returns this number. The guessed word should be the same length as the correct word. 

Dreamoon likes sequences very much. So he created a problem about the sequence that you can't find in OEIS:  You are given two integers $d, m$, find the number of arrays $a$, satisfying the following constraints:  The length of $a$ is $n$, $n \ge 1$  $1 \le a_1 < a_2 < \dots < a_n \le d$  Define an array $b$ of length $n$ as follows: $b_1 = a_1$, $\forall i > 1, b_i = b_{i - 1} \oplus a_i$, where $\oplus$ is the bitwise exclusive-or (xor). After constructing an array $b$, the constraint $b_1 < b_2 < \dots < b_{n - 1} < b_n$ should hold.  Since the number of possible arrays may be too large, you need to find the answer modulo $m$. 
tl;dr: You are given two integers $d, m$, find the number of arrays $a$, with constraints. The length of $a$ is $n$, $n \ge 1$  $1 \le a_1 < a_2 < \dots < a_n \le d$   Define an array $b$ of length $n$ as follows: $b_1 = a_1$, $\forall i > 1, b_i = b_{i - 1} \oplus a_i$,  where $\oplus$ is the bitwise exclusive-or.  After constructing an array $b$, the constraint $b_1 < b_2 < \dots < b_{n - 1} < b_n$ should hold.  You need to find the answer modulo $m$. 

You are given $W$, a set of $N$ words that are anagrams of each other. There are no duplicate letters in any word. A set of words $S \subseteq W$ is called  swap-free  if there is no way to turn a word $x \in S$ into another word $y \in S$ by swapping only a single pair of (not necessarily adjacent) letters in $x$. Find the size of the largest swap-free set $S$ chosen from the given set $W$. 
tl;dr: