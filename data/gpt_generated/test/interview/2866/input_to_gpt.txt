# Description "It's the end of trick-or-treating and we have a list/array representing how much candy each child in our group has made out with. We don't want the kids to start arguing, and using our parental intuition we know trouble is brewing as many of the children in the group have received different amounts of candy from each home.  So we want each child to have the same amount of candies, only we can't exactly take any candy away from the kids, that would be even worse. Instead we decide to give each child extra candy until they all have the same amount. # Task Your job is to find out how much candy each child has, and give them each additional candy until they too have as much as the child(ren) with the most candy. You also want to keep a total of how much candy you've handed out because reasons." Your job is to give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1.  In the first case (look below) the most candies are given to second kid (i.e second place in list/array), 8. Because of that we will give the first kid 3 so he can have 8 and the third kid 2 and the fourth kid 4, so all kids will have 8 candies.So we end up handing out 3 + 2 + 4 = 9. ```python candies ([5,8,6,4]) # return 9 candies ([1,2,4,6]) # return 11 candies ([1,6]) # return 5 candies ([]) # return -1 candies ([6]) # return -1 (because only one kid) ``` ```cs CandyProblem.GetMissingCandies(new [] {5, 6, 8, 4}) // return 9 CandyProblem.GetMissingCandies(new [] {1, 2, 4, 6}) // return 11 CandyProblem.GetMissingCandies(new [] { }) // return -1 CandyProblem.GetMissingCandies(new [] {1, 6}) // return 5 ``` ```haskell  candies [5,8,6,4] -- return 9 candies [1,2,4,6] -- return 11 candies [] -- return -1 candies [1,6] -- return 5 ``
tl;dr: # Task Given a list/array representing how much candy each child in our group has made out with, give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1.  ```python candies ([5,8,6,4]) # return 9 candies ([1,2,4,6]) # return 11 candies ([1,6]) # return 5 candies ([]) # return -1 candies ([6]) # return -1 (because only one kid) ``` ```cs CandyProblem.GetMissingCandies(new [] {5, 6, 8, 4}) // return 9 CandyProblem.GetMissingCandies(new [] {1, 2, 4, 6}) // return 11 CandyProblem.GetMissingCandies(new [] { }) // return -1 CandyProblem.GetMissingCandies(new [] {1, 6}) // return 5 ``` ```haskell  candies [5,8,6,4] -- return 9 candies [1,2,4,6] -- return 11 candies [] -- return -1 candies [1,6] -- return 5 ``

The Little Elephant from the Zoo of Lviv has an array A that consists of N positive integers. Let A[i] be the i-th number in this array (i = 1, 2, ..., N). Find the minimal number x > 1 such that x is a divisor of all integers from array A. More formally, this x should satisfy the following relations: A[1] mod x = 0, A[2] mod x = 0, ..., A[N] mod x = 0, where mod stands for the modulo operation. For example,  8 mod 3 = 2,  2 mod 2 = 0, 100 mod 5 = 0 and so on. If such number does not exist, output -1. 
tl;dr: You are given an array A that consists of N positive integers. Find the minimal number x > 1 such that x is a divisor of all integers from array A.  If such number does not exist, output -1. 

The technology behind the fridge has changed little over the years. Even so, many of the original owners of the Fred W. Wolf domestic refrigerator of 1913 would be amazed by the size and features of the modern appliances. However, since the 1960s one thing has been common for all fridge owners around the world: fridge magnets. An effective, albeit lazy, way to keep a small child entertained is to supply them with a set of magnetic numbers and a large magnetic surface, such as said fridge, to provide the playing field upon which to apply these digits. Far from a time-wasting exercise, this provides valuable training in the mathematical field of counting: moving the digits around to form  1 ,  2 , and so on up to such heights as  10 ,  11 ,  12 , and even beyond. The possibilities are endless! ...Or at least, they would be, if the supply of digits was not limited. Given the full list of what numbers we are in possession of, what is the smallest positive number that cannot be made using each of digits at most once  
tl;dr: