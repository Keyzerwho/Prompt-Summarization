Initially, you have the array $a$ consisting of one element $1$ ($a = [1]$). In one move, you can do one of the following things:   Increase some (single) element of $a$ by $1$ (choose some $i$ from $1$ to the current length of $a$ and increase $a_i$ by one);  Append the copy of some (single) element of $a$ to the end of the array (choose some $i$ from $1$ to the current length of $a$ and append $a_i$ to the end of the array).  For example, consider the sequence of five moves:   You take the first element $a_1$, append its copy to the end of the array and get $a = [1, 1]$.  You take the first element $a_1$, increase it by $1$ and get $a = [2, 1]$.  You take the second element $a_2$, append its copy to the end of the array and get $a = [2, 1, 1]$.  You take the first element $a_1$, append its copy to the end of the array and get $a = [2, 1, 1, 2]$.  You take the fourth element $a_4$, increase it by $1$ and get $a = [2, 1, 1, 3]$.  Your task is to find the minimum number of moves required to obtain the array with the sum at least $n$. You have to answer $t$ independent test cases. 
tl;dr: You are given an array $a$ consisting of one element $1$ ($a = [1]$). In one move, you can do one of the following things:   Increase some (single) element of $a$ by $1$ (choose some $i$ from $1$ to the current length of $a$ and increase $a_i$ by one);  Append the copy of some (single) element of $a$ to the end of the array (choose some $i$ from $1$ to the current length of $a$ and append $a_i$ to the end of the array).  Your task is to find the minimum number of moves required to obtain the array with the sum at least $n$. You have to answer $t$ independent test cases. 

An element in an array is dominant if it is greater than all elements to its right. You will be given an array and your task will be to return a list of all dominant elements. For example: ```Haskell solve([1,21,4,7,5]) = [21,7,5] because 21, 7 and 5 are greater than elments to their right.  solve([5,4,3,2,1]) = [5,4,3,2,1] Notice that the last element is always included. ``` More examples in the test cases. Good luck
tl;dr: An element in an array is dominant if it is greater than all elements to its right. You will be given an array and your task will be to return a list of all dominant elements.  For example: 

Kate likes to count words in text blocks. By words she means continuous sequences of English alphabetic characters (from a to z ). Here are examples: `Hello there, little user5453 374 ())$. I d been using my sphere as a stool. Slow-moving target 839342 was hit by OMGd-63 or K4mp.` contains "words" `['Hello', 'there', 'little', 'user', 'I', 'd', 'been', 'using', 'my','sphere', 'as', 'a', 'stool', 'Slow', 'moving', 'target', 'was', 'hit', 'by', 'OMGd', 'or', 'K', 'mp']` Kate doesn't like some of words and doesn't count them. Words to be excluded are "a", "the", "on", "at", "of", "upon", "in" and "as", case-insensitive. Today Kate's too lazy and have decided to teach her computer to count "words" for her. 
tl;dr: Kate count words which means continuous sequences of English alphabetic characters. Here are examples: `Hello there, little user5453 374 ())$. I d been using my sphere as a stool. Slow-moving target 839342 was hit by OMGd-63 or K4mp.` contains "words" `['Hello', 'there', 'little', 'user', 'I', 'd', 'been', 'using', 'my','sphere', 'as', 'a', 'stool', 'Slow', 'moving', 'target', 'was', 'hit', 'by', 'OMGd', 'or', 'K', 'mp']` Kate doesn't count "a", "the", "on", "at", "of", "upon", "in" and "as". Kate has decided to teach her computer to count "words" for her. 

Brandon Greg Jr. is moving to the United States to double his salary. He has $n$ items that he needs to pack into $k$ big boxes. The $n$ items are currently arranged in a row, and Brandon doesn t want to bother reordering them, so he will partition the $n$ items into $k$ groups of consecutive items, and put each of the $k$ groups into their own box. For convenience when moving, Brandon wants to minimize the weight of the heaviest box. The weights of the boxes themselves are negligible. 
tl;dr: