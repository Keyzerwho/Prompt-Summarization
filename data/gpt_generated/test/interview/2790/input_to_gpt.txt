In Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed. Let the total number of sequences listed in FEIS be X. Among those sequences, find the (X/2)-th (rounded up to the nearest integer) lexicographically smallest one. -----Constraints-----  - 1 \leq N,K \leq 3   10^5  - N and K are integers. 
tl;dr: In FEIS, all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed. Let the total number of sequences listed in FEIS be X.  Find the (X/2)-th lexicographically smallest one. -----Constraints-----  - 1 \leq N,K \leq 3   10^5 

Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group.  Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. 
tl;dr: You are given N people to be split into two groups such that given dislikes[i] = [a, b], a and b should be in different groups. You need to return true if such split is possible. 

You will be given the prime factors of a number as an array. E.g: ```[2,2,2,3,3,5,5,13]``` You need to find the number, n, to which that prime factorization belongs. It will be: ``` n = 2 .3 .5 .13 = 23400 ``` Then, generate the divisors of this number. Your function ```get_num() or getNum()``` will receive an array with potentially unordered prime factors and should output: an array with the found integer n at index 0, the amount of total divisors (both prime and compound numbers) at index 1, followed the smallest factor (index 2, and the biggest one (last element) We will see the example given above with the only difference that the array of the prime factors is unordered. The list of divisors for that number (23400) is: ``` 2, 3, 4, 5, 6, 8, 9, 10, 12, 13, 15, 18, 20, 24, 25, 26, 30, 36, 39, 40, 45, 50, 52, 60, 65, 72, 75, 78, 90, 100, 104, 117, 120, 130, 150, 156, 180, 195, 200, 225, 234, 260, 300, 312, 325, 360, 390, 450, 468, 520, 585, 600, 650, 780, 900, 936, 975, 1170, 1300, 1560, 1800, 1950, 2340, 2600, 2925, 3900, 4680, 5850, 7800, 11700 (not considering the integer 23400 itself) ``` There is a total amount of ```71``` divisors. The smallest divisor is ```2``` and the highest ```11700```. So the expected output will be:  ``` get_num([2,13,2,5,2,5,3,3]) == [23400, 71, 2, 11700] ``` Enjoy
tl;dr: Write a function get_num() or getNum() that receives an array with potentially unordered prime factors and output: an array with the found integer n at index 0, the amount of total divisors at index 1, followed the smallest factor and the biggest one. 

Gerald s job is to welcome the teams for this year s NWERC at the airport in Link ping. One of his duties is to stand at the luggage carousel and collect all the knapsacks that the teams are bringing. Gerald is a lazy person, so he just stands at the same position of the carousel and waits for bags to pass by so he can pick them up.  The baggage carousel consists of $s$ luggage slots, numbered in ascending order from $0$ to $s-1$. Since the baggage carousel is cyclic, luggage slots $s-1$ and $0$ also lie side by side. The carousel turns in such a way that if Gerald stands in front of slot $i$ at some point in time, he will stand in front of slot $(i+1) \bmod s$ one time unit later. In the beginning Gerald prepares a huge baggage cart at some position and stands there to wait for luggage. When a knapsack arrives in front of Gerald, he needs $t$ time units to take it and put it on the baggage cart. After these $t$ time units he is ready to pick up another knapsack. As long as there are remaining knapsacks on the luggage carousel, Gerald always takes the next one to arrive at his position as soon as he is ready after putting away the previous one. Now Gerald wonders about the effect of his choice of position on the time it will take him to finish this task. It is up to you to help Gerald calculate the minimum, maximum, and average time to pick up all knapsacks, taken over all $s$ possible slots, which can appear in front of Gerald after preparation. Time starts when he has prepared the baggage cart at some slot of the baggage carousel and ends after he has put the last knapsack on the cart. 
tl;dr: