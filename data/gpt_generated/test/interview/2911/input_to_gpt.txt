Sonya was unable to think of a story for this problem, so here comes the formal description. You are given the array containing n positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0. 
tl;dr: You are given the array containing n positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0. 

You wrote all your unit test names in camelCase. But some of your colleagues have troubles reading these long test names. So you make a compromise to switch to underscore separation. To make these changes fast you wrote a class to translate a camelCase name into an underscore separated name. Implement the ToUnderscore() method. 
tl;dr: Implement the ToUnderscore() method to translate a camelCase name into an underscore separated name.  

#Permutation  position In this kata you will have to permutate through a string of lowercase letters, each permutation will start at ```a``` and you must calculate how many iterations it takes to reach the current permutation. ##examples ``` input: 'a' result: 1 input: 'c' result: 3 input: 'z' result: 26 input: 'foo' result: 3759 input: 'aba' result: 27 input: 'abb' result: 28 ``
tl;dr: You will have to permutate through a string of lowercase letters, each permutation will start at a and you must calculate how many iterations it takes to reach the current permutation. 

You just finished participating in a programming contest with your friend. Unfortunately, you were unable to All Kill the contest (i.e., solve all of the problems), but you are now wondering if there might be some strategy that would have solved all of the problems. Solving a problem has two phases, a thinking phase and a coding phase. Your friend is responsible for all the thinking while you are responsible for all the coding. For each problem, you ve computed exactly how long it would take for you to code. However, before you can code a problem in contest, your friend needs to get the idea to solve it first. You aren t sure how to estimate the time when your friend gets a solution idea, so you model it like this: For every problem, your friend gets the idea of how to solve this problem at a uniformly random minute during the contest. Each of these is an independent random variable. You can only code one problem at a time, so there may be several problems queued up at any moment of time. You always prioritize coding the lowest numbered problems first. You do this minute-by-minute, so you will switch to coding a lower-numbered problem if your friend gets the idea for it before you re finished coding a higher-numbered problem, but you would prefer not to do this. Context switching is an expensive operation, even in the human brain! The contest strategy can be modeled as follows for each minute:  - For each problem that doesn t yet have an idea, your friend will get the idea to solve it with probability $1/(\textrm{number of minutes remaining in contest})$. Your friend can get the idea to solve multiple problems in the same minute.  - Among the problems that still need code time and your friend has gotten the solution idea, you will take the lowest numbered one and spend the next minute coding it (if no problem satisfies the condition, you do nothing at this step). You would like to know the probability of these two events happening together:  - Your team finishes coding all the problems by the end of the contest  - For each problem, the time spent coding that problem is a contiguous interval Let $p$ be this probability, $n$ be the number of problems in the contest and $t$ be the number of minutes in the contest. It can be shown that $p \cdot t^n$ is an integer. Output the value of $(p \cdot t^n) \pmod{998244353}$. Note that $998244353$ is a large prime. 
tl;dr: