Given an D-dimension array, where each axis is of length N, your goal is to find the sum of every index in the array starting from 0. For 
tl;dr: Given an D-dimension array, where each axis is of length N, your goal is to find the sum of every index in the array starting from 0. 

Given a credit card number we can determine who the issuer/vendor is with a few basic knowns. ```if:python Complete the function `get_issuer()` that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`. ``` ```if-not:python Complete the function `getIssuer()` that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`. ``` ```if:typescript Where `Issuer` is defined with the following enum type. ~~~typescript enum Issuer {   VISA = 'VISA',   AMEX = 'AMEX',   Mastercard = 'Mastercard',   Discover = 'Discover',   Unknown = 'Unknown', } ~~~ ``` ```markdown | Card Type  | Begins With          | Number Length | |------------|----------------------|---------------| | AMEX       | 34 or 37             | 15            | | Discover   | 6011                 | 16            | | Mastercard | 51, 52, 53, 54 or 55 | 16            | | VISA       | 4                    | 13 or 16      | ``` ```if:c,cpp **C/C++ note:** The return value in C is not freed. ``` ## 
tl;dr: ```if:python Complete the function `get_issuer()` that will determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`. ``` ```if-not:python Complete the function `getIssuer()` that will determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`. ``` ```if:typescript Where `Issuer` is defined with the following enum type. ~~~typescript enum Issuer {   VISA = 'VISA',   AMEX = 'AMEX',   Mastercard = 'Mastercard',   Discover = 'Discover',   Unknown = 'Unknown', } ~~~ ``` ```markdown | Card Type  | Begins With          | Number Length | |------------|----------------------|---------------| | AMEX       | 34 or 37             | 15            | | Discover   | 6011                 | 16            | | Mastercard | 51, 52, 53, 54 or 55 | 16            | | VISA       | 4                    | 13 or 16      | ``` ```if:c,cpp **C/C++ note:** The return value in C is not freed. ``` ## 

Chef is good at making pancakes. Generally he gets requests to serve N pancakes at once. He serves them in the form of a stack. A pancake can be treated as a circular disk with some radius. Chef needs to take care that when he places a pancake on the top of the stack the radius of the pancake should not exceed the radius of the largest pancake in the stack by more than 1.  Additionally all radii should be positive integers, and the bottom most pancake should have its radius as 1. Chef wants you to find out in how many ways can he create a stack containing N pancakes. Input First line of the input contains T (T <= 1000) denoting the number of test cases. T lines follow each containing a single integer N (1 <= N <= 1000) denoting the size of the required stack. Output For each case the output should be a single integer representing the number of ways a stack of size N can be created. As the answer can be large print it modulo 1000000007. 
tl;dr: Find the number of ways in which a stack of circular disk can be arranged in such a way that radius of disk on the top of the stack should not exceed the radius of the largest disk in the stack by more than 1.  The bottom most disk should have its radius as 1. Input First line of the input contains T (T <= 1000) denoting the number of test cases. T lines follow each containing a single integer N (1 <= N <= 1000) denoting the size of the required stack. Output For each case the output should be a single integer representing the number of ways a stack of size N can be created. As the answer can be large print it modulo 1000000007. 

VisuAlgo (http://visualgo.net) is a website developed by a team of staff and students of School of Computing, National University of Singapore, the host of the 2015 ACM-ICPC Asia Singapore Regional. VisuAlgo visualizes a number of popular data structures and algorithms in the Computer Science curriculum. Currently, it receives approximately 2000 hits/day from CS students and instructors worldwide. One new feature of VisuAlgo is the online quiz. As an example, the above figure shows a question about the classic Single-Source (Single-Destination) Shortest Paths problem in graph theory. The beauty of this online quiz feature is that the question parameters are randomized. The drawn graph G is taken from a collection of hundreds of directed weighted graphs (with their 2-D layouts) in VisuAlgo s internal database. The graph G has $V$ vertices numbered from $[0..V-1]$. The source vertex $s$ and the destination vertex $t$ are selected at random from $[0..V-1]$. However, such randomization of the question parameters may produce either a trivial question (e.g.  No Answer  when $s$ and $t$ are disconnected, $0$ when $s = t$, simple tracing of a path if there is only a single unique path from $s$ to $t$ as shown in the above figure) or insanely difficult question to be computed manually if there are too many possible shortest paths from $s$ to $t$. The developers of VisuAlgo want to calibrate such Shortest Paths question with randomized parameters so that it is possible for a normal Computer Science student to answer the randomly generated question manually within a reasonable amount of time. Please help them. 
tl;dr: