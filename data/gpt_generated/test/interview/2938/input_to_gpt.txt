In Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed. Let the total number of sequences listed in FEIS be X. Among those sequences, find the (X/2)-th (rounded up to the nearest integer) lexicographically smallest one. -----Constraints-----  - 1 \leq N,K \leq 3   10^5  - N and K are integers. 
tl;dr: In FEIS, all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed. Let the total number of sequences listed in FEIS be X.  Find the (X/2)-th lexicographically smallest one. -----Constraints-----  - 1 \leq N,K \leq 3   10^5 

You will be given the prime factors of a number as an array. E.g: ```[2,2,2,3,3,5,5,13]``` You need to find the number, n, to which that prime factorization belongs. It will be: ``` n = 2 .3 .5 .13 = 23400 ``` Then, generate the divisors of this number. Your function ```get_num() or getNum()``` will receive an array with potentially unordered prime factors and should output: an array with the found integer n at index 0, the amount of total divisors (both prime and compound numbers) at index 1, followed the smallest factor (index 2, and the biggest one (last element) We will see the example given above with the only difference that the array of the prime factors is unordered. The list of divisors for that number (23400) is: ``` 2, 3, 4, 5, 6, 8, 9, 10, 12, 13, 15, 18, 20, 24, 25, 26, 30, 36, 39, 40, 45, 50, 52, 60, 65, 72, 75, 78, 90, 100, 104, 117, 120, 130, 150, 156, 180, 195, 200, 225, 234, 260, 300, 312, 325, 360, 390, 450, 468, 520, 585, 600, 650, 780, 900, 936, 975, 1170, 1300, 1560, 1800, 1950, 2340, 2600, 2925, 3900, 4680, 5850, 7800, 11700 (not considering the integer 23400 itself) ``` There is a total amount of ```71``` divisors. The smallest divisor is ```2``` and the highest ```11700```. So the expected output will be:  ``` get_num([2,13,2,5,2,5,3,3]) == [23400, 71, 2, 11700] ``` Enjoy
tl;dr: Write a function get_num() or getNum() that receives an array with potentially unordered prime factors and output: an array with the found integer n at index 0, the amount of total divisors at index 1, followed the smallest factor and the biggest one. 

The chef was searching for his pen in the garage but he found his old machine with a display and some numbers on it. If some numbers entered then some different output occurs on the display. Chef wants to crack the algorithm that the machine is following. 
tl;dr: Write a code to print the average of the multiplication of a given number N with N-1 integer.                                    1 

Chess has been a long time passion of Yraglac. He spents at least an hour per day playing chess matches online or reading chess tactics books. The game is played by two players on an $8 \times 8$ grid, with each player taking turns to move a piece. In this problem, we will consider a simplified variant of chess consisting of two kinds of pieces: kings and rooks. Kings can move one square in any direction while rooks can move any number of squares up/down or left/right. Pieces can either move to an unoccupied square or to a square occupied by an opponent s piece, which is captured and removed from play. A piece is threatened when an opponent s piece is able to capture the piece in a single move. It is illegal to move one own s king to a position where it is threatened (but it is legal to do so for a rook). A player is considered to be in checkmate when it is their turn, their king is threatened, and all possible moves will result in the king still being threatened. Yraglac is a skilled player and has managed to reach a situation where he has one king and one rook, while his opponent only has one king. Given that it is Yraglac s turn, can he checkmate his opponent in a single move  
tl;dr: