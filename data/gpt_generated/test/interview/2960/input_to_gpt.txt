Dima is a beginner programmer. During his working process, he regularly has to repeat the following operation again and again: to remove every second element from the array. One day he has been bored with easy solutions of this problem, and he has come up with the following extravagant algorithm. Let's consider that initially array contains n numbers from 1 to n and the number i is located in the cell with the index 2i - 1 (Indices are numbered starting from one) and other cells of the array are empty. Each step Dima selects a non-empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one. The process continues until all n numbers will appear in the first n cells of the array. For example if n = 4, the array is changing as follows: [Image]  You have to write a program that allows you to determine what number will be in the cell with index x (1   x   n) after Dima's algorithm finishes. 
tl;dr: You are given an array consisting of n numbers from 1 to n and the number i is located in the cell with the index 2i - 1 (Indices are numbered starting from one) and other cells of the array are empty. Each step you selects a non-empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one. The process continues until all n numbers will appear in the first n cells of the array. For example if n = 4, the array is changing as follows: [Image]  You have to write a program that allows you to determine what number will be in the cell with index x (1   x   n) after your algorithm finishes. summary :  

Implement a function which  creates a **[radix tree](https://en.wikipedia.org/wiki/Radix_tree)** (a space-optimized trie [prefix tree])  in which each node that is the only child is merged with its parent [unless a word from the input ends there])  from a given list of words  using dictionaries (aka hash maps or hash tables) where: 1. The dictionary keys are the nodes. 2. Leaf nodes are empty dictionaries. 3. The value for empty input is an empty dictionary. 4. Words are all lowercase or empty strings. 5. Words can contain duplicates. ### 
tl;dr: Implement a function which creates a radix tree in which each node that is the only child is merged with its parent from a given list of words using dictionaries where: 1. The dictionary keys are the nodes. 2. Leaf nodes are empty dictionaries. 3. The value for empty input is an empty dictionary. 4. Words are all lowercase or empty strings. 5. Words can contain duplicates. 

For an array $b$ of length $m$ we define the function $f$ as  $ f(b) = \begin{cases} b[1] & \quad \text{if } m = 1 \\ f(b[1] \oplus b[2],b[2] \oplus b[3],\dots,b[m-1] \oplus b[m]) & \quad \text{otherwise,} \end{cases} $  where $\oplus$ is bitwise exclusive OR. For example, $f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$ You are given an array $a$ and a few queries. Each query is represented as two integers $l$ and $r$. The answer is the maximum value of $f$ on all continuous subsegments of the array $a_l, a_{l+1}, \ldots, a_r$. 
tl;dr: For an array $b$ of length $m$ we define the function $f$ as  $ f(b) = \begin{cases} b[1] & \quad \text{if } m = 1 \\ f(b[1] \oplus b[2],b[2] \oplus b[3],\dots,b[m-1] \oplus b[m]) & \quad \text{otherwise,} \end{cases} $  where $\oplus$ is bitwise exclusive OR. You are given an array $a$ and a few queries. Each query is represented as two integers $l$ and $r$. The answer is the maximum value of $f$ on all continuous subsegments of the array $a_l, a_{l+1}, \ldots, a_r$. 

You might be familiar with the binomial coefficient ${m \choose k}$ defined as ${m \choose k} = \frac{m!}{k!(m-k)!}$, where $m$ and $k$ are non-negative integers and $k \leq m$. Let $T_2(n)$ be the number of odd binomial coefficients such that $0 \le k \le m < n$. The most useful mathematical inequality you will learn during this competition is\[ 0.812556 n^{\log _2 3} \le T_2(n) \le n^{\log _2 3}. \] Emma doesn t like such imprecise inequalities and would like to calculate $T_2(n)$ exactly. Can you help her  
tl;dr: