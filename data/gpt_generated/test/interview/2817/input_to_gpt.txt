Given two strings representing two complex numbers. You need to return a string representing their multiplication. Note i2 = -1 according to the definition. 
tl;dr: Write program to return a string representing the multiplication of given two  strings of complex numbers. 

An array of integers $p_{1},p_{2}, \ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once. For example, the following arrays are permutations: $[3,1,2], [1], [1,2,3,4,5]$ and $[4,3,1,2]$. The following arrays are not permutations: $[2], [1,1], [2,3,4]$. There is a hidden permutation of length $n$. For each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$. In other words, $s_i$ is the sum of elements before the $i$-th element that are smaller than the $i$-th element. Your task is to restore the permutation. 
tl;dr: An array of integers $p_{1},p_{2}, \ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once. There is a hidden permutation of length $n$. For each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$. Your task is to restore the permutation. 

We have a set of consecutive numbers from ```1``` to ```n```. We want to count all the subsets that do not contain consecutive numbers. E.g. If our set ```S1``` is equal to ```[1,2,3,4,5]``` The subsets that fulfill these property are: ``` [1],[2],[3],[4],[5],[1,3],[1,4],[1,5],[2,4],[2,5],[3,5],[1,3,5] ``` A total of      ```12   ``` subsets. From the set ```S2``` equals to```[1,2,3]```, it is obvious that we have only ```4``` subsets and are: ``` [1],[2],[3],[1,3] ``` Make a code that may give the amount of all these subsets for any integer       ```n >= 2       ```. Features of the random tests: ``` number of tests = 100  10 <= n <= 120 ``
tl;dr: We have a set of consecutive numbers from ```1``` to ```n```. We want to count all the subsets that do not contain consecutive numbers. E.g. If ```S1``` is ```[1,2,3,4,5]``` The qualified subsets are: ``` [1],[2],[3],[4],[5],[1,3],[1,4],[1,5],[2,4],[2,5],[3,5],[1,3,5] ``` A total of      ```12   ``` subsets. If ```S2``` is ```[1,2,3]```, we have only ```4``` qualified subsets : ``` [1],[2],[3],[1,3] ``` Make a code that may give the amount of all these subsets for any integer       ```n >= 2       ```. Features of the random tests: ``` number of tests = 100  10 <= n <= 120 ``

In competitive weightlifting, you must perform a sequence of lifts. You have a constant strength $s$, and a decreasing energy reserve $e$. For each lift, you may choose any positive (not necessarily integer) weight $w$ to attempt. If $s \ge w$, the lift succeeds and your energy goes down by $e_{\text {success}}$; if $s < w$, the lift fails and your energy goes down by $e_{\text {failure}}$. You may continue attempting lifts as long as $e > 0$. If at any point $e \le 0$, you can make no further attempts. Your score is the maximum weight you successfully lift or $0$ if every attempt failed. Ideally, you should lift exactly at your strength limit. However, you do not know your strength $s$. You only know that you can definitely lift the empty bar ($25\text { kg}$), and that the maximum conceivable lift is $225\text { kg}$. How close to an optimal score can you guarantee  That is, what s the smallest $d$ for which you can ensure a score of at least $s-d$  For example, suppose $e = 4$, $e_{\text {success}} = 1$ and $e_{\text {failure}} = 2$. You try to lift $200\text { kg}$ and fail. Now, $e = 2$. You try $100\text { kg}$ and succeed. Now, $e = 1$. You try $150\text { kg}$ and succeed. Now, $e = 0$ and you must stop. You know that you can lift $150\text { kg}$, but you cannot lift $200\text { kg}$. Your strength $s$ must be somewhere between $150\text { kg}$ and $200\text { kg}$. You scored $150$, your optimal score might be as high as (just under) $200$. You still don t know $s$, but you know you re within $50$. In this case, $d = 50$. That s a specific example, and the strategy used is certainly not optimal. You can do better. What s the smallest value of $d$ you can get so that you can guarantee a score of at least $s-d$ for any and all possible values of $s$  
tl;dr: