Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting. Suppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \in A$ or $v \in A$ (or both). Pari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover. They have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself). 
tl;dr: You are given a graph with $n$ vertices and $m$ edges. You should find two disjoint subsets of its vertices A and B, such that both A and B are vertex covers or claim it's impossible. 

The factorial of a number, `n!`, is defined for whole numbers as the product of all integers from `1` to `n`.  For example, `5!` is `5 * 4 * 3 * 2 * 1 = 120` Most factorial implementations use a recursive function to determine the value of `factorial(n)`. However, this blows up the stack for large values of `n` - most systems cannot handle stack depths much greater than 2000 levels. Write an implementation to calculate the factorial of arbitrarily large numbers, *without recursion.* # Rules * `n < 0` should return `nil`/  `None` * `n = 0` should return `1` * `n > 0` should return `n!` # Note Codewars limits the amount of data it will send back and forth, which may introduce a false ceiling for how high of a value of `n` it will accept. All tests use values less than this limit
tl;dr: The factorial of a number, `n!`, is defined for whole numbers as the product of all integers from `1` to `n`.  Write an implementation to calculate the factorial of arbitrarily large numbers, without recursion. # Rules * `n < 0` should return `nil`/  `None` * `n = 0` should return `1` * `n > 0` should return `n!

**This Kata is intended as a small challenge for my students** All Star Code Challenge #16 Create a function called noRepeat() that takes a string argument and returns a single letter string of the **first** not repeated character in the entire string. ``` haskell noRepeat "aabbccdde" `shouldBe` 'e' noRepeat "wxyz"      `shouldBe` 'w' noRepeat "testing"   `shouldBe` 'e' ``` 
tl;dr: Create a function called noRepeat() that takes a string argument and returns a single letter string of the first not repeated character in the entire string. 

Damir likes to rotate. Right now he is rotating tables of letters. He wrote an $R\times C$ table onto a piece of paper. He has also chosen an angle $K$, a multiple of $45$, and wants to rotate his table that many degrees clockwise. It turns out this task is a bit too hard for Damir, so help him out. 
tl;dr: