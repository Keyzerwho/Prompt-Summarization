Create a function with two arguments that will return an array of the first (n) multiples of (x).  Assume both the given number and the number of times to count will be positive numbers greater than 0.  Return the results as an array (or list in Python, Haskell or Elixir). 
tl;dr: Create a function with two arguments that will return an array of the first n multiples of x. Assume both the given number and the number of times to count will be positive numbers greater than 0.  

There are N bags, each containing two white balls. The i-th box contains two balls with integers x_i and y_i written on them, respectively. For each of these bags, you will paint one of the balls red, and paint the other blue. Afterwards, the 2N balls will be classified according to color. Then, we will define the following:  - R_{max}: the maximum integer written on a ball painted in red  - R_{min}: the minimum integer written on a ball painted in red  - B_{max}: the maximum integer written on a ball painted in blue  - B_{min}: the minimum integer written on a ball painted in blue Find the minimum possible value of (R_{max} - R_{min}) \times (B_{max} - B_{min}). -----Constraints-----  - 1   N   200,000  - 1   x_i, y_i   10^9 
tl;dr: There are N bags, each containing two white balls. The i-th box contains two balls with integers x_i and y_i written on them, respectively. For each of these bags, you will paint one of the balls red, and paint the other blue. Afterwards, the 2N balls will be classified according to color. Then, we will define the following:  - R_{max}: the maximum integer written on a ball painted in red  - R_{min}: the minimum integer written on a ball painted in red  - B_{max}: the maximum integer written on a ball painted in blue  - B_{min}: the minimum integer written on a ball painted in blue Find the minimum possible value of (R_{max} - R_{min}) \times (B_{max} - B_{min}). -----Constraints-----  - 1   N   200,000  - 1   x_i, y_i   10^9 

To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing. For example, if we have S = "abcd" and we have some replacement operation i = 2, x = "cd", y = "ffff", then because "cd" starts at position 2 in the original string S, we will replace it with "ffff". Using another example on S = "abcd", if we have both the replacement operation i = 0, x = "ab", y = "eee", as well as another replacement operation i = 2, x = "ec", y = "ffff", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = "abc", indexes = [0, 1], sources = ["ab","bc"] is not a valid test case. 
tl;dr: You are given following inputs: original string S, starting index i, source word x and target word y.  If x starts at position i in S, you need to replace that occurrence of x with y. Consider: 0 <= indexes.length = sources.length = targets.length <= 100 0 < indexes[i] < S.length <= 1000 All characters in given inputs are lowercase letters. 

Luke likes to ride on public transit in different cities he visits, just for fun. He tries to find unique ways to travel in loops: leaving from one transit station, traveling along the transit connections to at least one other station, and returning to the station where he started. He is finding lots of loops, and he wants to know just how many there are in different transit systems. There may be so many he won t ever have time to try them all, but he ll find some satisfaction in knowing they are there. He s particularly interested in counting simple loops. A simple loop is a sequence of unique transit stations $t_1, t_2, \ldots , t_ j$, where there s a way to connect directly from $t_ i$ to $t_{i+1}$ for $1 \leq i < j$ and also from $t_ j$ to $t_1$. Of course, we can write down a simple loop starting with of the stations in the loop, therefore we consider any cyclic shift of such a sequence to be the same simple loop. However, two simple loops which visit the same set of transit stations in a different order are considered distinct. Help Luke by writing a program to count how many unique simple loops there are in each transit system. The following figures illustrate the transit stations (numbered ovals) and one-way connections (arrows) of the sample input.   
tl;dr: