Tavak and Seyyed are good friends. Seyyed is very funny and he told Tavak to solve the following problem instead of longest-path. You are given l and r. For all integers from l to r, inclusive, we wrote down all of their integer divisors except 1. Find the integer that we wrote down the maximum number of times. Solve the problem to show that it's not a NP problem. 
tl;dr: You are given l and r. For all integers from l to r, inclusive, we wrote down all of their integer divisors except 1. Find the integer that we wrote down the maximum number of times. Solve the problem to show that it's not a NP problem. summary :  

In this Kata your task will be to return the count of pairs that have consecutive numbers as follows: ```Haskell pairs([1,2,5,8,-4,-3,7,6,5]) = 3 The pairs are selected as follows [(1,2),(5,8),(-4,-3),(7,6),5] --the first pair is (1,2) and the numbers in the pair are consecutive; Count = 1 --the second pair is (5,8) and are not consecutive --the third pair is (-4,-3), consecutive. Count = 2 --the fourth pair is (7,6), also consecutive. Count = 3.  --the last digit has no pair, so we ignore. ``` More examples in the test cases.  Good luck! Please also try [Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2
tl;dr: Your task will be to return the count of pairs that have consecutive numbers as follows: ```Haskell pairs([1,2,5,8,-4,-3,7,6,5]) = 3 The pairs are selected as follows [(1,2),(5,8),(-4,-3),(7,6),5] --the first pair is (1,2) and are consecutive; Count = 1 --the second pair is (5,8) and are not consecutive --the third pair is (-4,-3), consecutive. Count = 2 --the fourth pair is (7,6), consecutive. Count = 3.  --the last digit has no pair, so we ignore. ``` Please also try [Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2

You are given a sequence a1, a2, ..., aN. Find the smallest possible value of ai + aj, where 1   i < j   N. 
tl;dr: You are given a sequence a1, a2, ..., aN. Find the smallest possible value of ai + aj, where 1   i < j   N. 

Many phones use a nine-pivot unlock pattern. The nine pivots are arranged as a $3 \times 3$ grid, and numbered from $1$ to $9$ as shown in the figure. The unlock pattern is a single stroke that starts at any pivot and visits each pivot exactly once. The stroke goes in a straight line segment between each pair of consecutive pivots. It may pass a pivot multiple times but only the first time counts as a visit. The phone unlocks if the pivots are visited in a predefined secret order. The figure illustrates an unlock pattern of $2 \rightarrow 5 \rightarrow 3 \rightarrow 6 \rightarrow 7 \rightarrow 4 \rightarrow 1 \rightarrow 8 \rightarrow 9$. Due to physical constraints, it is not possible for the stroke to pass but not visit a pivot if it has not been visited before. For instance, a pattern that starts with $1 \rightarrow 7 \rightarrow \dots $ is invalid because it must visit pivot $4$ before visiting pivot $7$. However, starting with $4 \rightarrow 1 \rightarrow 7 \dots $ is fine because pivot $4$ is already visited when the stroke passes it again.  Consider the directional changes along the unlock pattern. The pattern may take a left turn ( L ), a right turn ( R ), go straight ( S ), or turn around ( A ) at each pivot except for the first and the last pivot. If we write down the directional changes into one string, we get a string of length seven. This is the turn sequence of the unlock pattern. The turn sequence of the unlock pattern shown in the figure is  LRRRSRL . Given a turn sequence, with some of the directional changes replaced by question marks (   ), which mean we can take any direction at those pivots, how many different unlock patterns are consistent with this turn sequence  
tl;dr: