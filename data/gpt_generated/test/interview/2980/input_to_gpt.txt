Dinesh is very fond of sweets recently his aunt Riya gifted him an array $a$ of sweets of size $N$. The ith sweet is of the type $a[i]$. His mother told him that he can choose one type of sweet in a day and eat at most 2 sweets of that type. Since he has to eat all the sweets as quickly as possible because his cousins are arriving. Find out the minimum number of days in which he can eat all the sweets gifted by his aunt Riya.  
tl;dr: You are given an array $a$ of item of size $N$.Only one type of item can be chosen in a day and purchased at most 2 items of that type.Find minimum number of days in which all items are purchased. 

# Fourier transformations are hard. Fouriest transformations are harder. This Kata is based on the SMBC Comic on fourier transformations. A fourier transformation on a number is one that converts the number to a base in which it has more `4`s ( `10` in base `6` is `14`, which has `1` four as opposed to none, hence, fourier in base `6` ). A number's fouriest transformation converts it to the base in which it has the most `4`s.   For example: `35353` is the fouriest in base `6`: `431401`. This kata requires you to create a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened, as follows: ```python fouriest(number) -> "{number} is the fouriest ({fouriest_representation}) in base {base}" ``` ## Important notes * For this kata we don't care about digits greater than `9` ( only `0` to `9` ), so we will represent all digits greater than `9` as `'x'`: `10` in base `11` is `'x'`, `119` in base `20` is `'5x'`, `118` in base `20` is also `'5x'` * When a number has several fouriest representations, we want the one with the LOWEST base ```if:haskell,javascript * Numbers below `9` will not be tested ``` ```if:javascript * A `BigNumber` library has been provided; documentation is [here](https://mikemcl.github.io/bignumber.js/) ``` ## 
tl;dr: Create a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened. 

Arthur and his sister Carol have been playing a game called Nim for some time now. Nim is played as follows:  - The starting position has a number of heaps, all containing some, not necessarily equal, number of beads.  - The players take turns chosing a heap and removing a positive number of beads from it.  - The first player not able to make a move, loses. Arthur and Carol really enjoyed playing this simple game until they recently learned an easy way to always be able to find the best move:  - Xor the number of beads in the heaps in the current position (i.e., if we have $2$, $4$ and $7$ the xor-sum will be $1$ since $2\ \mathbf{xor}\ 4\ \mathbf{xor}\ 7 = 1$).  - If the xor-sum is $0$, too bad, you will lose.  - Otherwise, move such that the xor-sum becomes $0$. This is always possible. It is quite easy to convince oneself that this works. Consider these facts:  - The player that takes the last bead wins.  - After the winning player s last move the xor-sum will be $0$.  - The xor-sum will change after every move. Which means that if you make sure that the xor-sum always is $0$ when you have made your move, your opponent will never be able to win, and, thus, you will win. Understandably it is no fun to play a game when both players know how to play perfectly (ignorance is bliss). Fortunately, Arthur and Carol soon came up with a similar game, $S$-Nim, that seemed to solve this problem. Each player is now only allowed to remove a number of beads in some predefined set $S$, e.g. if we have $S = \{ 2, 5\} $ each player is only allowed to remove $2$ or $5$ beads. Now it is not always possible to make the xor-sum $0$ and, thus, the strategy above is useless. Or is it  Your job is to write a program that determines if a position of $S$-Nim is a losing or a winning position. A position is a winning position if there is at least one move to a losing position. A position is a losing position if there are no moves to a losing position. This means, as expected, that a position with no legal moves is a losing position. 
tl;dr: