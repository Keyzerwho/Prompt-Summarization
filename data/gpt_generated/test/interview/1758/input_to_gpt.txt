=====Problem Statement===== ABCXYZ company has up to 100 employees. The company decides to create a unique identification number (UID) for each of its employees. The company has assigned you the task of validating all the randomly generated UIDs. A valid UID must follow the rules below: It must contain at least 2 uppercase English alphabet characters. It must contain at least 3 digits (0-9). It should only contain alphanumeric characters (a-z, A-Z & 0-9). No character should repeat. There must be exactly 10 characters in a valid UID. 
tl;dr: =====Problem Statement===== You are given a string A valid string must follow the conditions below: It must contain at least 2 uppercase English alphabet characters. It must contain at least 3 digits 0 to 9. It should only contain alphanumeric characters a-z, A-Z & 0-9. No character should repeat. There must be exactly 10 characters in a valid string. 

Dima is a beginner programmer. During his working process, he regularly has to repeat the following operation again and again: to remove every second element from the array. One day he has been bored with easy solutions of this problem, and he has come up with the following extravagant algorithm. Let's consider that initially array contains n numbers from 1 to n and the number i is located in the cell with the index 2i - 1 (Indices are numbered starting from one) and other cells of the array are empty. Each step Dima selects a non-empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one. The process continues until all n numbers will appear in the first n cells of the array. For example if n = 4, the array is changing as follows: [Image]  You have to write a program that allows you to determine what number will be in the cell with index x (1   x   n) after Dima's algorithm finishes. 
tl;dr: You are given an array consisting of n numbers from 1 to n and the number i is located in the cell with the index 2i - 1 (Indices are numbered starting from one) and other cells of the array are empty. Each step you selects a non-empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one. The process continues until all n numbers will appear in the first n cells of the array. For example if n = 4, the array is changing as follows: [Image]  You have to write a program that allows you to determine what number will be in the cell with index x (1   x   n) after your algorithm finishes. summary :  

There are $n$ athletes in front of you. Athletes are numbered from $1$ to $n$ from left to right. You know the strength of each athlete   the athlete number $i$ has the strength $s_i$. You want to split all athletes into two teams. Each team must have at least one athlete, and each athlete must be exactly in one team. You want the strongest athlete from the first team to differ as little as possible from the weakest athlete from the second team. Formally, you want to split the athletes into two teams $A$ and $B$ so that the value $|\max(A) - \min(B)|$ is as small as possible, where $\max(A)$ is the maximum strength of an athlete from team $A$, and $\min(B)$ is the minimum strength of an athlete from team $B$. For example, if $n=5$ and the strength of the athletes is $s=[3, 1, 2, 6, 4]$, then one of the possible split into teams is:   first team: $A = [1, 2, 4]$,  second team: $B = [3, 6]$.  In this case, the value $|\max(A) - \min(B)|$ will be equal to $|4-3|=1$. This example illustrates one of the ways of optimal split into two teams. Print the minimum value $|\max(A) - \min(B)|$. 
tl;dr: You are given a list of $n$ integers. You want to split the integers into two lists. You want the largest integer in the first list $A$ to differ as little as possible from the smallest integer in the second list $B$. 

Naman has two binary strings $s$ and $t$ of length $n$ (a binary string is a string which only consists of the characters "0" and "1"). He wants to convert $s$ into $t$ using the following operation as few times as possible. In one operation, he can choose any subsequence of $s$ and rotate it clockwise once. For example, if $s = 1\textbf{1}101\textbf{00}$, he can choose a subsequence corresponding to indices ($1$-based) $\{2, 6, 7 \}$ and rotate them clockwise. The resulting string would then be $s = 1\textbf{0}101\textbf{10}$. A string $a$ is said to be a subsequence of string $b$ if $a$ can be obtained from $b$ by deleting some characters without changing the ordering of the remaining characters. To perform a clockwise rotation on a sequence $c$ of size $k$ is to perform an operation which sets $c_1:=c_k, c_2:=c_1, c_3:=c_2, \ldots, c_k:=c_{k-1}$ simultaneously. Determine the minimum number of operations Naman has to perform to convert $s$ into $t$ or say that it is impossible.  
tl;dr: