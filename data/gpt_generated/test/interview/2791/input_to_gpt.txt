You are given a string $s$ of even length $n$. String $s$ is binary, in other words, consists only of 0's and 1's. String $s$ has exactly $\frac{n}{2}$ zeroes and $\frac{n}{2}$ ones ($n$ is even). In one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string. What is the minimum number of operations you need to make string $s$ alternating  A string is alternating if $s_i \neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010... 
tl;dr: You are given a string $s$ of even length $n$. String $s$ is binary. String $s$ has exactly $\frac{n}{2}$ zeroes and $\frac{n}{2}$ ones ($n$ is even). In one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string. What is the minimum number of operations you need to make string $s$ alternating  A string is alternating if $s_i \neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010... 

Chef solved so many hard questions, now he wants to solve some easy problems for refreshment. Chef asks Cheffina for the new question. Cheffina challanges the chef to print the total number of 1's in the binary representation of N(natural number). 
tl;dr: Print the total number of 1's in binary representation of the given N integer. 

# Task  `N` candles are placed in a row, some of them are initially lit. For each candle from the 1st to the Nth the following algorithm is applied: if the observed candle is lit then states of this candle and all candles before it are changed to the opposite. Which candles will remain lit after applying the algorithm to all candles in the order they are placed in the line  # 
tl;dr: `N` candles are placed in a row, some of them are initially lit. For each candle from the 1st to the Nth the following algorithm is applied: if the observed candle is lit then states of this candle and all candles before it are changed to the opposite. Which candles will remain lit after applying the algorithm to all candles in the order they are placed in the line  # 

In C++ division with positive integers always rounds down. Because of this, sometimes when two integers are divided by the same divisor they become equal even though they were originally not equal. For example in C++, $\verb|5/4|$ and $\verb|7/4|$ are both equal to 1, but $5 \neq 7$. Given a list of nonnegative integers and a divisor, how many pairs of distinct entries in the list are there that give the same result when both are divided by the divisor in C++  
tl;dr: