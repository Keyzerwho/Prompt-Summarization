Given an array of unique integers salary where salary[i] is the salary of the employee i. Return the average salary of employees excluding the minimum and maximum salary.   
tl;dr: You are given an array of unique salaries. Return the average of salaries excluding the minimum and maximum salary.   

Complete the solution so that it returns the number of times the search_text is found within the full_text. ```python search_substr( fullText, searchText, allowOverlap = true ) ``` so that overlapping solutions are (not) counted. If the searchText is empty, it should return `0`. Usage examples: ```python search_substr('aa_bb_cc_dd_bb_e', 'bb') # should return 2 since bb shows up twice search_substr('aaabbbcccc', 'bbb') # should return 1 search_substr( 'aaa', 'aa' ) # should return 2 search_substr( 'aaa', '' ) # should return 0 search_substr( 'aaa', 'aa', false ) # should return 1 ``
tl;dr: Write a function search_substr(fullText, searchText) that it returns the number of times the search_text is found within the full_text. If the searchText is empty, return 0. 

The BFS algorithm is defined as follows.  Consider an undirected graph with vertices numbered from $1$ to $n$. Initialize $q$ as a new queue containing only vertex $1$, mark the vertex $1$ as used.  Extract a vertex $v$ from the head of the queue $q$.  Print the index of vertex $v$.  Iterate in arbitrary order through all such vertices $u$ that $u$ is a neighbor of $v$ and is not marked yet as used. Mark the vertex $u$ as used and insert it into the tail of the queue $q$.  If the queue is not empty, continue from step 2.  Otherwise finish.  Since the order of choosing neighbors of each vertex can vary, it turns out that there may be multiple sequences which BFS can print. In this problem you need to check whether a given sequence corresponds to some valid BFS traversal of the given tree starting from vertex $1$. The tree is an undirected graph, such that there is exactly one simple path between any two vertices. 
tl;dr: