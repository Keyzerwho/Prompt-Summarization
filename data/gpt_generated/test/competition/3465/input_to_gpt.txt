Toad Zitz has an array of integers, each integer is between $0$ and $m-1$ inclusive. The integers are $a_1, a_2, \ldots, a_n$. In one operation Zitz can choose an integer $k$ and $k$ indices $i_1, i_2, \ldots, i_k$ such that $1 \leq i_1 < i_2 < \ldots < i_k \leq n$. He should then change $a_{i_j}$ to $((a_{i_j}+1) \bmod m)$ for each chosen integer $i_j$. The integer $m$ is fixed for all operations and indices. Here $x \bmod y$ denotes the remainder of the division of $x$ by $y$. Zitz wants to make his array non-decreasing with the minimum number of such operations. Find this minimum number of operations. 
tl;dr: You have an array of integers, each integer is between $0$ and $m-1$ inclusive. The integers are $a_1, a_2, \ldots, a_n$. In one operation you can choose an integer $k$ and $k$ indices $i_1, i_2, \ldots, i_k$ such that $1 \leq i_1 < i_2 < \ldots < i_k \leq n$. You should then change $a_{i_j}$ to $((a_{i_j}+1) \bmod m)$ for each chosen integer $i_j$. The integer $m$ is fixed for all operations and indices. You wants to make this array non-decreasing with the minimum number of such operations. Find this minimum number of operations. 

Create a function that takes a string and returns that string with the first half lowercased and the last half uppercased. eg: foobar == fooBAR If it is an odd number then 'round' it up to find which letters to uppercase. See example below.     sillycase("brian")       //         --^-- midpoint       //         bri    first half (lower-cased)       //            AN second half (upper-cased
tl;dr: Create a function that takes a string and returns that string with the first half lowercased and the last half uppercased. If it is an odd number then 'round' it up to find which letters to uppercase.  

Your task is very simple. Just write a function `isAlphabetic(s)`, which takes an input string `s` in lowercase and returns `true`/`false` depending on whether the string is in alphabetical order or not. For example, `isAlphabetic('kata')` is False as 'a' comes after 'k', but `isAlphabetic('ant')` is True. Good luck :
tl;dr: Just write a function `isAlphabetic(s)`, which takes an input string `s` in lowercase and returns `true`/`false` depending on whether the string is in alphabetical order or not

The people of Absurdistan discovered how to build roads only last year. After the discovery, each city decided to build its own road, connecting the city to some other city. Each newly built road can be used in both directions. You bought a tourist guide which has a map of the country with the newly built roads. However, since you are very interested in history, you would like to know which city built which road. Given the description of $n$ roads, can you find an assignment of roads to $n$ cities, such that each city built one road  If there are multiple assignments, you are happy with any one. At least one solution is guaranteed to exist. 
tl;dr: