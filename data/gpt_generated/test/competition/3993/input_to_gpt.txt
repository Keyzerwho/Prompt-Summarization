Arkady needs your help again! This time he decided to build his own high-speed Internet exchange point. It should consist of n nodes connected with minimum possible number of wires into one network (a wire directly connects two nodes). Exactly k of the nodes should be exit-nodes, that means that each of them should be connected to exactly one other node of the network, while all other nodes should be connected to at least two nodes in order to increase the system stability. Arkady wants to make the system as fast as possible, so he wants to minimize the maximum distance between two exit-nodes. The distance between two nodes is the number of wires a package needs to go through between those two nodes. Help Arkady to find such a way to build the network that the distance between the two most distant exit-nodes is as small as possible. 
tl;dr: You want to build your own high-speed Internet exchange point. It should consist of n nodes connected with minimum possible number of wires into one network. Exactly k of the nodes should be exit-nodes, that means that each of them should be connected to exactly one other node of the network, while all other nodes should be connected to at least two nodes in order to increase the system stability. Find the Minimum Spanning Tree between two exit-nodes. 

Implement a function which takes a string, and returns its hash value. Algorithm steps: * `a` := sum of the ascii values of the input characters * `b` := sum of every difference between the consecutive characters of the input (second char minus first char, third minus second, ...) * `c` := (`a` OR `b`) AND ((NOT `a`) shift left by 2 bits) * `d` := `c` XOR (32 * (`total_number_of_spaces` + 1)) * return `d` **Note**: OR, AND, NOT, XOR are bitwise operations. ___ ### 
tl;dr: Implement a function which takes a string, and returns its hash value. Algorithm steps: * `a` := sum of the ascii values of the input characters * `b` := sum of every difference between the consecutive characters of the input (second char minus first char, third minus second, ...) * `c` := (`a` OR `b`) AND ((NOT `a`) shift left by 2 bits) * `d` := `c` XOR (32 * (`total_number_of_spaces` + 1)) * return `d` 

Recently, Tokitsukaze found an interesting game. Tokitsukaze had $n$ items at the beginning of this game. However, she thought there were too many items, so now she wants to discard $m$ ($1 \le m \le n$) special items of them. These $n$ items are marked with indices from $1$ to $n$. In the beginning, the item with index $i$ is placed on the $i$-th position. Items are divided into several pages orderly, such that each page contains exactly $k$ positions and the last positions on the last page may be left empty. Tokitsukaze would do the following operation: focus on the first special page that contains at least one special item, and at one time, Tokitsukaze would discard all special items on this page. After an item is discarded or moved, its old position would be empty, and then the item below it, if exists, would move up to this empty position. The movement may bring many items forward and even into previous pages, so Tokitsukaze would keep waiting until all the items stop moving, and then do the operation (i.e. check the special page and discard the special items) repeatedly until there is no item need to be discarded.  [Image] Consider the first example from the statement: $n=10$, $m=4$, $k=5$, $p=[3, 5, 7, 10]$. The are two pages. Initially, the first page is special (since it is the first page containing a special item). So Tokitsukaze discards the special items with indices $3$ and $5$. After, the first page remains to be special. It contains $[1, 2, 4, 6, 7]$, Tokitsukaze discards the special item with index $7$. After, the second page is special (since it is the first page containing a special item). It contains $[9, 10]$, Tokitsukaze discards the special item with index $10$.  Tokitsukaze wants to know the number of operations she would do in total. 
tl;dr: