There are some ambiguities when one writes Berland names with the letters of the Latin alphabet. For example, the Berland sound u can be written in the Latin alphabet as "u", and can be written as "oo". For this reason, two words "ulyana" and "oolyana" denote the same name. The second ambiguity is about the Berland sound h: one can use both "h" and "kh" to write it. For example, the words "mihail" and "mikhail" denote the same name. There are n users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account  Formally, we assume that two words denote the same name, if using the replacements "u" [Image] "oo" and "h" [Image] "kh", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements. For example, the following pairs of words denote the same name:  "koouper" and "kuooper". Making the replacements described above, you can make both words to be equal: "koouper" $\rightarrow$ "kuuper" and "kuooper" $\rightarrow$ "kuuper".  "khun" and "kkkhoon". With the replacements described above you can make both words to be equal: "khun" $\rightarrow$ "khoon" and "kkkhoon" $\rightarrow$ "kkhoon" $\rightarrow$ "khoon".  For a given list of words, find the minimal number of groups where the words in each group denote the same name. 
tl;dr: Some names with latin alphabets have ambiguities. For example, the Berland sound u can be written in the Latin alphabet as "u", and can be written as "oo". For this reason, two words "ulyana" and "oolyana" denote the same name. The second ambiguity is about the Berland sound h: one can use both "h" and "kh" to write it. How many distinct names are there, if two ambiguities described above are taken into account. For example, the following pairs of words denote the same name:  "koouper" and "kuooper". Making the replacements described above, you can make both words to be equal: "koouper" $\rightarrow$ "kuuper" and "kuooper" $\rightarrow$ "kuuper".  "khun" and "kkkhoon". With the replacements described above you can make both words to be equal: "khun" $\rightarrow$ "khoon" and "kkkhoon" $\rightarrow$ "kkhoon" $\rightarrow$ "khoon".  For a given list of words, find the minimal number of groups where the words in each group denote the same name. 

A spoonerism is a spoken phrase in which the first letters of two of the words are swapped around, often with amusing results. In its most basic form a spoonerism is a two word phrase in which only the first letters of each word are swapped: ```"not picking" --> "pot nicking"``` Your task is to create a function that takes a string of two words, separated by a space: ```words``` and returns a spoonerism of those words in a string, as in the above example. 
tl;dr: Your task is to create a function that takes a string of two words separated by a space, and returns a spoonerism of those words in a string. 

**This Kata is intended as a small challenge for my students** All Star Code Challenge #16 Create a function called noRepeat() that takes a string argument and returns a single letter string of the **first** not repeated character in the entire string. ``` haskell noRepeat "aabbccdde" `shouldBe` 'e' noRepeat "wxyz"      `shouldBe` 'w' noRepeat "testing"   `shouldBe` 'e' ``` 
tl;dr: Create a function called noRepeat() that takes a string argument and returns a single letter string of the first not repeated character in the entire string. 

You have $n$ coins, each of the same value of $1$. Distribute them into packets such that any amount $x$ ($1 \leq x \leq n$) can be formed using some (possibly one or all) number of these packets. Each packet may only be used entirely or not used at all. No packet may be used more than once in the formation of the single $x$, however it may be reused for the formation of other $x$'s. Find the minimum number of packets in such a distribution. 
tl;dr: