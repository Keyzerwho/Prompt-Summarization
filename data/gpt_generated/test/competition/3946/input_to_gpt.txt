# Fourier transformations are hard. Fouriest transformations are harder. This Kata is based on the SMBC Comic on fourier transformations. A fourier transformation on a number is one that converts the number to a base in which it has more `4`s ( `10` in base `6` is `14`, which has `1` four as opposed to none, hence, fourier in base `6` ). A number's fouriest transformation converts it to the base in which it has the most `4`s.   For example: `35353` is the fouriest in base `6`: `431401`. This kata requires you to create a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened, as follows: ```python fouriest(number) -> "{number} is the fouriest ({fouriest_representation}) in base {base}" ``` ## Important notes * For this kata we don't care about digits greater than `9` ( only `0` to `9` ), so we will represent all digits greater than `9` as `'x'`: `10` in base `11` is `'x'`, `119` in base `20` is `'5x'`, `118` in base `20` is also `'5x'` * When a number has several fouriest representations, we want the one with the LOWEST base ```if:haskell,javascript * Numbers below `9` will not be tested ``` ```if:javascript * A `BigNumber` library has been provided; documentation is [here](https://mikemcl.github.io/bignumber.js/) ``` ## 
tl;dr: Create a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened. 

Chef wants you to distribute candies among $N$ kids who are sitting in a circle. However, he wants to make some kids jealous of others. Thus, he wants you to distribute candies in such a way that there is a difference of at least $K$ candies between two adjacent kids.  Given the value of $N$ and $K$, you need to find the minimum number of candies you need to satisfy the given conditions, such that, each kid gets at least one candy. 
tl;dr: You are given $N$ nodes arranged in a cycle initialised to zero and a difference $K$.  Find and return the minimum number of increments required so that each node is atleast $1$ and adjacent nodes have a difference of is atleast $K$. 

The only difference between easy and hard versions is constraints. Nauuo is a girl who loves random picture websites. One day she made a random picture website by herself which includes $n$ pictures. When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $i$-th picture has a non-negative weight $w_i$, and the probability of the $i$-th picture being displayed is $\frac{w_i}{\sum_{j=1}^nw_j}$. That is to say, the probability of a picture to be displayed is proportional to its weight. However, Nauuo discovered that some pictures she does not like were displayed too often.  To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $1$ to its weight; otherwise, she would subtract $1$ from its weight. Nauuo will visit the website $m$ times. She wants to know the expected weight of each picture after all the $m$ visits modulo $998244353$. Can you help her  The expected weight of the $i$-th picture can be denoted by $\frac {q_i} {p_i}$ where $\gcd(p_i,q_i)=1$, you need to print an integer $r_i$ satisfying $0\le r_i<998244353$ and $r_i\cdot p_i\equiv q_i\pmod{998244353}$. It can be proved that such $r_i$ exists and is unique. 
tl;dr: