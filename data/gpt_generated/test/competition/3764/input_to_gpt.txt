> In information theory and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other. (http://en.wikipedia.org/wiki/Levenshtein_distance) Your task is to implement a function which calculates the Levenshtein distance for two arbitrary strings
tl;dr: The Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other. Your task is to implement a function which calculates the Levenshtein distance for two arbitrary strings

You are given a sequence a consisting of n integers. Find the maximum possible value of $a_{i} \operatorname{mod} a_{j}$ (integer remainder of a_{i} divided by a_{j}), where 1   i, j   n and a_{i}   a_{j}. 
tl;dr: You are given a sequence a consisting of n integers. Find the maximum possible value of integer remainder of a_{i} divided by a_{j}, where 1   i, j   n and a_{i}   a_{j}. 

Toad Zitz has an array of integers, each integer is between $0$ and $m-1$ inclusive. The integers are $a_1, a_2, \ldots, a_n$. In one operation Zitz can choose an integer $k$ and $k$ indices $i_1, i_2, \ldots, i_k$ such that $1 \leq i_1 < i_2 < \ldots < i_k \leq n$. He should then change $a_{i_j}$ to $((a_{i_j}+1) \bmod m)$ for each chosen integer $i_j$. The integer $m$ is fixed for all operations and indices. Here $x \bmod y$ denotes the remainder of the division of $x$ by $y$. Zitz wants to make his array non-decreasing with the minimum number of such operations. Find this minimum number of operations. 
tl;dr: You have an array of integers, each integer is between $0$ and $m-1$ inclusive. The integers are $a_1, a_2, \ldots, a_n$. In one operation you can choose an integer $k$ and $k$ indices $i_1, i_2, \ldots, i_k$ such that $1 \leq i_1 < i_2 < \ldots < i_k \leq n$. You should then change $a_{i_j}$ to $((a_{i_j}+1) \bmod m)$ for each chosen integer $i_j$. The integer $m$ is fixed for all operations and indices. You wants to make this array non-decreasing with the minimum number of such operations. Find this minimum number of operations. 

Jon Snow now has to fight with White Walkers. He has n rangers, each of which has his own strength. Also Jon Snow has his favourite number x. Each ranger can fight with a white walker only if the strength of the white walker equals his strength. He however thinks that his rangers are weak and need to improve. Jon now thinks that if he takes the bitwise XOR of strengths of some of rangers with his favourite number x, he might get soldiers of high strength. So, he decided to do the following operation k times:   Arrange all the rangers in a straight line in the order of increasing strengths.  Take the bitwise XOR (is written as $\oplus$) of the strength of each alternate ranger with x and update it's strength.  Suppose, Jon has 5 rangers with strengths [9, 7, 11, 15, 5] and he performs the operation 1 time with x = 2. He first arranges them in the order of their strengths, [5, 7, 9, 11, 15]. Then he does the following:   The strength of first ranger is updated to $5 \oplus 2$, i.e. 7.  The strength of second ranger remains the same, i.e. 7.  The strength of third ranger is updated to $9 \oplus 2$, i.e. 11.  The strength of fourth ranger remains the same, i.e. 11.  The strength of fifth ranger is updated to $15 \oplus 2$, i.e. 13.  The new strengths of the 5 rangers are [7, 7, 11, 11, 13] Now, Jon wants to know the maximum and minimum strength of the rangers after performing the above operations k times. He wants your help for this task. Can you help him  
tl;dr: