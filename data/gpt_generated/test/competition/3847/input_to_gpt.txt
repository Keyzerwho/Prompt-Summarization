You are given n strings s_1, s_2, ..., s_{n} consisting of characters 0 and 1. m operations are performed, on each of them you concatenate two existing strings into a new one. On the i-th operation the concatenation s_{a}_{i}s_{b}_{i} is saved into a new string s_{n} + i (the operations are numbered starting from 1). After each operation you need to find the maximum positive integer k such that all possible strings consisting of 0 and 1 of length k (there are 2^{k} such strings) are substrings of the new string. If there is no such k, print 0. 
tl;dr: You are given n strings s_1, s_2, ..., s_{n} consisting of characters 0 and 1. m operations are performed, on each of them you concatenate two existing strings into a new one. On the i-th operation the concatenation s_{a}_{i}s_{b}_{i} is saved into a new string s_{n} + i. After each operation you need to find the maximum positive integer k such that all possible strings consisting of 0 and 1 of length k are substrings of the new string. If there is no such k, print 0. 

Implement a function which  creates a **[radix tree](https://en.wikipedia.org/wiki/Radix_tree)** (a space-optimized trie [prefix tree])  in which each node that is the only child is merged with its parent [unless a word from the input ends there])  from a given list of words  using dictionaries (aka hash maps or hash tables) where: 1. The dictionary keys are the nodes. 2. Leaf nodes are empty dictionaries. 3. The value for empty input is an empty dictionary. 4. Words are all lowercase or empty strings. 5. Words can contain duplicates. ### 
tl;dr: Implement a function which creates a radix tree in which each node that is the only child is merged with its parent from a given list of words using dictionaries where: 1. The dictionary keys are the nodes. 2. Leaf nodes are empty dictionaries. 3. The value for empty input is an empty dictionary. 4. Words are all lowercase or empty strings. 5. Words can contain duplicates. 

In this Kata, we are going to determine if the count of each of the characters in a string can be equal if we remove a single character from that string. For example: ``` solve('abba') = false -- if we remove any character, the count of each character will not be equal. solve('abbba') = true -- if we remove one b, the count of each character becomes 2. solve('aaaa') = true -- if we remove one character, the remaining characters have same count. solve('wwwf') = true -- if we remove f, the remaining letters have same count. ``` More examples in the test cases. Empty string is not tested. Good luck
tl;dr: Determine if the count of each of the characters in a string can be equal if a single character is removed from that string. 

You are given two arrays $a$ and $b$ of positive integers, with length $n$ and $m$ respectively.  Let $c$ be an $n \times m$ matrix, where $c_{i,j} = a_i \cdot b_j$.  You need to find a subrectangle of the matrix $c$ such that the sum of its elements is at most $x$, and its area (the total number of elements) is the largest possible. Formally, you need to find the largest number $s$ such that it is possible to choose integers $x_1, x_2, y_1, y_2$ subject to $1 \leq x_1 \leq x_2 \leq n$, $1 \leq y_1 \leq y_2 \leq m$, $(x_2 - x_1 + 1) \times (y_2 - y_1 + 1) = s$, and $$\sum_{i=x_1}^{x_2}{\sum_{j=y_1}^{y_2}{c_{i,j}}} \leq x.$$ 
tl;dr: