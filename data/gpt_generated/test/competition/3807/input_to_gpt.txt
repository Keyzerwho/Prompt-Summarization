Your task is to write a function that does just what the title suggests (so, fair warning, be aware that you are not getting out of it just throwing a lame bas sorting method there) with an array/list/vector of integers and the expected number `n` of smallest elements to return. Also: * the number of elements to be returned cannot be higher than the array/list/vector length; * elements can be duplicated; * in case of duplicates, just return them according to the original order (see third example for more clarity). Same examples and more in the test cases: ```python first_n_smallest([1,2,3,4,5],3) == [1,2,3] first_n_smallest([5,4,3,2,1],3) == [3,2,1] first_n_smallest([1,2,3,4,1],3) == [1,2,1] first_n_smallest([1,2,3,-4,0],3) == [1,-4,0] first_n_smallest([1,2,3,4,5],0) == [] ``` [Performance version by FArekkusu](https://www.codewars.com/kata/5aeed69804a92621a7000077) also available
tl;dr: Your task is to write a function that does just what the title suggests with an array/list/vector of integers and the expected number n of smallest elements to return. 

Your work is to write a method that takes a value and an index, and returns the value with the bit at given index flipped. The bits are numbered from the least significant bit (index 1). 
tl;dr: Your work is to write a method that takes a value and an index, and returns the value with the bit at given index flipped. The bits are numbered from the least significant bit. The index number can be out of number's range. 

Given a permutation $p$ of length $n$, find its subsequence $s_1$, $s_2$, $\ldots$, $s_k$ of length at least $2$ such that:  $|s_1-s_2|+|s_2-s_3|+\ldots+|s_{k-1}-s_k|$ is as big as possible over all subsequences of $p$ with length at least $2$.  Among all such subsequences, choose the one whose length, $k$, is as small as possible.  If multiple subsequences satisfy these conditions, you are allowed to find any of them. A sequence $a$ is a subsequence of an array $b$ if $a$ can be obtained from $b$ by deleting some (possibly, zero or all) elements. A permutation of length $n$ is an array of length $n$ in which every element from $1$ to $n$ occurs exactly once. 
tl;dr: Given a permutation $p$ of length $n$, find its subsequence $s_1$, $s_2$, $\ldots$, $s_k$ of length at least $2$ such that:  $|s_1-s_2|+|s_2-s_3|+\ldots+|s_{k-1}-s_k|$ is as big as possible over all subsequences of $p$ with length at least $2$.  Among all such subsequences, choose the one whose length, $k$, is as small as possible.  

Limak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length. A block with side a has volume a^3. A tower consisting of blocks with sides a_1, a_2, ..., a_{k} has the total volume a_1^3 + a_2^3 + ... + a_{k}^3. Limak is going to build a tower. First, he asks you to tell him a positive integer X   the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn't exceed X. Limak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X. Can you help Limak  Find the maximum number of blocks his tower can have and the maximum X   m that results this number of blocks. 
tl;dr: