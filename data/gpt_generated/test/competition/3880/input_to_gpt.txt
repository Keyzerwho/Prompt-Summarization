Given a board of `NxN`, distributed with tiles labeled `0` to `N  - 1`(inclusive): A solved grid will have the tiles in order of label, left to right, top to bottom. Return `true` if the board state is currently solved, and `false` if the board state is unsolved. Input will always be a square 2d array. For example, a 2x2 solved grid: ``` [ [0, 1],   [2, 3] ] ``` A 2x2 unsolved grid: ``` [ [2, 1],   [0, 3] ] ``
tl;dr: Given a board of `NxN`, distributed with tiles labeled `0` to `N  - 1`(inclusive): A solved grid will have the tiles in order of label, left to right, top to bottom. Return `true` if the board state is currently solved, and `false` otherwise. For example, a 2x2 solved grid: ``` [ [0, 1],   [2, 3] ] ``` A 2x2 unsolved grid: ``` [ [2, 1],   [0, 3] ] ``

On a broken calculator that has a number showing on its display, we can perform two operations: Double: Multiply the number on the display by 2, or; Decrement: Subtract 1 from the number on the display. Initially, the calculator is displaying the number X. Return the minimum number of operations needed to display the number Y.   
tl;dr: You are given two numbers X and Y. In one step, you can either double the value of X, or decrement X by 1. Return the minimum number of steps required before the value of X equals Y.   

Yaroslav has an array, consisting of (2 n - 1) integers. In a single operation Yaroslav can change the sign of exactly n elements in the array. In other words, in one operation Yaroslav can select exactly n array elements, and multiply each of them by -1. Yaroslav is now wondering: what maximum sum of array elements can be obtained if it is allowed to perform any number of described operations  Help Yaroslav. 
tl;dr: