Baby is getting his frst tooth. This means more sleepless nights, but with the fun of feeling round his gums and trying to guess which will be first out!  Probably best have a sweepstake with your friends - because you have the best chance of knowing. You can feel the gums and see where the raised bits are - most raised, most likely tooth to come through first! Given an array of numbers (t) to represent baby's gums, you need to return the index of the lump that is most pronounced.  The most pronounced lump is the one that has the biggest differential to its surrounding values. e.g.: ``` [1, 2, 4] = 2 index 0 has a differential of -1 to its right (it is lower so the figure is negative) index 1 has a differential of +1 to its left, and -2 to its right. Total is -1. index 2 has a differential of +2 to its left, and nothing to its right,  ``` If there is no distinct highest value (more than one occurence of the largest differential), return -1
tl;dr: Given an array of numbers t to represent baby's gums, you need to return the index of the lump that is most pronounced. The most pronounced lump is the one that has the biggest differential to its surrounding values. If there is no distinct highest value, return -1. 

We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.   Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top.   When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.   When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.   After two cups of champagne are poured, the two glasses on the second row are half full.   After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.   After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below. Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)   
tl;dr: You are given glasses stacked in a pyramid. You need to output how full the j-th glass in the i-th row is when champagne is poured in the first glass at the top. Glasses poured will be in the range of [0, 10 ^ 9]. i and j will be in the range of [0, 99]. 

# Task Given an array `arr`, find the maximal value of `k` such `a[i] mod k` = `a[j] mod k` for all valid values of i and j. If it's impossible to find such number (there's an infinite number of `k`s), return `-1` instead. # Input/Output `[input]` integer array `arr` A non-empty array of positive integer. `2 <= arr.length <= 10` `1 <= arr[i] <= 100` `[output]` an integer The maximum value of `k` or `-1` if there is none. # 
tl;dr: # Task You are given an array `arr`, find the maximal value of `k` such `a[i] mod k` = `a[j] mod k` for all valid values of i and j. If it's impossible to find such number, return `-1` instead. # Input/Output `arr` is a non-empty array of positive integer. `2 <= arr.length <= 10` `1 <= arr[i] <= 100` `[output]` is an integer The maximum value of `k` or `-1` if there is none. # 

Oleg writes down the history of the days he lived. For each day he decides if it was good or bad. Oleg calls a non-empty sequence of days a zebra, if it starts with a bad day, ends with a bad day, and good and bad days are alternating in it. Let us denote bad days as 0 and good days as 1. Then, for example, sequences of days 0, 010, 01010 are zebras, while sequences 1, 0110, 0101 are not. Oleg tells you the story of days he lived in chronological order in form of string consisting of 0 and 1. Now you are interested if it is possible to divide Oleg's life history into several subsequences, each of which is a zebra, and the way it can be done. Each day must belong to exactly one of the subsequences. For each of the subsequences, days forming it must be ordered chronologically. Note that subsequence does not have to be a group of consecutive days.  
tl;dr: