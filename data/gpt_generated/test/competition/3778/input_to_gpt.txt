```if:python Create a function `args_count`, that returns the count of passed arguments ``` ```if:kotlin Create a function `argsCount`, that returns the count of passed arguments ``` ```if:ruby Create a method `args_count`, that returns the count of passed arguments ``` ```if:julia Create a method `argscount`, that returns the count of passed arguments ``` ```python args_count(1, 2, 3) -> 3 args_count(1, 2, 3, 10) -> 4 ``
tl;dr: ```if:python Create a function `args_count`, that returns the count of passed arguments ``` ```if:kotlin Create a function `argsCount`, that returns the count of passed arguments ``` ```if:ruby Create a method `args_count`, that returns the count of passed arguments ``` ```if:julia Create a method `argscount`, that returns the count of passed arguments ``` ```python args_count(1, 2, 3) -> 3 args_count(1, 2, 3, 10) -> 4 ``

Complete the solution so that it returns the number of times the search_text is found within the full_text. ```python search_substr( fullText, searchText, allowOverlap = true ) ``` so that overlapping solutions are (not) counted. If the searchText is empty, it should return `0`. Usage examples: ```python search_substr('aa_bb_cc_dd_bb_e', 'bb') # should return 2 since bb shows up twice search_substr('aaabbbcccc', 'bbb') # should return 1 search_substr( 'aaa', 'aa' ) # should return 2 search_substr( 'aaa', '' ) # should return 0 search_substr( 'aaa', 'aa', false ) # should return 1 ``
tl;dr: Write a function search_substr(fullText, searchText) that it returns the number of times the search_text is found within the full_text. If the searchText is empty, return 0. 

# Task  `N` candles are placed in a row, some of them are initially lit. For each candle from the 1st to the Nth the following algorithm is applied: if the observed candle is lit then states of this candle and all candles before it are changed to the opposite. Which candles will remain lit after applying the algorithm to all candles in the order they are placed in the line  # 
tl;dr: `N` candles are placed in a row, some of them are initially lit. For each candle from the 1st to the Nth the following algorithm is applied: if the observed candle is lit then states of this candle and all candles before it are changed to the opposite. Which candles will remain lit after applying the algorithm to all candles in the order they are placed in the line  # 

To improve the boomerang throwing skills of the animals, Zookeeper has set up an $n \times n$ grid with some targets, where each row and each column has at most $2$ targets each. The rows are numbered from $1$ to $n$ from top to bottom, and the columns are numbered from $1$ to $n$ from left to right.   For each column, Zookeeper will throw a boomerang from the bottom of the column (below the grid) upwards. When the boomerang hits any target, it will bounce off, make a $90$ degree turn to the right and fly off in a straight line in its new direction. The boomerang can hit multiple targets and does not stop until it leaves the grid.   [Image]  In the above example, $n=6$ and the black crosses are the targets. The boomerang in column $1$ (blue arrows) bounces $2$ times while the boomerang in column $3$ (red arrows) bounces $3$ times.  The boomerang in column $i$ hits exactly $a_i$ targets before flying out of the grid. It is known that $a_i \leq 3$. However, Zookeeper has lost the original positions of the targets. Thus, he asks you to construct a valid configuration of targets that matches the number of hits for each column, or tell him that no such configuration exists. If multiple valid configurations exist, you may print any of them. 
tl;dr: