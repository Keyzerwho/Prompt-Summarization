Complete the function that takes an array of words. You must concatenate the `n`th letter from each word to construct a new word which should be returned as a string, where `n` is the position of the word in the list. For example: ``` ["yoda", "best", "has"]  -->  "yes"   ^        ^        ^   n=0     n=1     n=2 ``` **
tl;dr: Given an array of words, you must concatenate the nth letter from each word to construct a new word which should be returned as a string, where n is the position of the word in the list. 

Reducing Problems - Bug Fixing #8 Oh no! Timmy's reduce is causing problems, Timmy's goal is to calculate the two teams scores and return the winner but timmy has gotten confused and sometimes teams don't enter their scores, total the scores out of 3! Help timmy fix his program! Return true if team 1 wins or false if team 2 wins
tl;dr: Reducing Problems - Bug Fixing #8 Timmy's goal is to calculate the two teams scores and return the winner and sometimes teams don't enter their scores, total the scores out of 3! Return true if team 1 wins or false if team 2 wins

Bike loves looking for the second maximum element in the sequence. The second maximum element in the sequence of distinct numbers x_1, x_2, ..., x_{k} (k > 1) is such maximum element x_{j}, that the following inequality holds: $x_{j} \neq \operatorname{max}_{i = 1}^{k} x_{i}$. The lucky number of the sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence. You've got a sequence of distinct positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l} + 1, ..., s_{r} as s[l..r] (1   l < r   n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r]. Note that as all numbers in sequence s are distinct, all the given definitions make sence. 
tl;dr: The lucky number of the sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence. You've got a sequence of distinct positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l} + 1, ..., s_{r} as s[l..r] (1   l < r   n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r]. All numbers in sequence s are distinct. 

Iahub and Sorin are the best competitive programmers in their town. However, they can't both qualify to an important contest. The selection will be made with the help of a single problem. Blatnatalag, a friend of Iahub, managed to get hold of the problem before the contest. Because he wants to make sure Iahub will be the one qualified, he tells Iahub the following task. You're given an (1-based) array a with n elements. Let's define function f(i, j) (1   i, j   n) as (i - j)^2 + g(i, j)^2. Function g is calculated by the following pseudo-code: int g(int i, int j) {     int sum = 0;     for (int k = min(i, j) + 1; k <= max(i, j); k = k + 1)         sum = sum + a[k];     return sum; } Find a value min_{i}   j  f(i, j). Probably by now Iahub already figured out the solution to this problem. Can you  
tl;dr: