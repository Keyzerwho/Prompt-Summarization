Dhruvil has always been a studious person and will be completing his Engineering soon. He is always kneen about solving problems and is preparing hard for his next interview at Hackerrank. He has practiced lots of problems and now he came across this problem. Given a message containing English letters(A-Z), it is being encoded to numbers using the following mapping: 'A' -> 1,'B' -> 2        'Z' -> 26. Now, given a non-empty string containing only digits, help Dhruvil determine the total number of ways to decode it. While decoding you need to choose a substring of charachters and not a subsequence. Also a chosen substring should not contain any leading "0"s, but can contain trailing "0"s. Since the output can be very large print the answer as modulo 10^9 + 7 i.e 1000000007. 
tl;dr: Characters of a string is decoded using mapping as 'A' -> 1,'B' -> 2        'Z' -> 26. Determine the total number of ways to decode it.  There should be no leading "0"s, but can contain trailing "0"s.Print the answer as modulo 10^9 + 7 i.e 1000000007. 

You have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges. During one move, you can choose some gift $1 \le i \le n$ and do one of the following operations:   eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one).  Of course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero). As said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \dots = a_n$ and $b_1 = b_2 = \dots = b_n$ (and $a_i$ equals $b_i$ is not necessary). Your task is to find the minimum number of moves required to equalize all the given gifts. You have to answer $t$ independent test cases. 
tl;dr: You are given 2 integer arrays of length $n$, array $x$ and array $y$. For each array, you want to make all its values equivalent such that $x_1$ = $x_2$ = $x_3$ = ... = $x_n$ and $y_1$ = $y_2$ = $y_3$ = ... = $y_n$ in the least number of moves possible. In one move, you can decrement the value of an element by 1 at $x_i$ or $y_i$, or at both $x_i$ and $y_i$ The value of an element can not go below 0. You have to answer $t$ independent test cases. 

Iahub and Sorin are the best competitive programmers in their town. However, they can't both qualify to an important contest. The selection will be made with the help of a single problem. Blatnatalag, a friend of Iahub, managed to get hold of the problem before the contest. Because he wants to make sure Iahub will be the one qualified, he tells Iahub the following task. You're given an (1-based) array a with n elements. Let's define function f(i, j) (1   i, j   n) as (i - j)^2 + g(i, j)^2. Function g is calculated by the following pseudo-code: int g(int i, int j) {     int sum = 0;     for (int k = min(i, j) + 1; k <= max(i, j); k = k + 1)         sum = sum + a[k];     return sum; } Find a value min_{i}   j  f(i, j). Probably by now Iahub already figured out the solution to this problem. Can you  
tl;dr: