Chef Vivek is good in mathematics and likes solving problems on prime numbers. One day his friend Jatin told him about Victory numbers. Victory number can be defined as a number formed after summing up all the prime numbers till given number n. Now, chef Vivek who is very fond of solving questions on prime numbers got busy in some other tasks. Your task is to help him finding victory number. 
tl;dr: Find sum the sum of all the prime numbers which are less than the given number N. 

You will be given the prime factors of a number as an array. E.g: ```[2,2,2,3,3,5,5,13]``` You need to find the number, n, to which that prime factorization belongs. It will be: ``` n = 2 .3 .5 .13 = 23400 ``` Then, generate the divisors of this number. Your function ```get_num() or getNum()``` will receive an array with potentially unordered prime factors and should output: an array with the found integer n at index 0, the amount of total divisors (both prime and compound numbers) at index 1, followed the smallest factor (index 2, and the biggest one (last element) We will see the example given above with the only difference that the array of the prime factors is unordered. The list of divisors for that number (23400) is: ``` 2, 3, 4, 5, 6, 8, 9, 10, 12, 13, 15, 18, 20, 24, 25, 26, 30, 36, 39, 40, 45, 50, 52, 60, 65, 72, 75, 78, 90, 100, 104, 117, 120, 130, 150, 156, 180, 195, 200, 225, 234, 260, 300, 312, 325, 360, 390, 450, 468, 520, 585, 600, 650, 780, 900, 936, 975, 1170, 1300, 1560, 1800, 1950, 2340, 2600, 2925, 3900, 4680, 5850, 7800, 11700 (not considering the integer 23400 itself) ``` There is a total amount of ```71``` divisors. The smallest divisor is ```2``` and the highest ```11700```. So the expected output will be:  ``` get_num([2,13,2,5,2,5,3,3]) == [23400, 71, 2, 11700] ``` Enjoy
tl;dr: Write a function get_num() or getNum() that receives an array with potentially unordered prime factors and output: an array with the found integer n at index 0, the amount of total divisors at index 1, followed the smallest factor and the biggest one. 

Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value  If there is a tie, return all the values with the highest frequency in any order. 
tl;dr: You are given root of a tree. Find the most frequent subtree sum value if the  subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). If there is a tie, return all the values with the highest frequency. 

Nick has n bottles of soda left after his birthday. Each bottle is described by two values: remaining amount of soda a_{i} and bottle volume b_{i} (a_{i}   b_{i}). Nick has decided to pour all remaining soda into minimal number of bottles, moreover he has to do it as soon as possible. Nick spends x seconds to pour x units of soda from one bottle to another. Nick asks you to help him to determine k   the minimal number of bottles to store all remaining soda and t   the minimal time to pour soda into k bottles. A bottle can't store more soda than its volume. All remaining soda should be saved. 
tl;dr: