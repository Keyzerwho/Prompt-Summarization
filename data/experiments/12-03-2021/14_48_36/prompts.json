{
    "0": "Python 3\n\"\"\"\nAn array of integers $p_{1},p_{2}, \\ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once.\n\nThere is a hidden permutation of length $n$.\n\nFor each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$.\n\nYour task is to restore the permutation.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the size of the permutation.\n\nThe second line contains $n$ integers $s_{1}, s_{2}, \\ldots, s_{n}$ ($0 \\le s_{i} \\le \\frac{n(n-1)}{2}$).\n\nIt is guaranteed that the array $s$ corresponds to a valid permutation of length $n$.\n\n\n-----Output-----\n\nPrint $n$ integers $p_{1}, p_{2}, \\ldots, p_{n}$ \u2014 the elements of the restored permutation. We can show that the answer is always unique.\n\n\n-----Examples-----\nInput\n3\n0 0 0\n\nOutput\n3 2 1\n\nInput\n2\n0 1\n\nOutput\n1 2\n\nInput\n5\n0 1 1 1 10\n\nOutput\n1 4 3 2 5\n\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nAn array of integers $p_{1},p_{2}, \\ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once. For example, the following arrays are permutations: $[3,1,2], [1], [1,2,3,4,5]$ and $[4,3,1,2]$. The following arrays are not permutations: $[2], [1,1], [2,3,4]$.\n\nThere is a hidden permutation of length $n$.\n\nFor each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$. In other words, $s_i$ is the sum of elements before the $i$-th element that are smaller than the $i$-th element.\n\nYour task is to restore the permutation.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the size of the permutation.\n\nThe second line contains $n$ integers $s_{1}, s_{2}, \\ldots, s_{n}$ ($0 \\le s_{i} \\le \\frac{n(n-1)}{2}$).\n\nIt is guaranteed that the array $s$ corresponds to a valid permutation of length $n$.\n\n\n-----Output-----\n\nPrint $n$ integers $p_{1}, p_{2}, \\ldots, p_{n}$ \u2014 the elements of the restored permutation. We can show that the answer is always unique.\n\n\n-----Examples-----\nInput\n3\n0 0 0\n\nOutput\n3 2 1\n\nInput\n2\n0 1\n\nOutput\n1 2\n\nInput\n5\n0 1 1 1 10\n\nOutput\n1 4 3 2 5\n\n\n\n-----Note-----\n\nIn the first example for each $i$ there is no index $j$ satisfying both conditions, hence $s_i$ are always $0$.\n\nIn the second example for $i = 2$ it happens that $j = 1$ satisfies the conditions, so $s_2 = p_1$.\n\nIn the third example for $i = 2, 3, 4$ only $j = 1$ satisfies the conditions, so $s_2 = s_3 = s_4 = 1$. For $i = 5$ all $j = 1, 2, 3, 4$ are possible, so $s_5 = p_1 + p_2 + p_3 + p_4 = 10$.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nThere are two arrays of integers $a$ and $b$ of length $n$. It turned out that array $a$ contains only elements from the set $\\{-1, 0, 1\\}$.\n\nYou can perform the following sequence of operations any number of times:  Choose any pair of indexes $(i, j)$ such that $1 \\le i < j \\le n$. It is possible to choose the same pair $(i, j)$ more than once.   Add $a_i$ to $a_j$. In other words, $j$-th element of the array becomes equal to $a_i + a_j$. \n\nYou wants to predict if it is possible to apply some number (zero or more) of these operations to the array $a$ so that it becomes equal to array $b$.\n\n\n-----Input-----\n\nEach test contains multiple test cases. \n\nThe first line contains the number of test cases $t$ ($1 \\le t \\le 10000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u00a0\u2014 the length of arrays.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-1 \\le a_i \\le 1$) \u00a0\u2014 elements of array $a$. There can be duplicates among elements.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($-10^9 \\le b_i \\le 10^9$) \u00a0\u2014 elements of array $b$. There can be duplicates among elements.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output one line containing \"YES\" if it's possible to make arrays $a$ and $b$ equal by performing the described operations, or \"NO\" if it's impossible.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n5\n3\n1 -1 0\n1 1 -2\n3\n0 1 1\n0 2 2\n2\n1 0\n1 41\n2\n-1 0\n-1 -41\n5\n0 1 -1 1 -1\n1 1 -1 1 -1\n\nOutput\nYES\nNO\nYES\nYES\nNO\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nOnce again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:\n\nThere are two arrays of integers $a$ and $b$ of length $n$. It turned out that array $a$ contains only elements from the set $\\{-1, 0, 1\\}$.\n\nAnton can perform the following sequence of operations any number of times:  Choose any pair of indexes $(i, j)$ such that $1 \\le i < j \\le n$. It is possible to choose the same pair $(i, j)$ more than once.   Add $a_i$ to $a_j$. In other words, $j$-th element of the array becomes equal to $a_i + a_j$. \n\nFor example, if you are given array $[1, -1, 0]$, you can transform it only to $[1, -1, -1]$, $[1, 0, 0]$ and $[1, -1, 1]$ by one operation.\n\nAnton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $a$ so that it becomes equal to array $b$. Can you help him?\n\n\n-----Input-----\n\nEach test contains multiple test cases. \n\nThe first line contains the number of test cases $t$ ($1 \\le t \\le 10000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) \u00a0\u2014 the length of arrays.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($-1 \\le a_i \\le 1$) \u00a0\u2014 elements of array $a$. There can be duplicates among elements.\n\nThe third line of each test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($-10^9 \\le b_i \\le 10^9$) \u00a0\u2014 elements of array $b$. There can be duplicates among elements.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output one line containing \"YES\" if it's possible to make arrays $a$ and $b$ equal by performing the described operations, or \"NO\" if it's impossible.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Example-----\nInput\n5\n3\n1 -1 0\n1 1 -2\n3\n0 1 1\n0 2 2\n2\n1 0\n1 41\n2\n-1 0\n-1 -41\n5\n0 1 -1 1 -1\n1 1 -1 1 -1\n\nOutput\nYES\nNO\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first test-case we can choose $(i, j)=(2, 3)$ twice and after that choose $(i, j)=(1, 2)$ twice too. These operations will transform $[1, -1, 0] \\to [1, -1, -2] \\to [1, 1, -2]$\n\nIn the second test case we can't make equal numbers on the second position.\n\nIn the third test case we can choose $(i, j)=(1, 2)$ $41$ times. The same about the fourth test case.\n\nIn the last lest case, it is impossible to make array $a$ equal to the array $b$.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nGiven a string s, write a method that will return true if it is a valid single integer or floating number or false if it is not.\n\"\"\"\ndef isDigit(string):",
    "5": "Python 3\n\"\"\"\nGiven a string s, write a method (function) that will return true if its a valid single integer or floating number or false if its not.\n\nValid examples, should return true:\n\nshould return false:\n\"\"\"\ndef isDigit(string):",
    "6": "Python 3\n\"\"\"\nYou are given an array $a$ of $n$ integers.\n\nYou want to make all elements of $a$ equal to zero by doing the following operation exactly three times:  Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment. \n\nIt is always possible to make all elements of $a$ equal to zero.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 100\\,000$): the number of elements of the array.\n\nThe second line contains $n$ elements of an array $a$ separated by spaces: $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n  The first line contains two integers $l$, $r$ ($1 \\le l \\le r \\le n$): the bounds of the selected segment.\n\n  The second line contains $r-l+1$ integers $b_l, b_{l+1}, \\dots, b_r$ ($-10^{18} \\le b_i \\le 10^{18}$): the numbers to add to $a_l, a_{l+1}, \\ldots, a_r$, respectively; $b_i$ should be divisible by $r - l + 1$. \n\n\n-----Example-----\nInput\n4\n1 3 2 4\n\nOutput\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nYou are given an array $a$ of $n$ integers.\n\nYou want to make all elements of $a$ equal to zero by doing the following operation exactly three times:  Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment (added integers can be different). \n\nIt can be proven that it is always possible to make all elements of $a$ equal to zero.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 100\\,000$): the number of elements of the array.\n\nThe second line contains $n$ elements of an array $a$ separated by spaces: $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n  The first line contains two integers $l$, $r$ ($1 \\le l \\le r \\le n$): the bounds of the selected segment.\n\n  The second line contains $r-l+1$ integers $b_l, b_{l+1}, \\dots, b_r$ ($-10^{18} \\le b_i \\le 10^{18}$): the numbers to add to $a_l, a_{l+1}, \\ldots, a_r$, respectively; $b_i$ should be divisible by $r - l + 1$. \n\n\n-----Example-----\nInput\n4\n1 3 2 4\n\nOutput\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\nDetermine if the count of each of the characters in a string can be equal if a single character is removed from that string.\n\nExamples:\nInput:\nsolve('abba')\nOutput:\nfalse\nExplanation:\nIf we remove any character, the count of each character will not be equal.\n\nInput:\nsolve('abbba')\nOutput:\ntrue\nExplanation:\nIf we remove one b, the count of each character becomes 2.\n\nInput:\nsolve('aaaa')\nOutput:\ntrue\nExplanation:\nIf we remove one character, the remaining characters have same count.\n\nInput:\nsolve('wwwf')\nOutput:\ntrue\nExplanation:\nIf we remove f, the remaining letters have same count.\n\"\"\"\ndef solve(s):",
    "9": "Python 3\n\"\"\"\nIn this Kata, we are going to determine if the count of each of the characters in a string can be equal if we remove a single character from that string.\n\nFor example:\n```\nsolve('abba') = false -- if we remove any character, the count of each character will not be equal.\nsolve('abbba') = true -- if we remove one b, the count of each character becomes 2.\nsolve('aaaa') = true -- if we remove one character, the remaining characters have same count.\nsolve('wwwf') = true -- if we remove f, the remaining letters have same count.\n```\nMore examples in the test cases. Empty string is not tested.\n\nGood luck!\n\"\"\"\ndef solve(s):",
    "10": "Python 3\n\"\"\"\nYour task is to create a function that takes a string of two words separated by a space, and returns a spoonerism of those words in a string.\n\nExample:\nInput: \"not picking\"\nOutput: \"pot nicking\"\n\"\"\"\ndef spoonerize(words):",
    "11": "Python 3\n\"\"\"\nA spoonerism is a spoken phrase in which the first letters of two of the words are swapped around, often with amusing results.\n\nIn its most basic form a spoonerism is a two word phrase in which only the first letters of each word are swapped:\n\n```\"not picking\" --> \"pot nicking\"```\n\nYour task is to create a function that takes a string of two words, separated by a space: ```words``` and returns a spoonerism of those words in a string, as in the above example.\n\nNOTE: All input strings will contain only two words.  Spoonerisms can be more complex.  For example, three-word phrases in which the first letters of the first and last words are swapped: ```\"pack of lies\" --> \"lack of pies\"``` or more than one letter from a word is swapped: ```\"flat battery --> \"bat flattery\"```\nYou are NOT expected to account for these, or any other nuances involved in spoonerisms.\n\nOnce you have completed this kata, a slightly more challenging take on the idea can be found here: http://www.codewars.com/kata/56dbed3a13c2f61ae3000bcd\n\"\"\"\ndef spoonerize(words):",
    "12": "Python 3\n\"\"\"\nThere are $n$ positive integers $a_1, a_2, \\dots, a_n$. For the one move you can choose any even value $c$ and divide by two all elements that equal $c$.\n\nFor example, if $a=[6,8,12,6,3,12]$ and you choose $c=6$, and $a$ is transformed into $a=[3,8,12,3,3,12]$ after the move.\n\nYou need to find the minimal number of moves for transforming $a$ to an array of only odd integers (each element shouldn't be divisible by $2$).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains $n$ ($1 \\le n \\le 2\\cdot10^5$) \u2014 the number of integers in the sequence $a$. The second line contains positive integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe sum of $n$ for all test cases in the input doesn't exceed $2\\cdot10^5$.\n\n\n-----Output-----\n\nFor $t$ test cases print the answers in the order of test cases in the input. The answer for the test case is the minimal number of moves needed to make all numbers in the test case odd (i.e. not divisible by $2$).\n\n\n-----Example-----\nInput\n4\n6\n40 6 40 3 20 1\n1\n1024\n4\n2 4 8 16\n3\n3 1 7\n\nOutput\n4\n10\n4\n0\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nThere are $n$ positive integers $a_1, a_2, \\dots, a_n$. For the one move you can choose any even value $c$ and divide by two all elements that equal $c$.\n\nFor example, if $a=[6,8,12,6,3,12]$ and you choose $c=6$, and $a$ is transformed into $a=[3,8,12,3,3,12]$ after the move.\n\nYou need to find the minimal number of moves for transforming $a$ to an array of only odd integers (each element shouldn't be divisible by $2$).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains $n$ ($1 \\le n \\le 2\\cdot10^5$) \u2014 the number of integers in the sequence $a$. The second line contains positive integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$).\n\nThe sum of $n$ for all test cases in the input doesn't exceed $2\\cdot10^5$.\n\n\n-----Output-----\n\nFor $t$ test cases print the answers in the order of test cases in the input. The answer for the test case is the minimal number of moves needed to make all numbers in the test case odd (i.e. not divisible by $2$).\n\n\n-----Example-----\nInput\n4\n6\n40 6 40 3 20 1\n1\n1024\n4\n2 4 8 16\n3\n3 1 7\n\nOutput\n4\n10\n4\n0\n\n\n\n-----Note-----\n\nIn the first test case of the example, the optimal sequence of moves can be as follows:\n\n  before making moves $a=[40, 6, 40, 3, 20, 1]$;  choose $c=6$;  now $a=[40, 3, 40, 3, 20, 1]$;  choose $c=40$;  now $a=[20, 3, 20, 3, 20, 1]$;  choose $c=20$;  now $a=[10, 3, 10, 3, 10, 1]$;  choose $c=10$;  now $a=[5, 3, 5, 3, 5, 1]$ \u2014 all numbers are odd. \n\nThus, all numbers became odd after $4$ moves. In $3$ or fewer moves, you cannot make them all odd.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nThere are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nCalculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length to the score. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nYou're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nUsing the play sequence you can calculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length (the number of characters \"O\") to the score. For example, if your play can be encoded as \"OOXOOOXXOO\", then there's three maximal consecutive \"O\"s block \"OO\", \"OOO\", \"OO\", so your score will be 2^2 + 3^2 + 2^2 = 17. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n-----Note-----\n\nFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  \u2192  3^2 = 9;  \"OOX\"  \u2192  2^2 = 4;  \"OXO\"  \u2192  1^2 + 1^2 = 2;  \"OXX\"  \u2192  1^2 = 1;  \"XOO\"  \u2192  2^2 = 4;  \"XOX\"  \u2192  1^2 = 1;  \"XXO\"  \u2192  1^2 = 1;  \"XXX\"  \u2192  0. \n\nSo the expected score is $\\frac{9 + 4 + 2 + 1 + 4 + 1 + 1}{8} = 2.75$\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nYou are given a string S consisting of a,b and c. Find the number of strings that can be possibly obtained by repeatedly performing the following operation zero or more times, modulo 998244353:\n - Choose an integer i such that 1\\leq i\\leq |S|-1 and the i-th and (i+1)-th characters in S are different. Replace each of the i-th and (i+1)-th characters in S with the character that differs from both of them.\n\n-----Constraints-----\n - 2 \\leq |S| \\leq 2 \u00d7 10^5\n - S consists of a, b and c.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS\n\n-----Output-----\nPrint the number of strings that can be possibly obtained by repeatedly performing the operation, modulo 998244353.\n\n-----Sample Input-----\nabc\n\n-----Sample Output-----\n3\n\n\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nYou are given a string S consisting of a,b and c. Find the number of strings that can be possibly obtained by repeatedly performing the following operation zero or more times, modulo 998244353:\n - Choose an integer i such that 1\\leq i\\leq |S|-1 and the i-th and (i+1)-th characters in S are different. Replace each of the i-th and (i+1)-th characters in S with the character that differs from both of them (among a, b and c).\n\n-----Constraints-----\n - 2 \\leq |S| \\leq 2 \u00d7 10^5\n - S consists of a, b and c.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS\n\n-----Output-----\nPrint the number of strings that can be possibly obtained by repeatedly performing the operation, modulo 998244353.\n\n-----Sample Input-----\nabc\n\n-----Sample Output-----\n3\n\nabc, aaa and ccc can be obtained.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nYou are given a binary array. Find the transition point in the sorted (ascending) binary array. Here indexing is starting from 0.\n\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input, $N$.\n- N space-separated binary numbers. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n1\n5\n0 1 0 0 1\n\n-----Sample Output:-----\n3\n\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nChef has a binary array in an unsorted manner. Cheffina challenges chef to find the transition point in the sorted (ascending) binary array. Here indexing is starting from 0.\nNote: Transition point always exists.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input, $N$.\n- N space-separated binary numbers. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n1\n5\n0 1 0 0 1\n\n-----Sample Output:-----\n3\n\n-----EXPLANATION:-----\nbinary array in sorted form will look like = [0, 0, 0, 1, 1]\n\"\"\"\ndef code():"
}