{
    "0": "Python 3\n\"\"\"\nYou are given $2n$ number of different items which are in $n$ pairs.\n\nLine up the $2n$ number of items in such a way that each pair occupies adjacent positions in the line.\n\nFind the minimum number of swaps of adjacent positions which must be performed to make it so that each item pair occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of different item.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th itme in the line form a pair.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the item up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nAllen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nYou are given N people to be split into two groups such that if a person dislikes someone, then both of them should not be in the same group.\nYou need to return true if such split is possible.\n\nExample 1:\nInput: N = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: group1 [1,4], group2 [2,3]\n\n\nExample 2:\nInput: N = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\n\n\nExample 3:\nInput: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\nOutput: false\n\nConstraints:\n\n1 <= N <= 2000\n0 <= dislikes.length <= 10000\ndislikes[i].length == 2\n1 <= dislikes[i][j] <= N\ndislikes[i][0] < dislikes[i][1]\nThere does not exist i != j for which dislikes[i] == dislikes[j].\n\"\"\"\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:",
    "3": "Python 3\n\"\"\"\nGiven a set of N\u00a0people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size.\nEach person may dislike some other people, and they should not go into the same group.\u00a0\nFormally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.\nReturn true\u00a0if and only if it is possible to split everyone into two groups in this way.\n\n\nExample 1:\nInput: N = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: group1 [1,4], group2 [2,3]\n\n\nExample 2:\nInput: N = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\n\n\nExample 3:\nInput: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\nOutput: false\n\n\n\n\n\u00a0\nConstraints:\n\n1 <= N <= 2000\n0 <= dislikes.length <= 10000\ndislikes[i].length == 2\n1 <= dislikes[i][j] <= N\ndislikes[i][0] < dislikes[i][1]\nThere does not exist i != j for which dislikes[i] == dislikes[j].\n\"\"\"\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:",
    "4": "Python 3\n\"\"\"\nA rectangle with sides $A$ and $B$ is cut into rectangles with cuts parallel to its sides.\n\nFor each type of rectangles, lengths of the sides of rectangles are given along with the amount of the rectangles of this type that were left after cutting the initial rectangle.\n\nCalculate the amount of pairs $(A; B)$ such as the given rectangles could be created by cutting the rectangle with sides of lengths $A$ and $B$. Pairs $(A; B)$ and $(B; A)$ are considered different when $A \\neq B$.\n\n\n-----Input-----\n\nThe first line consists of a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^{5}$)\u00a0\u2014 amount of different types of rectangles left after cutting the initial rectangle.\n\nThe next $n$ lines each consist of three integers $w_{i}, h_{i}, c_{i}$ $(1 \\leq w_{i}, h_{i}, c_{i} \\leq 10^{12})$\u00a0\u2014 the lengths of the sides of the rectangles of this type and the amount of the rectangles of this type.\n\nIt is guaranteed that the rectangles of the different types are different.\n\n\n-----Output-----\n\nOutput one integer\u00a0\u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n1\n1 1 9\n\nOutput\n3\n\nInput\n2\n2 3 20\n2 4 40\n\nOutput\n6\n\nInput\n2\n1 2 5\n2 3 5\n\nOutput\n0\n\n\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nA rectangle with sides $A$ and $B$ is cut into rectangles with cuts parallel to its sides. For example, if $p$ horizontal and $q$ vertical cuts were made, $(p + 1) \\cdot (q + 1)$ rectangles were left after the cutting. After the cutting, rectangles were of $n$ different types. Two rectangles are different if at least one side of one rectangle isn't equal to the corresponding side of the other. Note that the rectangle can't be rotated, this means that rectangles $a \\times b$ and $b \\times a$ are considered different if $a \\neq b$.\n\nFor each type of rectangles, lengths of the sides of rectangles are given along with the amount of the rectangles of this type that were left after cutting the initial rectangle.\n\nCalculate the amount of pairs $(A; B)$ such as the given rectangles could be created by cutting the rectangle with sides of lengths $A$ and $B$. Note that pairs $(A; B)$ and $(B; A)$ are considered different when $A \\neq B$.\n\n\n-----Input-----\n\nThe first line consists of a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^{5}$)\u00a0\u2014 amount of different types of rectangles left after cutting the initial rectangle.\n\nThe next $n$ lines each consist of three integers $w_{i}, h_{i}, c_{i}$ $(1 \\leq w_{i}, h_{i}, c_{i} \\leq 10^{12})$\u00a0\u2014 the lengths of the sides of the rectangles of this type and the amount of the rectangles of this type.\n\nIt is guaranteed that the rectangles of the different types are different.\n\n\n-----Output-----\n\nOutput one integer\u00a0\u2014 the answer to the problem.\n\n\n-----Examples-----\nInput\n1\n1 1 9\n\nOutput\n3\n\nInput\n2\n2 3 20\n2 4 40\n\nOutput\n6\n\nInput\n2\n1 2 5\n2 3 5\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample there are three suitable pairs: $(1; 9)$, $(3; 3)$ and $(9; 1)$.\n\nIn the second sample case there are 6 suitable pairs: $(2; 220)$, $(4; 110)$, $(8; 55)$, $(10; 44)$, $(20; 22)$ and $(40; 11)$.\n\nHere the sample of cut for $(20; 22)$.\n\n [Image] \n\nThe third sample has no suitable pairs.\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nYou are given an array of numbers. Make sets of 3 numbers. A set is valid when 1st number < 2nd number < 3rd number or 1st number > 2nd number > 3rd number.\n\nReturn the number of such sets that can be formed. a number can be in multiple sets\n\u00a0\nExample 1:\nInput: rating = [2,5,3,4,1]\nOutput: 3\nExplanation: We can form three sets given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\nExample 2:\nInput: rating = [2,1,3]\nOutput: 0\nExplanation: We can't form any set given the conditions.\n\nExample 3:\nInput: rating = [1,2,3,4]\nOutput: 4\n\n\u00a0\nConstraints:\n\nn == rating.length\n1 <= n <= 200\n1 <= rating[i] <= 10^5\n\n\"\"\"\nclass Solution:\n    def numTeams(self, rating: List[int]) -> int:",
    "7": "Python 3\n\"\"\"\nThere are\u00a0n\u00a0soldiers standing in a line. Each soldier is assigned a unique rating value.\nYou have to form a team of 3 soldiers\u00a0amongst them under the following rules:\n\nChoose 3 soldiers with index (i, j, k) with\u00a0rating (rating[i], rating[j], rating[k]).\nA team is valid if:\u00a0 (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0\u00a0<= i <\u00a0j <\u00a0k <\u00a0n).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\nExample 1:\nInput: rating = [2,5,3,4,1]\nOutput: 3\nExplanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\nExample 2:\nInput: rating = [2,1,3]\nOutput: 0\nExplanation: We can't form any team given the conditions.\n\nExample 3:\nInput: rating = [1,2,3,4]\nOutput: 4\n\n\u00a0\nConstraints:\n\nn == rating.length\n1 <= n <= 200\n1 <= rating[i] <= 10^5\n\n\"\"\"\nclass Solution:\n    def numTeams(self, rating: List[int]) -> int:",
    "8": "Python 3\n\"\"\"\nThe input given are sets of linear equations.\nWrite a method ```solve``` that accepts a list of linear equations that your method will have to solve. \nThe output should be a map object with a value for each variable in the equations. \nIf the system has infinitely many solutions or is unsolvable, return ```null``` or `None` in python.\n\nFor example :  \n  \n\"2x + 4y + 6z = 18\"  \n\"3y + 3z = 6\"  \n\"x + 2y = z - 3\"\n  \nshould result in a map :  \n  \nx = 2  \ny = -1  \nz = 3  \n  \nPossible input equations have the following rules:  \n-   Only the plus and minus operators are used on both the left and right hand side of the equation.  \n-   Both sides of the equation can have variables; One variable can appear in multiple terms, on both sides.\n-   Variable names are strings of arbitrary length.  \n-   All coefficients are integers and generally fall within the range of -150 to 150, with a few ranging from -1000 to 1000. Free terms are integers in range -20000 to 20000.  \n-   Equations do not necessarily have variables.  \n-   Equations have exactly one operator (+ or -) between terms.  \n\n\nComparisons are performed with accuracy of `1e-6`.\n\n**Note on numerical stability:**\n\nThere are many possible ways to solve a system of linear equations. One group of such algorithms is based on reduction and elimination methods. If you are going to use any of these, remember that such algorithms are in general *numerically unstable*, i.e. division operations repeated over and over introduce inaccuracies which accumulate from row to row. As a result it might occur that some value which is expected to be zero is actually larger, for example, `2.5e-10`. Such inaccuracies tend to be bigger in large equation systems, and random tests check systems of up to 26 equations. If it happens that small tests pass for you, and large tests fail, it probably means that you did not account for inaccuracies correctly.\nAlso note that tests do not depend on any reference solution, so the way how test cases are generated _is numerically stable_ - the only source of inaccuracies is your solution, and you need to account for it.\n\n```if:python\n___Note for python users:___\n\n`numpy` module has been disabled, so that the task matches the one of the other languages. There is an anti-cheat measure about that, so you won't be able to import some other modules too (either way, you shouldn't need any module to solve this kata...)\n```\n\"\"\"\ndef solve(*equations):",
    "9": "Python 3\n\"\"\"\nTo almost all of us solving sets of linear equations is quite obviously the most exciting bit of linear algebra. \nBenny does not agree though and wants to write a quick program to solve his homework problems for him. \nUnfortunately Benny's lack of interest in linear algebra means he has no real clue on how to go about this. \nFortunately, you can help him!\n\nWrite a method ```solve``` that accepts a list of linear equations that your method will have to solve. \nThe output should be a map (a `Map` object in JavaScript) with a value for each variable in the equations. \nIf the system does not have a unique solution (has infinitely many solutions or is unsolvable), return ```null``` (`None` in python).\n\nFor example :  \n  \n\"2x + 4y + 6z = 18\"  \n\"3y + 3z = 6\"  \n\"x + 2y = z - 3\"\n  \nshould result in a map :  \n  \nx = 2  \ny = -1  \nz = 3  \n  \nPossible input equations have the following rules:  \n-   Only the plus and minus operators are used on both the left and right hand side of the equation.  \n-   Both sides of the equation can have variables; One variable can appear in multiple terms, on both sides.\n-   Variable names are strings of arbitrary length.  \n-   All coefficients are integers and generally fall within the range of -150 to 150, with a few ranging from -1000 to 1000. Free terms are integers in range -20000 to 20000.  \n-   Equations do not necessarily have variables.  \n-   Equations have exactly one operator (+ or -) between terms.  \n\n\nComparisons are performed with accuracy of `1e-6`.\n\n**Note on numerical stability:**\n\nThere are many possible ways to solve a system of linear equations. One group of such algorithms is based on reduction and elimination methods. If you are going to use any of these, remember that such algorithms are in general *numerically unstable*, i.e. division operations repeated over and over introduce inaccuracies which accumulate from row to row. As a result it might occur that some value which is expected to be zero is actually larger, for example, `2.5e-10`. Such inaccuracies tend to be bigger in large equation systems, and random tests check systems of up to 26 equations. If it happens that small tests pass for you, and large tests fail, it probably means that you did not account for inaccuracies correctly.\nAlso note that tests do not depend on any reference solution, so the way how test cases are generated _is numerically stable_ - the only source of inaccuracies is your solution, and you need to account for it.\n\n```if:python\n___Note for python users:___\n\n`numpy` module has been disabled, so that the task matches the one of the other languages. There is an anti-cheat measure about that, so you won't be able to import some other modules too (either way, you shouldn't need any module to solve this kata...)\n```\n\"\"\"\ndef solve(*equations):",
    "10": "Python 3\n\"\"\"\nIn this task, you have to define a function named func that will take a list as input.\n\nYou must try and guess the pattern how we get the output number and return list - [output number,binary representation,octal representation,hexadecimal representation]\n\nExamples: \nInput:\nfunc([12,13,6,3,6,45,123])\nOutput:\n[29,'11101','35','1d']\n\nInput:\nfunc([1,9,23,43,65,31,63,99]) \nOutput:\n[41,'101001','51','29']\n\nInput:\nfunc([2,4,6,8,10,12,14,16,18,19])\nOutput:\n[10,'1010','12','a']\n\n\"\"\"\ndef func(l):",
    "11": "Python 3\n\"\"\"\nIn this kata, you have to define a function named **func** that will take a list as input.\n\nYou must try and guess the pattern how we get the output number and return list - **[output number,binary representation,octal representation,hexadecimal representation]**, but **you must convert that specific number without built-in : bin,oct and hex functions.**\n\nExamples : \n\n```python\nfunc([12,13,6,3,6,45,123]) returns - [29,'11101','35','1d']\n\nfunc([1,9,23,43,65,31,63,99]) returns - [41,'101001','51','29']\n\nfunc([2,4,6,8,10,12,14,16,18,19]) returns - [10,'1010','12','a']\n```\n\"\"\"\ndef func(l):",
    "12": "Python 3\n\"\"\"\nNumbers $1, 2, 3, \\dots n$ (each integer from $1$ to $n$ once) are written on a board. In one operation you can erase any two numbers $a$ and $b$ from the board and write one integer $\\frac{a + b}{2}$ rounded up instead.\n\nYou should perform the given operation $n - 1$ times and make the resulting number that will be left on the board as small as possible. \n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of integers written on the board initially.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, in the first line, print the minimum possible number left on the board after $n - 1$ operations. Each of the next $n - 1$ lines should contain two integers\u00a0\u2014 numbers $a$ and $b$ chosen and erased in each operation.\n\n\n-----Example-----\nInput\n1\n4\n\nOutput\n2\n2 4\n3 3\n3 1\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nNumbers $1, 2, 3, \\dots n$ (each integer from $1$ to $n$ once) are written on a board. In one operation you can erase any two numbers $a$ and $b$ from the board and write one integer $\\frac{a + b}{2}$ rounded up instead.\n\nYou should perform the given operation $n - 1$ times and make the resulting number that will be left on the board as small as possible. \n\nFor example, if $n = 4$, the following course of action is optimal:  choose $a = 4$ and $b = 2$, so the new number is $3$, and the whiteboard contains $[1, 3, 3]$;  choose $a = 3$ and $b = 3$, so the new number is $3$, and the whiteboard contains $[1, 3]$;  choose $a = 1$ and $b = 3$, so the new number is $2$, and the whiteboard contains $[2]$. \n\nIt's easy to see that after $n - 1$ operations, there will be left only one number. Your goal is to minimize it.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of integers written on the board initially.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, in the first line, print the minimum possible number left on the board after $n - 1$ operations. Each of the next $n - 1$ lines should contain two integers\u00a0\u2014 numbers $a$ and $b$ chosen and erased in each operation.\n\n\n-----Example-----\nInput\n1\n4\n\nOutput\n2\n2 4\n3 3\n3 1\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nYou are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.\n\nSorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.\n\nEvery element of the sequence must appear in exactly one subsequence.\n\n\n-----Input-----\n\nThe first line of input data contains integer n (1 \u2264 n \u2264 10^5)\u00a0\u2014 the length of the sequence.\n\nThe second line of input data contains n different integers a_1, a_2, ..., a_{n} ( - 10^9 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the sequence. It is guaranteed that all elements of the sequence are distinct.\n\n\n-----Output-----\n\nIn the first line print the maximum number of subsequences k, which the original sequence can be split into while fulfilling the requirements.\n\nIn the next k lines print the description of subsequences in the following format: the number of elements in subsequence c_{i} (0 < c_{i} \u2264 n), then c_{i} integers l_1, l_2, ..., l_{c}_{i} (1 \u2264 l_{j} \u2264 n)\u00a0\u2014 indices of these elements in the original sequence. \n\nIndices could be printed in any order. Every index from 1 to n must appear in output exactly once.\n\nIf there are several possible answers, print any of them.\n\n\n-----Examples-----\nInput\n6\n3 2 1 6 5 4\n\nOutput\n4\n2 1 3\n1 2\n2 4 6\n1 5\n\nInput\n6\n83 -75 -49 11 37 62\n\nOutput\n1\n6 1 2 3 4 5 6\n\n\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nYou are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.\n\nSorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.\n\nEvery element of the sequence must appear in exactly one subsequence.\n\n\n-----Input-----\n\nThe first line of input data contains integer n (1 \u2264 n \u2264 10^5)\u00a0\u2014 the length of the sequence.\n\nThe second line of input data contains n different integers a_1, a_2, ..., a_{n} ( - 10^9 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the sequence. It is guaranteed that all elements of the sequence are distinct.\n\n\n-----Output-----\n\nIn the first line print the maximum number of subsequences k, which the original sequence can be split into while fulfilling the requirements.\n\nIn the next k lines print the description of subsequences in the following format: the number of elements in subsequence c_{i} (0 < c_{i} \u2264 n), then c_{i} integers l_1, l_2, ..., l_{c}_{i} (1 \u2264 l_{j} \u2264 n)\u00a0\u2014 indices of these elements in the original sequence. \n\nIndices could be printed in any order. Every index from 1 to n must appear in output exactly once.\n\nIf there are several possible answers, print any of them.\n\n\n-----Examples-----\nInput\n6\n3 2 1 6 5 4\n\nOutput\n4\n2 1 3\n1 2\n2 4 6\n1 5\n\nInput\n6\n83 -75 -49 11 37 62\n\nOutput\n1\n6 1 2 3 4 5 6\n\n\n\n-----Note-----\n\nIn the first sample output:\n\nAfter sorting the first subsequence we will get sequence 1\u00a02\u00a03\u00a06\u00a05\u00a04.\n\nSorting the second subsequence changes nothing.\n\nAfter sorting the third subsequence we will get sequence 1\u00a02\u00a03\u00a04\u00a05\u00a06.\n\nSorting the last subsequence changes nothing.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nYou are given an array $a_1, a_2 \\dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \\le i < j < k < l \\le n$;  $a_i = a_k$ and $a_j = a_l$; \n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 3000$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the array $a$.\n\nIt's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.\n\n\n-----Output-----\n\nFor each test case, print the number of described tuples.\n\n\n-----Example-----\nInput\n2\n5\n2 2 2 2 2\n6\n1 3 3 1 2 3\n\nOutput\n5\n2\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nYou are given an array $a_1, a_2 \\dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \\le i < j < k < l \\le n$;  $a_i = a_k$ and $a_j = a_l$; \n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 3000$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the array $a$.\n\nIt's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.\n\n\n-----Output-----\n\nFor each test case, print the number of described tuples.\n\n\n-----Example-----\nInput\n2\n5\n2 2 2 2 2\n6\n1 3 3 1 2 3\n\nOutput\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, for any four indices $i < j < k < l$ are valid, so the answer is the number of tuples.\n\nIn the second test case, there are $2$ valid tuples:   $(1, 2, 4, 6)$: $a_1 = a_4$ and $a_2 = a_6$;  $(1, 3, 4, 6)$: $a_1 = a_4$ and $a_3 = a_6$.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nTake an integer 'n' (n >= 0) and a digit 'd' (0 <= d <= 9) as an integer. Square all numbers 'k' (0 <= k <= n) between 0 and 'n'. Count the numbers of \ndigits 'd' used in the writing of all the 'k**2'. Write the function taking 'n' and 'd' as parameters and returning this count.\n\n#Examples:\n```\nn = 10, d = 1, the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\nWe are using the digit 1 in 1, 16, 81, 100. The total count is then 4.\n\nnb_dig(25, 1):\nthe numbers of interest are\n1, 4, 9, 10, 11, 12, 13, 14, 19, 21 which squared are 1, 16, 81, 100, 121, 144, 169, 196, 361, 441\nso there are 11 digits `1` for the squares of numbers between 0 and 25.\n```\nNote that `121` has twice the digit `1`.\n\"\"\"\ndef nb_dig(n, d):",
    "19": "Python 3\n\"\"\"\nTake an integer `n (n >= 0)` and a digit `d (0 <= d <= 9)` as an integer. Square all numbers `k (0 <= k <= n)` between 0 and n. Count the numbers of \ndigits `d` used in the writing of all the `k**2`. Call `nb_dig` (or nbDig or ...) the function taking `n` and `d` as parameters and returning this count.\n\n#Examples:\n```\nn = 10, d = 1, the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\nWe are using the digit 1 in 1, 16, 81, 100. The total count is then 4.\n\nnb_dig(25, 1):\nthe numbers of interest are\n1, 4, 9, 10, 11, 12, 13, 14, 19, 21 which squared are 1, 16, 81, 100, 121, 144, 169, 196, 361, 441\nso there are 11 digits `1` for the squares of numbers between 0 and 25.\n```\nNote that `121` has twice the digit `1`.\n\"\"\"\ndef nb_dig(n, d):"
}