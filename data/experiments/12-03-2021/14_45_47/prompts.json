{
    "0": "Python 3\n\"\"\"\nYou have the radius of a circle with the center in point (0,0). Write a function that calculates the number of points in the circle where (x,y) are integers.  0 <= radius <= 1000.\n\nExample: \nInput:\nradius = 2\nOutput:\n13\n\"\"\"\ndef points(n):",
    "1": "Python 3\n\"\"\"\nYou have the `radius` of a circle with the center in point `(0,0)`.\n\nWrite a function that calculates the number of points in the circle where `(x,y)` - the cartesian coordinates of the points - are `integers`.\n\nExample: for `radius = 2` the result should be `13`.\n\n`0 <= radius <= 1000`\n\n![](http://i.imgur.com/1SMov3s.png)\n\"\"\"\ndef points(n):",
    "2": "Python 3\n\"\"\"\n# Task\n\nYou will be given an array of random integers and a number n. You have to extract n smallest integers out of it. The original order need to be preserved.\n\n# Examples\n\nperformant_smallest([1, 2, 3, 4, 5], 3)     ==   [1, 2, 3]\nperformant_smallest([5, 4, 3, 2, 1], 3)     ==   [3, 2, 1]\nperformant_smallest([1, 2, 3, 4, 1], 3)     ==   [1, 2, 1]\nperformant_smallest([2, 1, 3, 2, 3], 3)     ==   [2, 1, 2]\n\n\"\"\"\ndef performant_smallest(arr, n):",
    "3": "Python 3\n\"\"\"\nThis challenge is based on [the kata](https://www.codewars.com/kata/n-smallest-elements-in-original-order) by GiacomoSorbi. Before doing this one it is advisable to complete the non-performance version first.\n\n___\n\n# Task\n\nYou will be given an array of random integers and a number `n`. You have to extract `n` smallest integers out of it **preserving the original order**.\n\n# Examples\n\n```python\nperformant_smallest([1, 2, 3, 4, 5], 3)     ==   [1, 2, 3]\nperformant_smallest([5, 4, 3, 2, 1], 3)     ==   [3, 2, 1]\nperformant_smallest([1, 2, 3, 4, 1], 3)     ==   [1, 2, 1]\nperformant_smallest([2, 1, 3, 2, 3], 3)     ==   [2, 1, 2]\n```\n\n# Notes\n\n* There will be duplicates in the array, and they have to be returned in the order of their each separate appearence.\n* This kata is an example of the \"know your data\" principle. Remember this while searching for the correct approach.\n\n# Performance tests\n\n```python\nTests: 15\nArray size: 800,000\nValues range: [1; 50]\nNumber of elements to return: 25-50% of the array\n```\n\"\"\"\ndef performant_smallest(arr, n):",
    "4": "Python 3\n\"\"\"\nCreate a function called noRepeat() that takes a string argument and returns a single letter string of the first not repeated character in the entire string.\n\nExamples:\nInput:\nnoRepeat(\"aabbccdde\")\nOutput:\n'e'\nInput:\nnoRepeat(\"wxyz\")\nOutput:\n'w'\nInput:\nnoRepeat(\"testing\")\nOutput:\n'e'\n\"\"\"\ndef no_repeat(string):",
    "5": "Python 3\n\"\"\"\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #16\n\nCreate a function called noRepeat() that takes a string argument and returns a single letter string of the **first** not repeated character in the entire string.\n\n``` haskell\nnoRepeat \"aabbccdde\" `shouldBe` 'e'\nnoRepeat \"wxyz\"      `shouldBe` 'w'\nnoRepeat \"testing\"   `shouldBe` 'e'\n```\n\nNote:\nONLY letters from the english alphabet will be used as input\nThere will ALWAYS be at least one non-repeating letter in the input string\n\"\"\"\ndef no_repeat(string):",
    "6": "Python 3\n\"\"\"\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 5000$) \u2014 the number of voters.\n\nThe next $n$ lines contains the description of voters. $i$-th line contains two integers $m_i$ and $p_i$ ($1 \\le p_i \\le 10^9, 0 \\le m_i < n$).\n\nIt is guaranteed that the sum of all $n$ over all test cases does not exceed $5000$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Example-----\nInput\n3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n\nOutput\n8\n0\n7\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nThe only difference between easy and hard versions is constraints.\n\nNow elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you.\n\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 5000$) \u2014 the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 5000$) \u2014 the number of voters.\n\nThe next $n$ lines contains the description of voters. $i$-th line contains two integers $m_i$ and $p_i$ ($1 \\le p_i \\le 10^9, 0 \\le m_i < n$).\n\nIt is guaranteed that the sum of all $n$ over all test cases does not exceed $5000$.\n\n\n-----Output-----\n\nFor each test case print one integer \u2014 the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Example-----\nInput\n3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n\nOutput\n8\n0\n7\n\n\n\n-----Note-----\n\nIn the first test case you have to buy vote of the third voter. Then the set of people voting for you will change as follows: ${3} \\rightarrow {1, 3} \\rightarrow {1, 2, 3}$.\n\nIn the second example you don't need to buy votes. The set of people voting for you will change as follows: ${1} \\rightarrow {1, 3, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 5, 6, 7} \\rightarrow {1, 2, 3, 4, 5, 6, 7}$.\n\nIn the third test case you have to buy votes of the second and the fifth voters. Then the set of people voting for you will change as follows: ${2, 5} \\rightarrow {1, 2, 3, 4, 5} \\rightarrow {1, 2, 3, 4, 5, 6}$.\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\nYou have an array of integers, each integer is between $0$ and $m-1$ inclusive. The integers are $a_1, a_2, \\ldots, a_n$.\n\nIn one operation you can choose an integer $k$ and $k$ indices $i_1, i_2, \\ldots, i_k$ such that $1 \\leq i_1 < i_2 < \\ldots < i_k \\leq n$. You should then change $a_{i_j}$ to $((a_{i_j}+1) \\bmod m)$ for each chosen integer $i_j$. The integer $m$ is fixed for all operations and indices.\n\nYou wants to make this array non-decreasing with the minimum number of such operations. Find this minimum number of operations.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 300\\,000$)\u00a0\u2014 the number of integers in the array and the parameter $m$.\n\nThe next line contains $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < m$)\u00a0\u2014 the given array.\n\n\n-----Output-----\n\nOutput one integer: the minimum number of described operations Zitz needs to make his array non-decreasing. If no operations required, print $0$.\n\nIt is easy to see that with enough operations Zitz can always make his array non-decreasing.\n\n\n-----Examples-----\nInput\n5 3\n0 0 0 1 2\n\nOutput\n0\n\nInput\n5 7\n0 6 1 3 2\n\nOutput\n1\n\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nToad Zitz has an array of integers, each integer is between $0$ and $m-1$ inclusive. The integers are $a_1, a_2, \\ldots, a_n$.\n\nIn one operation Zitz can choose an integer $k$ and $k$ indices $i_1, i_2, \\ldots, i_k$ such that $1 \\leq i_1 < i_2 < \\ldots < i_k \\leq n$. He should then change $a_{i_j}$ to $((a_{i_j}+1) \\bmod m)$ for each chosen integer $i_j$. The integer $m$ is fixed for all operations and indices.\n\nHere $x \\bmod y$ denotes the remainder of the division of $x$ by $y$.\n\nZitz wants to make his array non-decreasing with the minimum number of such operations. Find this minimum number of operations.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 300\\,000$)\u00a0\u2014 the number of integers in the array and the parameter $m$.\n\nThe next line contains $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i < m$)\u00a0\u2014 the given array.\n\n\n-----Output-----\n\nOutput one integer: the minimum number of described operations Zitz needs to make his array non-decreasing. If no operations required, print $0$.\n\nIt is easy to see that with enough operations Zitz can always make his array non-decreasing.\n\n\n-----Examples-----\nInput\n5 3\n0 0 0 1 2\n\nOutput\n0\n\nInput\n5 7\n0 6 1 3 2\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, the array is already non-decreasing, so the answer is $0$.\n\nIn the second example, you can choose $k=2$, $i_1 = 2$, $i_2 = 5$, the array becomes $[0,0,1,3,3]$. It is non-decreasing, so the answer is $1$.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\nYou are given an array $a$ of length $n$ consisting of zeros.\nYou perform $n$ actions with this array: during the $i$-th action:\n\nChoose the leftmost maximum length subarray consisting only of zeros;\nLet this segment be $[l; r]$. \nIf $r-l+1$ is odd then assign $a[\\frac{l+r}{2}] := i$ otherwise assign $a[\\frac{l+r-1}{2}] := i$. \n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each test case, print the answer \u2014 the array $a$ of length $n$ after performing $n$ actions described in the problem statement. Note that the answer exists and unique.\n\n\n-----Example-----\nInput\n6\n1\n2\n3\n4\n5\n6\n\nOutput\n1 \n1 2 \n2 1 3 \n3 1 2 4 \n2 4 1 3 5 \n3 4 1 5 2 6\n\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nYou are given an array $a$ of length $n$ consisting of zeros. You perform $n$ actions with this array: during the $i$-th action, the following sequence of operations appears:  Choose the maximum by length subarray (continuous subsegment) consisting only of zeros, among all such segments choose the leftmost one;  Let this segment be $[l; r]$. If $r-l+1$ is odd (not divisible by $2$) then assign (set) $a[\\frac{l+r}{2}] := i$ (where $i$ is the number of the current action), otherwise (if $r-l+1$ is even) assign (set) $a[\\frac{l+r-1}{2}] := i$. \n\nConsider the array $a$ of length $5$ (initially $a=[0, 0, 0, 0, 0]$). Then it changes as follows:  Firstly, we choose the segment $[1; 5]$ and assign $a[3] := 1$, so $a$ becomes $[0, 0, 1, 0, 0]$;  then we choose the segment $[1; 2]$ and assign $a[1] := 2$, so $a$ becomes $[2, 0, 1, 0, 0]$;  then we choose the segment $[4; 5]$ and assign $a[4] := 3$, so $a$ becomes $[2, 0, 1, 3, 0]$;  then we choose the segment $[2; 2]$ and assign $a[2] := 4$, so $a$ becomes $[2, 4, 1, 3, 0]$;  and at last we choose the segment $[5; 5]$ and assign $a[5] := 5$, so $a$ becomes $[2, 4, 1, 3, 5]$. \n\nYour task is to find the array $a$ of length $n$ after performing all $n$ actions. Note that the answer exists and unique.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each test case, print the answer \u2014 the array $a$ of length $n$ after performing $n$ actions described in the problem statement. Note that the answer exists and unique.\n\n\n-----Example-----\nInput\n6\n1\n2\n3\n4\n5\n6\n\nOutput\n1 \n1 2 \n2 1 3 \n3 1 2 4 \n2 4 1 3 5 \n3 4 1 5 2 6\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\nPrint the words in the line in reveres order of a given line without any punctuation marks.\n\n-----Input:-----\nThe first line of input contains a single integer $N$, indicating the number of lines in the input. This is followed by $N$ lines of input text.\n\n-----Output:-----\n$N$ lines of output text containing the input lines in reverse order and where each line contains the words in reverse order as illustrated above.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 10000$.\n- There are at most $80$ characters in each line\n\n-----Sample input-----\n2\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n-----Sample output-----\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nIn this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline). Your task is print the words in the text in reverse order without any punctuation marks.\nFor example consider the following candidate for the input text:\n$ $\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n$ $\nThe corresponding output would read as:\n$ $\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n\n$ $\nThat is, the lines are printed in reverse order and in each line the words are printed in reverse order.\n\n-----Input:-----\nThe first line of input contains a single integer $N$, indicating the number of lines in the input. This is followed by $N$ lines of input text.\n\n-----Output:-----\n$N$ lines of output text containing the input lines in reverse order and where each line contains the words in reverse order as illustrated above.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 10000$.\n- There are at most $80$ characters in each line\n\n-----Sample input-----\n2\nThis is a sample piece of text to illustrate this \nproblem.  If you are smart you will solve this right.\n\n-----Sample output-----\nright this solve will you smart are you If problem\nthis illustrate to text of piece sample a is This\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nGiven an array of integers $a_1, a_2, \\ldots, a_n$.\n\nWe say that $y$ is reachable from $x$ if $x<y$ and there exists an integer array $p$ such that $x = p_1 < p_2 < \\ldots < p_k=y$, and $a_{p_i}\\, \\&\\, a_{p_{i+1}} > 0$ for all integers $i$ such that $1 \\leq i < k$.\n\nHere $\\&$ denotes the bitwise AND operation.\n\nCheck reachability for each of them.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $q$ ($2 \\leq n \\leq 300\\,000$, $1 \\leq q \\leq 300\\,000$)\u00a0\u2014 the number of integers in the array and the number of queries you need to answer.\n\nThe second line contains $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 300\\,000$)\u00a0\u2014 the given array.\n\nThe next $q$ lines contain two integers each. The $i$-th of them contains two space-separated integers $x_i$ and $y_i$ ($1 \\leq x_i < y_i \\leq n$). You need to check if $y_i$ is reachable from $x_i$. \n\n\n-----Output-----\n\nOutput $q$ lines. In the $i$-th of them print \"Shi\" if $y_i$ is reachable from $x_i$, otherwise, print \"Fou\".\n\n\n-----Example-----\nInput\n5 3\n1 3 0 2 1\n1 3\n2 4\n1 4\n\nOutput\nFou\nShi\nShi\n\n\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nToad Pimple has an array of integers $a_1, a_2, \\ldots, a_n$.\n\nWe say that $y$ is reachable from $x$ if $x<y$ and there exists an integer array $p$ such that $x = p_1 < p_2 < \\ldots < p_k=y$, and $a_{p_i}\\, \\&\\, a_{p_{i+1}} > 0$ for all integers $i$ such that $1 \\leq i < k$.\n\nHere $\\&$ denotes the bitwise AND operation.\n\nYou are given $q$ pairs of indices, check reachability for each of them.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $q$ ($2 \\leq n \\leq 300\\,000$, $1 \\leq q \\leq 300\\,000$)\u00a0\u2014 the number of integers in the array and the number of queries you need to answer.\n\nThe second line contains $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 300\\,000$)\u00a0\u2014 the given array.\n\nThe next $q$ lines contain two integers each. The $i$-th of them contains two space-separated integers $x_i$ and $y_i$ ($1 \\leq x_i < y_i \\leq n$). You need to check if $y_i$ is reachable from $x_i$. \n\n\n-----Output-----\n\nOutput $q$ lines. In the $i$-th of them print \"Shi\" if $y_i$ is reachable from $x_i$, otherwise, print \"Fou\".\n\n\n-----Example-----\nInput\n5 3\n1 3 0 2 1\n1 3\n2 4\n1 4\n\nOutput\nFou\nShi\nShi\n\n\n\n-----Note-----\n\nIn the first example, $a_3 = 0$. You can't reach it, because AND with it is always zero. $a_2\\, \\&\\, a_4 > 0$, so $4$ is reachable from $2$, and to go from $1$ to $4$ you can use $p = [1, 2, 4]$.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nYou have to line up $2n$ number of different items which are in $n$ pairs.\n\nFind the minimum number of swaps of adjacent positions which must be performed to make it so that each item pair occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of different item.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th itme in the line form a pair.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the item up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nAllen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nNumbers $1, 2, 3, \\dots n$ (each integer from $1$ to $n$ once) are written on a board. In one operation you can erase any two numbers $a$ and $b$ from the board and write one integer $\\frac{a + b}{2}$ rounded up instead.\n\nYou should perform the given operation $n - 1$ times and make the resulting number that will be left on the board as small as possible. \n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of integers written on the board initially.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, in the first line, print the minimum possible number left on the board after $n - 1$ operations. Each of the next $n - 1$ lines should contain two integers\u00a0\u2014 numbers $a$ and $b$ chosen and erased in each operation.\n\n\n-----Example-----\nInput\n1\n4\n\nOutput\n2\n2 4\n3 3\n3 1\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nNumbers $1, 2, 3, \\dots n$ (each integer from $1$ to $n$ once) are written on a board. In one operation you can erase any two numbers $a$ and $b$ from the board and write one integer $\\frac{a + b}{2}$ rounded up instead.\n\nYou should perform the given operation $n - 1$ times and make the resulting number that will be left on the board as small as possible. \n\nFor example, if $n = 4$, the following course of action is optimal:  choose $a = 4$ and $b = 2$, so the new number is $3$, and the whiteboard contains $[1, 3, 3]$;  choose $a = 3$ and $b = 3$, so the new number is $3$, and the whiteboard contains $[1, 3]$;  choose $a = 1$ and $b = 3$, so the new number is $2$, and the whiteboard contains $[2]$. \n\nIt's easy to see that after $n - 1$ operations, there will be left only one number. Your goal is to minimize it.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains one integer $n$ ($2 \\le n \\le 2 \\cdot 10^5$)\u00a0\u2014 the number of integers written on the board initially.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each test case, in the first line, print the minimum possible number left on the board after $n - 1$ operations. Each of the next $n - 1$ lines should contain two integers\u00a0\u2014 numbers $a$ and $b$ chosen and erased in each operation.\n\n\n-----Example-----\nInput\n1\n4\n\nOutput\n2\n2 4\n3 3\n3 1\n\"\"\"\ndef code():"
}