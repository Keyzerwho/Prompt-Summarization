{
    "0": "Python 3\n\"\"\"\nYou are given a string $s$ of even length $n$. String $s$ is binary.\n\nString $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string.\n\nWhat is the minimum number of operations you need to make string $s$ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010...\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a binary string $s$ of length $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum number of operations to make $s$ alternating.\n\n\n-----Example-----\nInput\n3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nYou are given a string $s$ of even length $n$. String $s$ is binary, in other words, consists only of 0's and 1's.\n\nString $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string.\n\nWhat is the minimum number of operations you need to make string $s$ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010...\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a binary string $s$ of length $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum number of operations to make $s$ alternating.\n\n\n-----Example-----\nInput\n3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\n\n\n-----Note-----\n\nIn the first test case, string 10 is already alternating.\n\nIn the second test case, we can, for example, reverse the last two elements of $s$ and get: 0110 $\\rightarrow$ 0101.\n\nIn the third test case, we can, for example, make the following two operations:   11101000 $\\rightarrow$ 10101100;  10101100 $\\rightarrow$ 10101010.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nYou have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\n \nThe output should be the total number of full staircase rows formed.\n\nn>=0 and has the range of a 32-bit signed integer.\n\nExample 1:\n\nn = 5\n\nThe coins can form the following rows:\n\u00a4\n\u00a4 \u00a4\n\u00a4 \u00a4\n\nBecause the 3rd row is incomplete, we return 2.\n\n\n\nExample 2:\n\nn = 8\n\nThe coins can form the following rows:\n\u00a4\n\u00a4 \u00a4\n\u00a4 \u00a4 \u00a4\n\u00a4 \u00a4\n\nBecause the 4th row is incomplete, we return 3.\n\"\"\"\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:",
    "3": "Python 3\n\"\"\"\nYou have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\n \nGiven n, find the total number of full staircase rows that can be formed.\n\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\n\nExample 1:\n\nn = 5\n\nThe coins can form the following rows:\n\u00a4\n\u00a4 \u00a4\n\u00a4 \u00a4\n\nBecause the 3rd row is incomplete, we return 2.\n\n\n\nExample 2:\n\nn = 8\n\nThe coins can form the following rows:\n\u00a4\n\u00a4 \u00a4\n\u00a4 \u00a4 \u00a4\n\u00a4 \u00a4\n\nBecause the 4th row is incomplete, we return 3.\n\"\"\"\nclass Solution:\n    def arrangeCoins(self, n: int) -> int:",
    "4": "Python 3\n\"\"\"\nYou are given a list of strings where each string in format of \"A,B,C,D\". where A,D are strings and B,C are numbers. A string is possibly invalid if:\n\nthe C exceeds 1000, or;\nif two strings have same A and different D and the difference between C is greater than or equal to 60.\n\nreturn list of strings which are possibley invalid in any order\n\nExample 1:\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\nExample 2:\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]\n\nExample 3:\nInput: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]\n\n\u00a0\nConstraints:\n\ntransactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city}\u00a0consist of\u00a0lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of\u00a0digits, and represent an integer between 0 and 1000.\nEach {amount}\u00a0consist of\u00a0digits, and represent an integer between 0 and 2000.\n\n\"\"\"\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:",
    "5": "Python 3\n\"\"\"\nA transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nEach transaction string transactions[i]\u00a0consists of\u00a0comma separated values representing\u00a0the name, time (in minutes), amount, and city of the transaction.\nGiven a list of transactions,\u00a0return a list of transactions that are possibly invalid.\u00a0 You may return the answer in any order.\n\u00a0\nExample 1:\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\nExample 2:\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]\n\nExample 3:\nInput: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]\n\n\u00a0\nConstraints:\n\ntransactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city}\u00a0consist of\u00a0lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of\u00a0digits, and represent an integer between 0 and 1000.\nEach {amount}\u00a0consist of\u00a0digits, and represent an integer between 0 and 2000.\n\"\"\"\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:",
    "6": "Python 3\n\"\"\"\nYou have a sequence A of N non-negative integers.\nCompute the sum of \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} over all sequences B of N non-negative integers whose sum is at most M, and print it modulo (10^9 + 7).\n\\dbinom{B_i}{A_i}, the binomial coefficient, denotes the number of ways to choose A_i objects from B_i objects, and is 0 when B_i < A_i.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 2000\n - 1 \\leq M \\leq 10^9\n - 0 \\leq A_i \\leq 2000\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 A_2 \\ldots A_N\n\n-----Output-----\nPrint the sum of \\prod _{i = 1} ^N \\dbinom{B_i}{A_i}, modulo (10^9 + 7).\n\n-----Sample Input-----\n3 5\n1 2 1\n\n-----Sample Output-----\n8\n\n\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nWe have a sequence A of N non-negative integers.\nCompute the sum of \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} over all sequences B of N non-negative integers whose sum is at most M, and print it modulo (10^9 + 7).\nHere, \\dbinom{B_i}{A_i}, the binomial coefficient, denotes the number of ways to choose A_i objects from B_i objects, and is 0 when B_i < A_i.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 2000\n - 1 \\leq M \\leq 10^9\n - 0 \\leq A_i \\leq 2000\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 A_2 \\ldots A_N\n\n-----Output-----\nPrint the sum of \\prod _{i = 1} ^N \\dbinom{B_i}{A_i}, modulo (10^9 + 7).\n\n-----Sample Input-----\n3 5\n1 2 1\n\n-----Sample Output-----\n8\n\nThere are four sequences B such that \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} is at least 1:\n - B = \\{1, 2, 1\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{1}{1} \\times \\dbinom{2}{2} \\times \\dbinom{1}{1} = 1;\n - B = \\{2, 2, 1\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{2}{1} \\times \\dbinom{2}{2} \\times \\dbinom{1}{1} = 2;\n - B = \\{1, 3, 1\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{1}{1} \\times \\dbinom{3}{2} \\times \\dbinom{1}{1} = 3;\n - B = \\{1, 2, 2\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{1}{1} \\times \\dbinom{2}{2} \\times \\dbinom{2}{1} = 2.\nThe sum of these is 1 + 2 + 3 + 2 = 8.\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\nThere is an integer sequence of length 2^N: A_0, A_1, ..., A_{2^N-1}.\nFor every integer K satisfying 1 \\leq K \\leq 2^N-1, solve the following problem:\n - Let i and j be integers. Find the maximum value of A_i + A_j where 0 \\leq i < j \\leq 2^N-1 and (i or j) \\leq K.\nHere, or denotes the bitwise OR.\n\n-----Constraints-----\n - 1 \\leq N \\leq 18\n - 1 \\leq A_i \\leq 10^9\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_0 A_1 ... A_{2^N-1}\n\n-----Output-----\nPrint 2^N-1 lines.\nIn the i-th line, print the answer of the problem above for K=i.\n\n-----Sample Input-----\n2\n1 2 3 1\n\n-----Sample Output-----\n3\n4\n5\n\n\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nThere is an integer sequence of length 2^N: A_0, A_1, ..., A_{2^N-1}. (Note that the sequence is 0-indexed.)\nFor every integer K satisfying 1 \\leq K \\leq 2^N-1, solve the following problem:\n - Let i and j be integers. Find the maximum value of A_i + A_j where 0 \\leq i < j \\leq 2^N-1 and (i or j) \\leq K.\nHere, or denotes the bitwise OR.\n\n-----Constraints-----\n - 1 \\leq N \\leq 18\n - 1 \\leq A_i \\leq 10^9\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_0 A_1 ... A_{2^N-1}\n\n-----Output-----\nPrint 2^N-1 lines.\nIn the i-th line, print the answer of the problem above for K=i.\n\n-----Sample Input-----\n2\n1 2 3 1\n\n-----Sample Output-----\n3\n4\n5\n\nFor K=1, the only possible pair of i and j is (i,j)=(0,1), so the answer is A_0+A_1=1+2=3.\nFor K=2, the possible pairs of i and j are (i,j)=(0,1),(0,2).\nWhen (i,j)=(0,2), A_i+A_j=1+3=4. This is the maximum value, so the answer is 4.\nFor K=3, the possible pairs of i and j are (i,j)=(0,1),(0,2),(0,3),(1,2),(1,3),(2,3) .\nWhen (i,j)=(1,2), A_i+A_j=2+3=5. This is the maximum value, so the answer is 5.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\nYou are initially at the top-left corner of a m x n grid.\nYou can only take down or right actions.\nHow many possible unique paths are there to reach the bottom-right corner of the grid?\n\nNote: m and n will be at most 100.\n\n\nExample 1:\n\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n\n\nExample 2:\n\n\nInput: m = 7, n = 3\nOutput: 28\n\"\"\"\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:",
    "11": "Python 3\n\"\"\"\nA robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nHow many possible unique paths are there?\n\n\nAbove is a 7 x 3 grid. How many possible unique paths are there?\n\nNote: m and n will be at most 100.\n\n\nExample 1:\n\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n\n\nExample 2:\n\n\nInput: m = 7, n = 3\nOutput: 28\n\"\"\"\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:",
    "12": "Python 3\n\"\"\"\n# Task\n\nGiven case insensitive strings, you will encode strings using a Soundex variation called \"American Soundex\" using the following steps:\n\n1. Save the first letter. Remove all occurrences of h and w except first letter.\n2. Replace all consonants with digits as follows:\n * b, f, p, v = 1\n * c, g, j, k, q, s, x, z = 2\n * d, t = 3\n * l = 4\n * m, n = 5\n * r = 6\n3. Replace all adjacent same digits with one digit.\n4. Remove all occurrences of a, e, i, o, u, y except first letter.\n5. If first symbol is a digit replace it with letter saved on step 1.\n6. Append 3 zeros if result contains less than 3 digits. Remove all except first letter and 3 digits after it.\n\n# Input\n\nA space separated string of one or more names. E.g. Sarah Connor\n\n# Output\n\nSpace separated string of equivalent Soundex codes, the first character of each code must be uppercase. E.g. S600 C560\n\"\"\"\ndef soundex(name):",
    "13": "Python 3\n\"\"\"\n# A History Lesson\n\nSoundex is an interesting phonetic algorithm developed nearly 100 years ago for indexing names as they are pronounced in English. The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling.\n\nReference: https://en.wikipedia.org/wiki/Soundex\n\n\n\n# Preface\n\nI first read about Soundex over 30 years ago. At the time it seemed to me almost  like  A.I. that you could just type in somebody's name the way it sounded and there was still a pretty good chance it could match the correct person record. That was about the same year as the first \"Terminator\" movie so it was easy for me to put 2 and 2 together and conclude that Arnie must have had some kind of futuristic Soundex chip in his titanium skull helping him to locate ```Serah Coner```... or was it ```Sarh Connor```... or maybe ```Sayra Cunnarr```...\n\n:-)\n\n\n\n# Task\n\nIn this Kata you will encode strings using a Soundex variation called \"American Soundex\" using the following (case insensitive) steps:\n\n* Save the first letter. Remove all occurrences of ```h``` and ```w``` except first letter.\n* Replace all consonants (include the first letter) with digits as follows:\n * ```b```, ```f```, ```p```, ```v``` = 1\n * ```c```, ```g```, ```j```, ```k```, ```q```, ```s```, ```x```, ```z``` = 2\n * ```d```, ```t``` = 3\n * ```l``` = 4\n * ```m```, ```n``` = 5\n * ```r``` = 6\n* Replace all adjacent same digits with one digit.\n* Remove all occurrences of ```a```, ```e```, ```i```, ```o```, ```u```, ```y``` except first letter.\n* If first symbol is a digit replace it with letter saved on step 1.\n* Append 3 zeros if result contains less than 3 digits. Remove all except first letter and 3 digits after it\n\n## Input\n\nA space separated string of one or more names. E.g.\n\n```Sarah Connor```\n\n## Output\n\nSpace separated string of equivalent Soundex codes (the first character of each code must be uppercase). E.g.\n\n```S600 C560```\n\"\"\"\ndef soundex(name):",
    "14": "Python 3\n\"\"\"\nFind the second-to-last element of a list.\n\nExamples:\nInput:\npenultimate([1,2,3,4])\nOutput:\n3\nInput:\npenultimate([\"Python is dynamic\"])\nOutput:\n'i'\n\n\"\"\"\ndef penultimate(a):",
    "15": "Python 3\n\"\"\"\nFind the second-to-last element of a list.\n\nExample:\n```python\npenultimate([1,2,3,4])            # => 3\npenultimate([\"Python is dynamic\"]) # => 'i'\n(courtesy of [haskell.org](http://www.haskell.org/haskellwiki/99_questions/1_to_10))\n```\n\"\"\"\ndef penultimate(a):",
    "16": "Python 3\n\"\"\"\nIn Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed.\n\nLet the total number of sequences listed in FEIS be X. Among those sequences, find the (X/2)-th lexicographically smallest one.\n\n-----Constraints-----\n - 1 \\leq N,K \\leq 3 \u00d7 10^5\n\n\n-----Input-----\nInput is given from Standard Input in the following format:\nK N\n\n-----Output-----\nPrint the (X/2)-th lexicographically smallest sequence listed in FEIS, with spaces in between, where X is the total number of sequences listed in FEIS.\n\n-----Sample Input-----\n3 2\n\n-----Sample Output-----\n2 1 \n\nThere are 12 sequences listed in FEIS: (1),(1,1),(1,2),(1,3),(2),(2,1),(2,2),(2,3),(3),(3,1),(3,2),(3,3).\nThe (12/2 = 6)-th lexicographically smallest one among them is (2,1).\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nIn Finite Encyclopedia of Integer Sequences (FEIS), all integer sequences of lengths between 1 and N (inclusive) consisting of integers between 1 and K (inclusive) are listed.\nLet the total number of sequences listed in FEIS be X. Among those sequences, find the (X/2)-th (rounded up to the nearest integer) lexicographically smallest one.\n\n-----Constraints-----\n - 1 \\leq N,K \\leq 3 \u00d7 10^5\n - N and K are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nK N\n\n-----Output-----\nPrint the (X/2)-th (rounded up to the nearest integer) lexicographically smallest sequence listed in FEIS, with spaces in between, where X is the total number of sequences listed in FEIS.\n\n-----Sample Input-----\n3 2\n\n-----Sample Output-----\n2 1 \n\nThere are 12 sequences listed in FEIS: (1),(1,1),(1,2),(1,3),(2),(2,1),(2,2),(2,3),(3),(3,1),(3,2),(3,3).\nThe (12/2 = 6)-th lexicographically smallest one among them is (2,1).\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nThe factorial of a number, `n!`, is defined for whole numbers as the product of all integers from `1` to `n`. \n\nFor example, 5! is 5 * 4 * 3 * 2 * 1 = 120\n\nWrite an implementation to calculate the factorial of arbitrarily large numbers, without recursion.\n\n# Rules\n\n* `n < 0` should return `nil`/  `None`\n* `n = 0` should return `1`\n* `n > 0` should return `n!`\n\n# Note\n\nCodewars limits the amount of data it will send back and forth, which may introduce a false ceiling for how high of a value of `n` it will accept. All tests use values less than this limit.\n\"\"\"\ndef factorial(n):",
    "19": "Python 3\n\"\"\"\nThe factorial of a number, `n!`, is defined for whole numbers as the product of all integers from `1` to `n`. \n\nFor example, `5!` is `5 * 4 * 3 * 2 * 1 = 120`\n\nMost factorial implementations use a recursive function to determine the value of `factorial(n)`. However, this blows up the stack for large values of `n` - most systems cannot handle stack depths much greater than 2000 levels.\n\nWrite an implementation to calculate the factorial of arbitrarily large numbers, *without recursion.*\n\n# Rules\n\n* `n < 0` should return `nil`/  `None`\n* `n = 0` should return `1`\n* `n > 0` should return `n!`\n\n# Note\n\nCodewars limits the amount of data it will send back and forth, which may introduce a false ceiling for how high of a value of `n` it will accept. All tests use values less than this limit.\n\"\"\"\ndef factorial(n):"
}