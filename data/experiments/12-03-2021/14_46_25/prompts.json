{
    "0": "Python 3\n\"\"\"\nConsider all integer sequences of length N whose elements are between 1 and 10, inclusive. Out of those 10^N sequences, how many contain an X,Y,Z-Haiku?\nPrint the answer modulo 10^9+7.\n\n-----Constraints-----\n - 3 \u2266 N \u2266 40\n - 1 \u2266 X \u2266 5\n - 1 \u2266 Y \u2266 7\n - 1 \u2266 Z \u2266 5\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN X Y Z\n\n-----Output-----\nPrint the number of the sequences that contain an X,Y,Z-Haiku, modulo 10^9+7.\n\n-----Sample Input-----\n3 5 7 5\n\n-----Sample Output-----\n1\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nHaiku is a short form of Japanese poetry. A Haiku consists of three phrases with 5, 7 and 5 syllables, in this order.\nIroha is looking for X,Y,Z-Haiku (defined below) in integer sequences.\nConsider all integer sequences of length N whose elements are between 1 and 10, inclusive. Out of those 10^N sequences, how many contain an X,Y,Z-Haiku?\nHere, an integer sequence a_0, a_1, ..., a_{N-1} is said to contain an X,Y,Z-Haiku if and only if there exist four indices x, y, z, w (0 \u2266 x < y < z < w \u2266 N) such that all of the following are satisfied:\n - a_x + a_{x+1} + ... + a_{y-1} = X\n - a_y + a_{y+1} + ... + a_{z-1} = Y\n - a_z + a_{z+1} + ... + a_{w-1} = Z\nSince the answer can be extremely large, print the number modulo 10^9+7.\n\n-----Constraints-----\n - 3 \u2266 N \u2266 40\n - 1 \u2266 X \u2266 5\n - 1 \u2266 Y \u2266 7\n - 1 \u2266 Z \u2266 5\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN X Y Z\n\n-----Output-----\nPrint the number of the sequences that contain an X,Y,Z-Haiku, modulo 10^9+7.\n\n-----Sample Input-----\n3 5 7 5\n\n-----Sample Output-----\n1\n\nHere, the only sequence that contains a 5,7,5-Haiku is [5, 7, 5].\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nYou have a bracket sequence s_1, s_2, ..., s_{n}, or, in other words, a string s of length n, consisting of characters \"(\" and \")\".\n\nYou need to answer m queries, each of them is described by two integers l_{i}, r_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence s_{l}_{i}, s_{l}_{i} + 1, ..., s_{r}_{i}.\n\n-----Input-----\n\nThe first line contains a sequence of characters s_1, s_2, ..., s_{n} (1 \u2264 n \u2264 10^6) without any spaces. Each character is either a \"(\" or a \")\". The second line contains integer m (1 \u2264 m \u2264 10^5) \u2014 the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers l_{i}, r_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 n) \u2014 the description of the i-th query.\n\n\n-----Output-----\n\nPrint the answer to each question on a single line. Print the answers in the order they go in the input.\n\n\n-----Examples-----\nInput\n())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10\n\nOutput\n0\n0\n2\n10\n4\n6\n6\n\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nSereja has a bracket sequence s_1, s_2, ..., s_{n}, or, in other words, a string s of length n, consisting of characters \"(\" and \")\".\n\nSereja needs to answer m queries, each of them is described by two integers l_{i}, r_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence s_{l}_{i}, s_{l}_{i} + 1, ..., s_{r}_{i}. Help Sereja answer all queries.\n\nYou can find the definitions for a subsequence and a correct bracket sequence in the notes.\n\n\n-----Input-----\n\nThe first line contains a sequence of characters s_1, s_2, ..., s_{n} (1 \u2264 n \u2264 10^6) without any spaces. Each character is either a \"(\" or a \")\". The second line contains integer m (1 \u2264 m \u2264 10^5) \u2014 the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers l_{i}, r_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 n) \u2014 the description of the i-th query.\n\n\n-----Output-----\n\nPrint the answer to each question on a single line. Print the answers in the order they go in the input.\n\n\n-----Examples-----\nInput\n())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10\n\nOutput\n0\n0\n2\n10\n4\n6\n6\n\n\n\n-----Note-----\n\nA subsequence of length |x| of string s = s_1s_2... s_{|}s| (where |s| is the length of string s) is string x = s_{k}_1s_{k}_2... s_{k}_{|}x| (1 \u2264 k_1 < k_2 < ... < k_{|}x| \u2264 |s|).\n\nA correct bracket sequence is a bracket sequence that can be transformed into a correct aryphmetic expression by inserting characters \"1\" and \"+\" between the characters of the string. For example, bracket sequences \"()()\", \"(())\" are correct (the resulting expressions \"(1)+(1)\", \"((1+1)+1)\"), and \")(\" and \"(\" are not.\n\nFor the third query required sequence will be \u00ab()\u00bb.\n\nFor the fourth query required sequence will be \u00ab()(())(())\u00bb.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nYou need to write the method that returns true if 2 integers share at least two '1' bits. Assume that all numbers are positive\n\nFor example\nint seven = 7;    //0111\nint ten = 10;     //1010\nint fifteen = 15; //1111\nSharedBits(seven, ten);     //false\nSharedBits(seven, fifteen); //true\nSharedBits(ten, fifteen);   //true\n\n- seven and ten share only a single '1' (at index 3)\n- seven and fifteen share 3 bits (at indexes 1, 2, and 3)\n- ten and fifteen  share 2 bits (at indexes 0 and 2)\n\n\"\"\"\ndef shared_bits(a, b):",
    "5": "Python 3\n\"\"\"\nIn this Kata you need to write the method SharedBits that returns true if 2 integers share at least two '1' bits. For simplicity assume that all numbers are positive\n\nFor example\nint seven = 7;    //0111\nint ten = 10;     //1010\nint fifteen = 15; //1111\nSharedBits(seven, ten);     //false\nSharedBits(seven, fifteen); //true\nSharedBits(ten, fifteen);   //true\n\n- seven and ten share only a single '1' (at index 3)\n- seven and fifteen share 3 bits (at indexes 1, 2, and 3)\n- ten and fifteen  share 2 bits (at indexes 0 and 2)\n\nHint: you can do this with just string manipulation, but binary operators will make your life much easier.\n\"\"\"\ndef shared_bits(a, b):",
    "6": "Python 3\n\"\"\"\nYou are given a string $s$ of even length $n$. String $s$ is binary.\n\nString $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string.\n\nWhat is the minimum number of operations you need to make string $s$ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010...\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a binary string $s$ of length $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum number of operations to make $s$ alternating.\n\n\n-----Example-----\nInput\n3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nYou are given a string $s$ of even length $n$. String $s$ is binary, in other words, consists only of 0's and 1's.\n\nString $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string.\n\nWhat is the minimum number of operations you need to make string $s$ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010...\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even)\u00a0\u2014 the length of string $s$.\n\nThe second line of each test case contains a binary string $s$ of length $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum number of operations to make $s$ alternating.\n\n\n-----Example-----\nInput\n3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\n\n\n-----Note-----\n\nIn the first test case, string 10 is already alternating.\n\nIn the second test case, we can, for example, reverse the last two elements of $s$ and get: 0110 $\\rightarrow$ 0101.\n\nIn the third test case, we can, for example, make the following two operations:   11101000 $\\rightarrow$ 10101100;  10101100 $\\rightarrow$ 10101010.\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\n# Task\n Consider the following algorithm for constructing strings S(1) .. S(26):\n```\nS(1) = \"a\";\nFor i in [2, 3, ..., 26]:\nS(i) = S(i - 1) + character(i) + S(i - 1).```\n\nYour task is to find the `k`th symbol (indexing from 1) in the string S(26).\n\n# Input / Output\n\n\n - `[input]` integer `k`\n\n  1 \u2264 k < 2^(26)\n\n\n - `[output]` a string(char in C#)\n\n  the `k`th symbol of S(26)\n\"\"\"\ndef abacaba(k):",
    "9": "Python 3\n\"\"\"\n# Task\n Consider the following algorithm for constructing 26 strings S(1) .. S(26):\n```\nS(1) = \"a\";\nFor i in [2, 3, ..., 26]:\nS(i) = S(i - 1) + character(i) + S(i - 1).```\n\n For example:\n```\nS(1) = \"a\"\nS(2) = S(1) + \"b\" + S(1) = \"a\" + \"b\" + \"a\" = \"aba\"\nS(3) = S(2) + \"c\" + S(2) = \"aba\" + \"c\" +\"aba\" = \"abacaba\"\n...\nS(26) = S(25) + \"z\" + S(25)```\nFinally, we got a long string S(26). Your task is to find the `k`th symbol (indexing from 1) in the string S(26). All strings consist of lowercase letters only.\n\n# Input / Output\n\n\n - `[input]` integer `k`\n\n  1 \u2264 k < 2^(26)\n\n\n - `[output]` a string(char in C#)\n\n  the `k`th symbol of S(26)\n\"\"\"\ndef abacaba(k):",
    "10": "Python 3\n\"\"\"\n# Task\n\nGiven case insensitive strings, you will encode strings using a Soundex variation called \"American Soundex\".\n\n# Input\n\nA space separated string of one or more names. E.g. Sarah Connor\n\n# Output\n\nSpace separated string of equivalent Soundex codes, the first character of each code must be uppercase. E.g. S600 C560\n\"\"\"\ndef soundex(name):",
    "11": "Python 3\n\"\"\"\n# A History Lesson\n\nSoundex is an interesting phonetic algorithm developed nearly 100 years ago for indexing names as they are pronounced in English. The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling.\n\nReference: https://en.wikipedia.org/wiki/Soundex\n\n\n\n# Preface\n\nI first read about Soundex over 30 years ago. At the time it seemed to me almost  like  A.I. that you could just type in somebody's name the way it sounded and there was still a pretty good chance it could match the correct person record. That was about the same year as the first \"Terminator\" movie so it was easy for me to put 2 and 2 together and conclude that Arnie must have had some kind of futuristic Soundex chip in his titanium skull helping him to locate ```Serah Coner```... or was it ```Sarh Connor```... or maybe ```Sayra Cunnarr```...\n\n:-)\n\n\n\n# Task\n\nIn this Kata you will encode strings using a Soundex variation called \"American Soundex\" using the following (case insensitive) steps:\n\n* Save the first letter. Remove all occurrences of ```h``` and ```w``` except first letter.\n* Replace all consonants (include the first letter) with digits as follows:\n * ```b```, ```f```, ```p```, ```v``` = 1\n * ```c```, ```g```, ```j```, ```k```, ```q```, ```s```, ```x```, ```z``` = 2\n * ```d```, ```t``` = 3\n * ```l``` = 4\n * ```m```, ```n``` = 5\n * ```r``` = 6\n* Replace all adjacent same digits with one digit.\n* Remove all occurrences of ```a```, ```e```, ```i```, ```o```, ```u```, ```y``` except first letter.\n* If first symbol is a digit replace it with letter saved on step 1.\n* Append 3 zeros if result contains less than 3 digits. Remove all except first letter and 3 digits after it\n\n## Input\n\nA space separated string of one or more names. E.g.\n\n```Sarah Connor```\n\n## Output\n\nSpace separated string of equivalent Soundex codes (the first character of each code must be uppercase). E.g.\n\n```S600 C560```\n\"\"\"\ndef soundex(name):",
    "12": "Python 3\n\"\"\"\nThere are N people, numbered 1 through N.\nWe want to divide them into some number of groups, under the following two conditions:\n - Every group contains between A and B people, inclusive.\n - Let F_i be the number of the groups containing exactly i people. Then, for all i, either F_i=0 or C\u2264F_i\u2264D holds.\nFind the number of these ways to divide the people into groups.\nHere, two ways to divide them into groups is considered different if and only if there exists two people such that they belong to the same group in exactly one of the two ways.\nprint the answer modulo 10^9+7.\n\n-----Constraints-----\n - 1\u2264N\u226410^3\n - 1\u2264A\u2264B\u2264N\n - 1\u2264C\u2264D\u2264N\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN A B C D\n\n-----Output-----\nPrint the number of ways to divide the people into groups under the conditions, modulo 10^9+7.\n\n-----Sample Input-----\n3 1 3 1 2\n\n-----Sample Output-----\n4\n\n\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nThere are N people, conveniently numbered 1 through N.\nWe want to divide them into some number of groups, under the following two conditions:\n - Every group contains between A and B people, inclusive.\n - Let F_i be the number of the groups containing exactly i people. Then, for all i, either F_i=0 or C\u2264F_i\u2264D holds.\nFind the number of these ways to divide the people into groups.\nHere, two ways to divide them into groups is considered different if and only if there exists two people such that they belong to the same group in exactly one of the two ways.\nSince the number of these ways can be extremely large, print the count modulo 10^9+7.\n\n-----Constraints-----\n - 1\u2264N\u226410^3\n - 1\u2264A\u2264B\u2264N\n - 1\u2264C\u2264D\u2264N\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN A B C D\n\n-----Output-----\nPrint the number of ways to divide the people into groups under the conditions, modulo 10^9+7.\n\n-----Sample Input-----\n3 1 3 1 2\n\n-----Sample Output-----\n4\n\nThere are four ways to divide the people:\n - (1,2),(3)\n - (1,3),(2)\n - (2,3),(1)\n - (1,2,3)\nThe following way to divide the people does not count: (1),(2),(3). This is because it only satisfies the first condition and not the second.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nCheck whether the given number N is divisible by 3 or not. If yes then print 1 else print 0.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n18\n308\n\n-----Sample Output:-----\n1\n0\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nChef has a number N, Cheffina challenges the chef to check the divisibility of all the permutation of N by 3. If any of the permutations is divisible by 3 then print 1 else print 0.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n18\n308\n\n-----Sample Output:-----\n1\n0\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nGiven a two dimensional metrix of Latin letters, determine if the word \"spoon\" (case insensitive) appears in the matrix.\n\n-----Input-----\nThe first line of input contains a positive integer T, the number of test cases. After that T test cases follow. The first line of each test case contains two space separated integers R and C, the number of rows and the number of columns of the matrix M respectively. Thereafter R lines follow each containing C characters, the actual digital map itself.\n\n-----Output-----\nFor each test case print one line. If a \"Spoon\" is found in the matrix, output \"There is a spoon!\" else output \"There is indeed no spoon!\" (Quotes only for clarity).\n\n-----Constraints-----\n\n1 \u2264 T \u2264 100\n\n1 \u2264 R, C \u2264 100\n\n-----Sample Input-----\n3\n3 6\nabDefb\nbSpoon\nNIKHil\n6 6\naaaaaa\nssssss\nxuisdP\noooooo\nioowoo\nbdylan\n6 5\nbdfhj\ncacac\nopqrs\nddddd\nindia\nyucky\n\n-----Sample Output-----\nThere is a spoon!\nThere is a spoon!\nThere is indeed no spoon!\n\n-----Explanation-----\nIn the first test case, \"Spoon\" occurs in the second row. In the second test case, \"spOon\" occurs in the last column.\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nChef recently saw the movie Matrix. He loved the movie overall but he didn't agree with some things in it. Particularly he didn't agree with the bald boy when he declared - There is no spoon. Being a chef, he understands the importance of the spoon and realizes that the universe can't survive without it. Furthermore, he is sure there is a spoon; he saw it in his kitchen this morning. So he has set out to prove the bald boy is wrong and find a spoon in the matrix. He has even obtained a digital map already. Can you help him?\n\nFormally you're given a matrix of lowercase and uppercase Latin letters. Your job is to find out if the word \"Spoon\" occurs somewhere in the matrix or not. A word is said to be occurred in the matrix if it is presented in some row from left to right or in some column from top to bottom. Note that match performed has to be case insensitive. \n\n-----Input-----\nThe first line of input contains a positive integer T, the number of test cases. After that T test cases follow. The first line of each test case contains two space separated integers R and C, the number of rows and the number of columns of the matrix M respectively. Thereafter R lines follow each containing C characters, the actual digital map itself.\n\n-----Output-----\nFor each test case print one line. If a \"Spoon\" is found in Matrix, output \"There is a spoon!\" else output \"There is indeed no spoon!\" (Quotes only for clarity).\n\n-----Constraints-----\n\n1 \u2264 T \u2264 100\n\n1 \u2264 R, C \u2264 100\n\n-----Sample Input-----\n3\n3 6\nabDefb\nbSpoon\nNIKHil\n6 6\naaaaaa\nssssss\nxuisdP\noooooo\nioowoo\nbdylan\n6 5\nbdfhj\ncacac\nopqrs\nddddd\nindia\nyucky\n\n-----Sample Output-----\nThere is a spoon!\nThere is a spoon!\nThere is indeed no spoon!\n\n-----Explanation-----\nIn the first test case, \"Spoon\" occurs in the second row. In the second test case, \"spOon\" occurs in the last column.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nYou are given a prime number $p$, $n$ integers $a_1, a_2, \\ldots, a_n$, and an integer $k$. \n\nFind the number of pairs of indexes $(i, j)$ where, $1 \\le i < j \\le n$, for which $(a_i + a_j)(a_i^2 + a_j^2) \\equiv k \\bmod p$.\n\n\n-----Input-----\n\nThe first line contains integers $n, p, k$ ($2 \\le n \\le 3 \\cdot 10^5$, $2 \\le p \\le 10^9$, $0 \\le k \\le p-1$). $p$ is guaranteed to be prime.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le p-1$). It is guaranteed that all elements are different.\n\n\n-----Output-----\n\nOutput a single integer\u00a0\u2014 answer to the problem.\n\n\n-----Examples-----\nInput\n3 3 0\n0 1 2\n\nOutput\n1\nInput\n6 7 2\n1 2 3 4 5 6\n\nOutput\n3\n\n\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nYou are given a prime number $p$, $n$ integers $a_1, a_2, \\ldots, a_n$, and an integer $k$. \n\nFind the number of pairs of indexes $(i, j)$ ($1 \\le i < j \\le n$) for which $(a_i + a_j)(a_i^2 + a_j^2) \\equiv k \\bmod p$.\n\n\n-----Input-----\n\nThe first line contains integers $n, p, k$ ($2 \\le n \\le 3 \\cdot 10^5$, $2 \\le p \\le 10^9$, $0 \\le k \\le p-1$). $p$ is guaranteed to be prime.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le p-1$). It is guaranteed that all elements are different.\n\n\n-----Output-----\n\nOutput a single integer\u00a0\u2014 answer to the problem.\n\n\n-----Examples-----\nInput\n3 3 0\n0 1 2\n\nOutput\n1\nInput\n6 7 2\n1 2 3 4 5 6\n\nOutput\n3\n\n\n-----Note-----\n\nIn the first example:\n\n$(0+1)(0^2 + 1^2) = 1 \\equiv 1 \\bmod 3$.\n\n$(0+2)(0^2 + 2^2) = 8 \\equiv 2 \\bmod 3$.\n\n$(1+2)(1^2 + 2^2) = 15 \\equiv 0 \\bmod 3$.\n\nSo only $1$ pair satisfies the condition.\n\nIn the second example, there are $3$ such pairs: $(1, 5)$, $(2, 3)$, $(4, 6)$.\n\"\"\"\ndef code():"
}