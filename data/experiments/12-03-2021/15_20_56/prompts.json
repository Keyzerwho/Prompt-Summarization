{
    "0": "Python 3\n\"\"\"\nWe make 2 rows and put first letter in the Row 1, the second in the Row 2, third in Row 1 and so on until the end. Then we put the text from Row 2 next to the Row 1 text.\n\n\n## Example\nFor example if the text to encrypt is: `\"Simple text\"`, the 2 rows will be:\n\n\n\nRow 1\nS\nm\nl\n \ne\nt\n\n\nRow 2\ni\np\ne\nt\nx\n \n\n\n\nSo the result string will be: `\"Sml etipetx\"`\n\"\"\"\ndef simple_transposition(text):",
    "1": "Python 3\n\"\"\"\nSimple transposition is a basic and simple cryptography technique. We make 2 rows and put first a letter in the Row 1, the second in the Row 2, third in Row 1 and so on until the end. Then we put the text from Row 2 next to the Row 1 text and thats it.\n\nComplete the function that receives a string and encrypt it with this simple transposition.\n\n## Example\nFor example if the text to encrypt is: `\"Simple text\"`, the 2 rows will be:\n\n\n\nRow 1\nS\nm\nl\n \ne\nt\n\n\nRow 2\ni\np\ne\nt\nx\n \n\n\n\nSo the result string will be: `\"Sml etipetx\"`\n\"\"\"\ndef simple_transposition(text):",
    "2": "Python 3\n\"\"\"\nWrite a function that calculates the sum of similarities of a string with each of its suffixes.\n\nExamples:\nInput:\nstring_suffix('ababaa')\nOutput:\n11\nExplanation:\nThe suffixes of the string are `ababaa`, `babaa`, `abaa`, `baa`, `aa` and `a`. The similarities of each of these strings with the string `ababaa` are 6,0,3,0,1,1 respectively. Thus the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11.\n\nInput:\nstring_suffix('abc')\nOutput:\n3\n\"\"\"\ndef string_suffix(s):",
    "3": "Python 3\n\"\"\"\nLet's say take 2 strings, A and B, and define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings `abc` and `abd` is 2, while the similarity of strings `aaa` and `aaab` is 3.\n\nwrite a function that calculates the sum of similarities of a string S with each of it's **suffixes**.\n\n```python\nstring_suffix('ababaa') => returns 11\nstring_suffix('abc') => returns 3\n```\n\nExplanation:\n\nIn the first case, the suffixes of the string are `ababaa`, `babaa`, `abaa`, `baa`, `aa` and `a`. The similarities of each of these strings with the string `ababaa` are 6,0,3,0,1,1 respectively. Thus the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11.\n\nFor the second case, the answer is simply 3 + 0 + 0 = 3.\n\nNote : Each string will have at least one character - no need to check for empty strings :)\n\"\"\"\ndef string_suffix(s):",
    "4": "Python 3\n\"\"\"\nConsider a sequence [a_1, a_2, ... , a_{n}]. \n\nLet's define its prefix product sequence as $[ a_{1} \\operatorname{mod} n,(a_{1} a_{2}) \\operatorname{mod} n, \\cdots,(a_{1} a_{2} \\cdots a_{n}) \\operatorname{mod} n ]$.\n\nNow given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1].\n\n\n-----Input-----\n\nThe only input line contains an integer n (1 \u2264 n \u2264 10^5).\n\n\n-----Output-----\n\nIn the first output line, print \"YES\" if such sequence exists, or print \"NO\" if no such sequence exists.\n\nIf any solution exists, you should output n more lines. i-th line contains only an integer a_{i}. The elements of the sequence should be different positive integers no larger than n.\n\nIf there are multiple solutions, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n7\n\nOutput\nYES\n1\n4\n3\n6\n5\n2\n7\n\nInput\n6\n\nOutput\nNO\n\n\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nConsider a sequence [a_1, a_2, ... , a_{n}]. Define its prefix product sequence $[ a_{1} \\operatorname{mod} n,(a_{1} a_{2}) \\operatorname{mod} n, \\cdots,(a_{1} a_{2} \\cdots a_{n}) \\operatorname{mod} n ]$.\n\nNow given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1].\n\n\n-----Input-----\n\nThe only input line contains an integer n (1 \u2264 n \u2264 10^5).\n\n\n-----Output-----\n\nIn the first output line, print \"YES\" if such sequence exists, or print \"NO\" if no such sequence exists.\n\nIf any solution exists, you should output n more lines. i-th line contains only an integer a_{i}. The elements of the sequence should be different positive integers no larger than n.\n\nIf there are multiple solutions, you are allowed to print any of them.\n\n\n-----Examples-----\nInput\n7\n\nOutput\nYES\n1\n4\n3\n6\n5\n2\n7\n\nInput\n6\n\nOutput\nNO\n\n\n\n-----Note-----\n\nFor the second sample, there are no valid sequences.\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nGiven a string, return the minimal number of parenthesis reversals needed to make balanced parenthesis.\n\nFor example:\nInput:\nsolve(\")(\")\nOutput:\n2\nExplanation:\nBecause we need to reverse \")\" to \"(\" and \"(\" to \")\". These are 2 reversals.\n\nInput: \nsolve(\"(((())\")\nOutput:\n1\nExplanation:\nWe need to reverse just one \"(\" parenthesis to make it balanced.\n\nInput:\nsolve(\"(((\")\nOutput:\n-1\nExplanation:\nNot possible to form balanced parenthesis. Return -1.\n\"\"\"\ndef solve(s):",
    "7": "Python 3\n\"\"\"\nGiven a string, return the minimal number of parenthesis reversals needed to make balanced parenthesis. \n\nFor example:\n```Javascript\nsolve(\")(\") = 2 Because we need to reverse \")\" to \"(\" and \"(\" to \")\". These are 2 reversals. \nsolve(\"(((())\") = 1 We need to reverse just one \"(\" parenthesis to make it balanced.\nsolve(\"(((\") = -1 Not possible to form balanced parenthesis. Return -1.\n```\n\nParenthesis will be either `\"(\"` or `\")\"`. \n\nMore examples in the test cases. \n\nGood luck.\n\"\"\"\ndef solve(s):",
    "8": "Python 3\n\"\"\"\nSolve a given equation and return the value of x in the form of string \"x=#value\". For the equation, if there is no solution, return \"No solution\" or if infinite solutions, return \"Infinite solutions\" or if exactly one solution for the equation, ensure that the value of x is an integer.\n\n\nExample 1:\n\nInput: \"x+5-3+x=6+x-2\"\nOutput: \"x=2\"\n\n\n\nExample 2:\n\nInput: \"x=x\"\nOutput: \"Infinite solutions\"\n\n\n\nExample 3:\n\nInput: \"2x=x\"\nOutput: \"x=0\"\n\n\n\nExample 4:\n\nInput: \"2x+3x-6x=x+2\"\nOutput: \"x=-1\"\n\n\n\nExample 5:\n\nInput: \"x=x+2\"\nOutput: \"No solution\"\n\"\"\"\nclass Solution:\n    def solveEquation(self, equation: str) -> str:",
    "9": "Python 3\n\"\"\"\nSolve a given equation and return the value of x in the form of string \"x=#value\". The equation contains only '+', '-' operation, the variable x and its coefficient.\n\n\n\nIf there is no solution for the equation, return \"No solution\".\n\n\nIf there are infinite solutions for the equation, return \"Infinite solutions\".\n\n\nIf there is exactly one solution for the equation, we ensure that the value of x is an integer.\n\n\nExample 1:\n\nInput: \"x+5-3+x=6+x-2\"\nOutput: \"x=2\"\n\n\n\nExample 2:\n\nInput: \"x=x\"\nOutput: \"Infinite solutions\"\n\n\n\nExample 3:\n\nInput: \"2x=x\"\nOutput: \"x=0\"\n\n\n\nExample 4:\n\nInput: \"2x+3x-6x=x+2\"\nOutput: \"x=-1\"\n\n\n\nExample 5:\n\nInput: \"x=x+2\"\nOutput: \"No solution\"\n\"\"\"\nclass Solution:\n    def solveEquation(self, equation: str) -> str:",
    "10": "Python 3\n\"\"\"\n\nYou have to print the words in the given text in lexicographic order. Each word should appear exactly once and there should be no uppercase letters in the output.\n\n\n\n-----Input format-----\n- The first line of input contains a single integer $N$, indicating the number of lines in the input.\n- This is followed by $N$ lines of input text.\n\n-----Output format-----\n- The first line of output contains a single integer $M$ indicating the number of distinct words in the given text. \n- The next $M$ lines list out these words in lexicographic order.\n\n\n-----Sample Input-----\n2\nThis is a sample piece of text to illustrate this \nproblem. \n\n-----Sample Output-----\n10\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nIn this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline).\nYour task is print the words in the text in lexicographic order (that is, dictionary order). Each word should appear exactly once in your list. You can ignore the case (for instance, \"The\" and \"the\" are to be treated as the same word). There should be no uppercase letters in the output.\nFor example, consider the following candidate for the input text: \nThis is a sample piece of text to illustrate this \nproblem.\n\nThe corresponding output would read as:\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n\n-----Input format-----\n- The first line of input contains a single integer $N$, indicating the number of lines in the input.\n- This is followed by $N$ lines of input text.\n\n-----Output format-----\n- The first line of output contains a single integer $M$ indicating the number of distinct words in the given text. \n- The next $M$ lines list out these words in lexicographic order.\n\n-----Constraints-----\n- $1 \\leq N \\leq 10000$\n- There are at most 80 characters in each line.\n- There are at the most 1000 distinct words in the given text.\n\n-----Sample Input-----\n2\nThis is a sample piece of text to illustrate this \nproblem. \n\n-----Sample Output-----\n10\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\nYou are given two integers $d, m$, find the number of arrays $a$, with constraints.\nThe length of $a$ is $n$, $n \\ge 1$  $1 \\le a_1 < a_2 < \\dots < a_n \\le d$  \nDefine an array $b$ of length $n$ as follows: $b_1 = a_1$, $\\forall i > 1, b_i = b_{i - 1} \\oplus a_i$, \nwhere $\\oplus$ is the bitwise exclusive-or. \nAfter constructing an array $b$, the constraint $b_1 < b_2 < \\dots < b_{n - 1} < b_n$ should hold. \nYou need to find the answer modulo $m$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 100$).\n\nEach of the next $t$ lines contains two integers $d, m$ ($1 \\leq d, m \\leq 10^9$).\n\nNote that $m$ is not necessary the prime!\n\n\n-----Output-----\n\nPrint the number of arrays $a$, modulo $m$.\n\n\n-----Example-----\nInput\n10\n1 1000000000\n2 999999999\n3 99999998\n4 9999997\n5 999996\n6 99995\n7 9994\n8 993\n9 92\n10 1\n\nOutput\n1\n3\n5\n11\n17\n23\n29\n59\n89\n0\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nDreamoon likes sequences very much. So he created a problem about the sequence that you can't find in OEIS: \n\nYou are given two integers $d, m$, find the number of arrays $a$, satisfying the following constraints:  The length of $a$ is $n$, $n \\ge 1$  $1 \\le a_1 < a_2 < \\dots < a_n \\le d$  Define an array $b$ of length $n$ as follows: $b_1 = a_1$, $\\forall i > 1, b_i = b_{i - 1} \\oplus a_i$, where $\\oplus$ is the bitwise exclusive-or (xor). After constructing an array $b$, the constraint $b_1 < b_2 < \\dots < b_{n - 1} < b_n$ should hold. \n\nSince the number of possible arrays may be too large, you need to find the answer modulo $m$.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 100$) denoting the number of test cases in the input.\n\nEach of the next $t$ lines contains two integers $d, m$ ($1 \\leq d, m \\leq 10^9$).\n\nNote that $m$ is not necessary the prime!\n\n\n-----Output-----\n\nFor each test case, print the number of arrays $a$, satisfying all given constrains, modulo $m$.\n\n\n-----Example-----\nInput\n10\n1 1000000000\n2 999999999\n3 99999998\n4 9999997\n5 999996\n6 99995\n7 9994\n8 993\n9 92\n10 1\n\nOutput\n1\n3\n5\n11\n17\n23\n29\n59\n89\n0\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nYou are given an integer, take the average of each pair of consecutive digits. Repeat this process until you have a single integer, then return that integer. If the average of two digits is not an integer, round the result up.\n\nExample 1:\nInput: digitsAverage(246)\nOutput: 4\n\nExample 2:\nInput: digitsAverage(89)\nOutputL 9\n\"\"\"\ndef digits_average(input):",
    "15": "Python 3\n\"\"\"\nGiven an integer, take the (mean) average of each pair of consecutive digits. Repeat this process until you have a single integer, then return that integer. e.g.\n\nNote: if the average of two digits is not an integer, round the result **up** (e.g. the average of 8 and 9 will be 9)\n\n## Examples\n\n```\ndigitsAverage(246)  ==>  4\n\noriginal: 2   4   6\n           \\ / \\ /\n1st iter:   3   5\n             \\ /\n2nd iter:     4\n\n\ndigitsAverage(89)  ==>  9\n\noriginal: 8   9\n           \\ /\n1st iter:   9\n```\n\np.s. for a bigger challenge, check out the [one line version](https://www.codewars.com/kata/one-line-task-digits-average) of this kata by myjinxin2015!\n\"\"\"\ndef digits_average(input):",
    "16": "Python 3\n\"\"\"\nYou are given an array $a$ consisting of one element $1$ ($a = [1]$).\n\nIn one move, you can do one of the following things:\n\n  Increase some (single) element of $a$ by $1$ (choose some $i$ from $1$ to the current length of $a$ and increase $a_i$ by one);  Append the copy of some (single) element of $a$ to the end of the array (choose some $i$ from $1$ to the current length of $a$ and append $a_i$ to the end of the array). \n\nYour task is to find the minimum number of moves required to obtain the array with the sum at least $n$.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 10^9$) \u2014 the lower bound on the sum of the array.\n\n\n-----Output-----\n\nFor each test case, print the answer: the minimum number of moves required to obtain the array with the sum at least $n$.\n\n\n-----Example-----\nInput\n5\n1\n5\n42\n1337\n1000000000\n\nOutput\n0\n3\n11\n72\n63244\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nInitially, you have the array $a$ consisting of one element $1$ ($a = [1]$).\n\nIn one move, you can do one of the following things:\n\n  Increase some (single) element of $a$ by $1$ (choose some $i$ from $1$ to the current length of $a$ and increase $a_i$ by one);  Append the copy of some (single) element of $a$ to the end of the array (choose some $i$ from $1$ to the current length of $a$ and append $a_i$ to the end of the array). \n\nFor example, consider the sequence of five moves:\n\n  You take the first element $a_1$, append its copy to the end of the array and get $a = [1, 1]$.  You take the first element $a_1$, increase it by $1$ and get $a = [2, 1]$.  You take the second element $a_2$, append its copy to the end of the array and get $a = [2, 1, 1]$.  You take the first element $a_1$, append its copy to the end of the array and get $a = [2, 1, 1, 2]$.  You take the fourth element $a_4$, increase it by $1$ and get $a = [2, 1, 1, 3]$. \n\nYour task is to find the minimum number of moves required to obtain the array with the sum at least $n$.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 10^9$) \u2014 the lower bound on the sum of the array.\n\n\n-----Output-----\n\nFor each test case, print the answer: the minimum number of moves required to obtain the array with the sum at least $n$.\n\n\n-----Example-----\nInput\n5\n1\n5\n42\n1337\n1000000000\n\nOutput\n0\n3\n11\n72\n63244\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nFind the sum of the first n elements in the Recam\u00e1n Sequence. 0 <= n <= 2,500,000.\n\nThe Recam\u00e1n sequence is formed using the next formula:\n* We start with `0`\n* At each step `i`, we subtract `i` from the previous number\n* If the result is not negative, and not yet present in the sequence, it becomes the `i`th element of the sequence\n* Otherwise the `i`th element of the sequence will be previous number plus `i`\n\nThe beginning of the sequence is `[0, 1, 3, 6, 2, ...]` because:  \n0) `0` <- we start with `0`  \n1) `1` <- `0 - 1` is negative, hence we choose `0 + 1`  \n2) `3` <- `1 - 2` is negative, hence we choose `1 + 2`  \n3) `6` <-`3 - 3` is not negative, but we already have a `0` in the sequence, hence we choose `3 + 3`  \n4) `2` <- `6 - 4` is positive, and is not present in the sequence yet, so we go for it\n\nExamples:\nrec(0) == 0\nrec(1) == 0\nrec(2) == 1\nrec(3) == 4\nrec(4) == 10\nrec(5) == 12\n\"\"\"\ndef rec(x):",
    "19": "Python 3\n\"\"\"\n## Task\n\nFind the sum of the first `n` elements in the Recam\u00e1n Sequence.\n\nInput range:\n\n```python\n1000 tests\n0 <= n <= 2,500,000\n```\n\n___\n\n## Sequence\n\nThe sequence is formed using the next formula:\n* We start with `0`\n* At each step `i`, we subtract `i` from the previous number\n* If the result is not negative, and not yet present in the sequence, it becomes the `i`th element of the sequence\n* Otherwise the `i`th element of the sequence will be previous number plus `i`\n\nThe beginning of the sequence is `[0, 1, 3, 6, 2, ...]` because:  \n0) `0` <- we start with `0`  \n1) `1` <- `0 - 1` is negative, hence we choose `0 + 1`  \n2) `3` <- `1 - 2` is negative, hence we choose `1 + 2`  \n3) `6` <-`3 - 3` is not negative, but we already have a `0` in the sequence, hence we choose `3 + 3`  \n4) `2` <- `6 - 4` is positive, and is not present in the sequence yet, so we go for it\n\n___\n\n## Examples\n\n```\nrec(0) == 0\nrec(1) == 0\nrec(2) == 1\nrec(3) == 4\nrec(4) == 10\nrec(5) == 12\n```\n\"\"\"\ndef rec(x):"
}