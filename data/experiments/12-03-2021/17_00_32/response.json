{
    "id": "cmpl-4BClFihodt3DRtNayanMrGy8D24nC",
    "object": "text_completion",
    "created": 1638576009,
    "model": "davinci-codex:2021-08-03",
    "choices": [
        {
            "text": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if n == 1:\n        print(0)\n    else:\n        if a[0] == a[-1]:\n            print(0)\n        else:\n            print(n)\n\ncode()",
            "index": 0,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] == a[i+1]:\n            ans += 1\n    print(ans)\n\ncode()",
            "index": 1,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if type(position) != str:\n        return []\n    if len(position) != 2:\n        return []\n    if position[0] not in 'ABCDEFGH' or position[1] not in '12345678':\n        return []\n    x = 'ABCDEFGH'.index(position[0])\n    y = '12345678'.index(position[1])\n    moves = []\n    for i in range(1, 9):\n        if x + i <= 7:\n            moves.append(f'{position[0]}{int(position[1]) + i}')\n        if x - i >= 0:\n            moves.append(f'{position[0]}{int(position[1]) - i}')\n        if y + i <= 7:\n            moves.append(f'{chr(ord(position[0]) + i)}{position[1]}')\n        if y - i >= 0:\n            moves.append(f'{chr(ord(position[0]) - i)}{position[1]}')\n        if x + i <= 7 and y + i <= 7:\n            moves.append(f'{chr(ord(position[0]) + i)}{int(position[1]) + i}')\n        if x - i >= 0 and y - i >= 0:\n            moves.append(f'{chr(ord(position[0]) - i)}{int(position[1]) - i}')\n        if x + i <= 7 and y - i >= 0:\n            moves.append(f'{chr(ord(position[0]) + i)}{int(position[1]) - i}')\n        if x - i >= 0 and y + i <= 7:\n            moves.append(f'{chr(ord(position[0]) - i)}{int(position[1]) + i}')\n    return sorted(moves)",
            "index": 2,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if type(position) != str:\n        return []\n    if len(position) != 2:\n        return []\n    if position[0] not in 'ABCDEFGH' or position[1] not in '12345678':\n        return []\n    x = 'ABCDEFGH'.index(position[0])\n    y = '12345678'.index(position[1])\n    moves = []\n    for i in range(1, 9):\n        moves.append(f'{chr(ord(position[0]) + i)}{position[1]}')\n        moves.append(f'{chr(ord(position[0]) - i)}{position[1]}')\n        moves.append(f'{position[0]}{str(int(position[1]) + i)}')\n        moves.append(f'{position[0]}{str(int(position[1]) - i)}')\n        moves.append(f'{chr(ord(position[0]) + i)}{str(int(position[1]) + i)}')\n        moves.append(f'{chr(ord(position[0]) - i)}{str(int(position[1]) + i)}')\n        moves.append(f'{chr(ord(position[0]) + i)}{str(int(position[1]) - i)}')\n        moves.append(f'{chr(ord(position[0]) - i)}{str(int(position[1]) - i)}')\n    moves = [x for x in moves if x[0] in 'ABCDEFGH' and x[1] in '12345678']\n    return sorted(moves)",
            "index": 3,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    graph = [[] for i in range(n+1)]\n    for i in range(n-1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    init = list(map(int, input().split()))\n    goal = list(map(int, input().split()))\n    cnt = 0\n    for i in range(1, n+1):\n        if init[i-1] != goal[i-1]:\n            cnt += 1\n            for j in graph[i]:\n                init[j-1] = 1 - init[j-1]\n    print(cnt)\n    for i in range(1, n+1):\n        if init[i-1] != goal[i-1]:\n            print(i)\n\nif __name__ == '__main__':\n    code()",
            "index": 4,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    graph = [[] for i in range(n+1)]\n    for i in range(n-1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    init = list(map(int, input().split()))\n    goal = list(map(int, input().split()))\n    cnt = 0\n    for i in range(1, n+1):\n        if init[i-1] != goal[i-1]:\n            cnt += 1\n            for j in graph[i]:\n                if init[j-1] == goal[i-1]:\n                    init[j-1] = 1 - init[j-1]\n                    break\n    print(cnt)\n    for i in range(1, n+1):\n        if init[i-1] != goal[i-1]:\n            print(i)\n\nif __name__ == '__main__':\n    code()",
            "index": 5,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    watchmen = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        watchmen.append((x, y))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(watchmen[i][0] - watchmen[j][0]) + abs(watchmen[i][1] - watchmen[j][1]) == \\\n                    ((watchmen[i][0] - watchmen[j][0]) ** 2 + (watchmen[i][1] - watchmen[j][1]) ** 2) ** 0.5:\n                count += 1\n    print(count)\n\nif __name__ == '__main__':\n    code()",
            "index": 6,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    watchmen = []\n    for i in range(n):\n        watchmen.append(list(map(int, input().split())))\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(watchmen[i][0] - watchmen[j][0]) + abs(watchmen[i][1] - watchmen[j][1]) == \\\n                    ((watchmen[i][0] - watchmen[j][0]) ** 2 + (watchmen[i][1] - watchmen[j][1]) ** 2) ** 0.5:\n                count += 1\n    print(count)\n\ncode()",
            "index": 7,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    rabbits = (legs - (2 * heads)) / 4\n    chickens = heads - rabbits\n    cows = horns - heads\n    return {\"rabbits\" : int(rabbits), \"chickens\" : int(chickens), \"cows\" : int(cows)}",
            "index": 8,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if legs % 2 != 0 or heads < 1 or horns < 0:\n        return None\n    rabbits = (legs - (2 * heads + horns)) / 2\n    chickens = heads - rabbits - horns / 2\n    cows = horns / 2\n    return {\"rabbits\": int(rabbits), \"chickens\": int(chickens), \"cows\": int(cows)}",
            "index": 9,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not root:\n            return []\n        res = []\n        queue = [root]\n        level = 0\n        while queue:\n            level += 1\n            res.append([])\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                res[-1].append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                res[-1] = res[-1][::-1]\n        return res",
            "index": 10,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not root:\n            return []\n        res = []\n        queue = [root]\n        level = 0\n        while queue:\n            level += 1\n            res.append([])\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                res[-1].append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                res[-1] = res[-1][::-1]\n        return res",
            "index": 11,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not root:\n            return 0\n        q = [root]\n        while q:\n            temp = []\n            for node in q:\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            if not temp:\n                return sum([node.val for node in q])\n            q = temp",
            "index": 12,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not root:\n            return 0\n        q = [root]\n        while q:\n            temp = []\n            for node in q:\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            if not temp:\n                return sum([node.val for node in q])\n            q = temp",
            "index": 13,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    points = []\n    for i in range(n):\n        points.append(list(map(int, input().split())))\n    good_points = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if points[i][0] == points[j][0] and points[i][1] == points[j][1] and points[i][2] == points[j][2] and points[i][3] == points[j][3] and points[i][4] == points[j][4]:\n                continue\n            else:\n                if (points[i][0]*points[j][0] + points[i][1]*points[j][1] + points[i][2]*points[j][2] + points[i][3]*points[j][3] + points[i][4]*points[j][4]) == 0:\n                    continue\n                else:\n                    if (points[i][0]*points[j][0] + points[i][1]*points[j][1] + points[i][2]*points[j][2] + points[i][3]*points[j][3] + points[i][4]*points[j][4]) > 0:\n                        if (points[i][0]**2 + points[i][1]**2 + points[i][2]**2 + points[i][3]**2 + points[i][4]**2) == (points[j][0]**2 + points[j][1]**2 + points[j][2]**2 + points[j][3]**2 + points[j][4]**2):\n                            continue\n                        else:\n                            if (points[i][0]**2 + points[i][1]**2 + points[i][2]**2 + points[i][3]**2 + points[i][4]**2) < (points[j][0]**2 + points[j][1]**2 + points[j][2]**2 + points[j][3]**2 + points[j][4]**2):\n                                good_points.append(i+1)\n                            else:\n                                good_points.append(j+1)\n                    else:\n                        if (points[i][0]**2 + points[i][1]**2 + points[i][2]**2 + points[i][3]**2 + points[i][4]**2) == (points[j][0]**2 + points[j][1]**2 + points[j][2]**2 + points[j][3]**2 + points[j][4]**2):\n                            continue\n                        else:\n                            if (points[i][0]**2 + points[i][1]**2 + points[i][2]**2 + points[i][3]**2 + points[i][4]**2) > (points[j][0]**2 + points[j][1]**2 + points[j][2]**2 + points[j][3]**2 + points[j][4]**2):\n                                good_points.append(i+1)\n                            else:\n                                good_points.append(j+1)\n    print(len(good_points))\n    for i in range(len(good_points)):\n        print(good_points[i])\n\nif __name__ == '__main__':\n    code()",
            "index": 14,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    points = []\n    for i in range(n):\n        points.append(list(map(int, input().split())))\n    good = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    for m in range(l+1, n):\n                        if (points[i][0] * (points[j][1] * points[k][2] * points[l][3] * points[m][4] - points[j][1] * points[k][2] * points[l][4] * points[m][3] - points[j][1] * points[k][3] * points[l][2] * points[m][4] + points[j][1] * points[k][3] * points[l][4] * points[m][2] + points[j][1] * points[k][4] * points[l][2] * points[m][3] - points[j][1] * points[k][4] * points[l][3] * points[m][2] - points[j][2] * points[k][1] * points[l][3] * points[m][4] + points[j][2] * points[k][1] * points[l][4] * points[m][3] + points[j][2] * points[k][3] * points[l][1] * points[m][4] - points[j][2] * points[k][3] * points[l][4] * points[m][1] - points[j][2] * points[k][4] * points[l][1] * points[m][3] + points[j][2] * points[k][4] * points[l][3] * points[m][1] + points[j][3] * points[k][1] * points[l][2] * points[m][4] - points[j][3] * points[k][1] * points[l][4] * points[m][2] - points[j][3] * points[k][2] * points[l][1] * points[m][4] + points[j][3] * points[k][2] * points[l][4] * points[m][1] + points[j][3] * points[k][4] * points[l][1] * points[m][2] - points[j][3] * points[k][4] * points[l][2] * points[m][1] - points[j][4] * points[k][1] * points[l][2] * points[m][3] + points[j][4] * points[k][1] * points[l][3] * points[m][2] + points[j][4] * points[k][2] * points[l][1] * points[m][3] - points[j][4] * points[k][2] * points[l][3] * points[m][1] - points[j][4] * points[k][3] * points[l][1] * points[m][2] + points[j][4] * points[k][3] * points[l][2] * points[m][1]) == 0):\n                            good.append(i+1)\n                            break\n    print(len(good))\n    for i in good:\n        print(i)\n\ncode()",
            "index": 15,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    N = int(input())\n    bag = []\n    for i in range(N):\n        bag.append(list(map(int, input().split())))\n    bag.sort()\n    R_max = 0\n    R_min = 0\n    B_max = 0\n    B_min = 0\n    for i in range(N):\n        if bag[i][0] > R_max:\n            R_max = bag[i][0]\n        if bag[i][0] < R_min:\n            R_min = bag[i][0]\n        if bag[i][1] > B_max:\n            B_max = bag[i][1]\n        if bag[i][1] < B_min:\n            B_min = bag[i][1]\n    print(R_max - R_min)\n    print(B_max - B_min)\n    print((R_max - R_min) * (B_max - B_min))\n\nif __name__ == \"__main__\":\n    code()",
            "index": 16,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    #Create variables\n    N = int(input())\n    x = []\n    y = []\n    for i in range(N):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n    #Sort the lists\n    x.sort()\n    y.sort()\n    #Calculate the minimum product\n    min_prod = (x[-1] - x[0]) * (y[-1] - y[0])\n    print(min_prod)\n\nif __name__ == \"__main__\":\n    code()",
            "index": 17,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 != 0 and is_prime(i) == False:\n            count += 1\n    return count\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\nprint(odd_not_prime(5))\nprint(odd_not_prime(10))",
            "index": 18,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 != 0 and not is_prime(i):\n            count += 1\n    return count\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\nprint(odd_not_prime(5))\nprint(odd_not_prime(10))",
            "index": 19,
            "logprobs": null,
            "finish_reason": "stop"
        }
    ]
}