{
    "0": "Python 3\n\"\"\"\nYou are given a sequence of n integers a_1, a_2, ..., a_{n}. \n\nDetermine a real number x such that the weakness of the sequence a_1 - x, a_2 - x, ..., a_{n} - x is as small as possible.\n\nThe weakness of a sequence is defined as the maximum value of the poorness over all segments of a sequence.\n\nThe poorness of a segment is defined as the absolute value of sum of the elements of segment.\n\n\n-----Input-----\n\nThe first line contains one integer n (1 \u2264 n \u2264 200 000), the length of a sequence.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (|a_{i}| \u2264 10 000).\n\n\n-----Output-----\n\nOutput a real number denoting the minimum possible weakness of a_1 - x, a_2 - x, ..., a_{n} - x. Your answer will be considered correct if its relative or absolute error doesn't exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n1.000000000000000\n\nInput\n4\n1 2 3 4\n\nOutput\n2.000000000000000\n\nInput\n10\n1 10 2 9 3 8 4 7 5 6\n\nOutput\n4.500000000000000\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nYou are given a sequence of n integers a_1, a_2, ..., a_{n}. \n\nDetermine a real number x such that the weakness of the sequence a_1 - x, a_2 - x, ..., a_{n} - x is as small as possible.\n\nThe weakness of a sequence is defined as the maximum value of the poorness over all segments (contiguous subsequences) of a sequence.\n\nThe poorness of a segment is defined as the absolute value of sum of the elements of segment.\n\n\n-----Input-----\n\nThe first line contains one integer n (1 \u2264 n \u2264 200 000), the length of a sequence.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (|a_{i}| \u2264 10 000).\n\n\n-----Output-----\n\nOutput a real number denoting the minimum possible weakness of a_1 - x, a_2 - x, ..., a_{n} - x. Your answer will be considered correct if its relative or absolute error doesn't exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n1.000000000000000\n\nInput\n4\n1 2 3 4\n\nOutput\n2.000000000000000\n\nInput\n10\n1 10 2 9 3 8 4 7 5 6\n\nOutput\n4.500000000000000\n\n\n\n-----Note-----\n\nFor the first case, the optimal value of x is 2 so the sequence becomes  - 1, 0, 1 and the max poorness occurs at the segment \"-1\" or segment \"1\". The poorness value (answer) equals to 1 in this case. \n\nFor the second sample the optimal value of x is 2.5 so the sequence becomes  - 1.5,  - 0.5, 0.5, 1.5 and the max poorness occurs on segment \"-1.5 -0.5\" or \"0.5 1.5\". The poorness value (answer) equals to 2 in this case.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nLet's define the following recurrence: $$a_{n+1} = a_{n} + minDigit(a_{n}) \\cdot maxDigit(a_{n}).$$\n\nHere $minDigit(x)$ and $maxDigit(x)$ are the minimal and maximal digits in the decimal representation of $x$ without leading zeroes. For examples refer to notes.\n\nYour task is calculate $a_{K}$ for given $a_{1}$ and $K$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of independent test cases.\n\nEach test case consists of a single line containing two integers $a_{1}$ and $K$ ($1 \\le a_{1} \\le 10^{18}$, $1 \\le K \\le 10^{16}$) separated by a space.\n\n\n-----Output-----\n\nFor each test case print one integer $a_{K}$ on a separate line.\n\n\n-----Example-----\nInput\n8\n1 4\n487 1\n487 2\n487 3\n487 4\n487 5\n487 6\n487 7\n\nOutput\n42\n487\n519\n528\n544\n564\n588\n628\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nLet's define the following recurrence: $$a_{n+1} = a_{n} + minDigit(a_{n}) \\cdot maxDigit(a_{n}).$$\n\nHere $minDigit(x)$ and $maxDigit(x)$ are the minimal and maximal digits in the decimal representation of $x$ without leading zeroes. For examples refer to notes.\n\nYour task is calculate $a_{K}$ for given $a_{1}$ and $K$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$)\u00a0\u2014 the number of independent test cases.\n\nEach test case consists of a single line containing two integers $a_{1}$ and $K$ ($1 \\le a_{1} \\le 10^{18}$, $1 \\le K \\le 10^{16}$) separated by a space.\n\n\n-----Output-----\n\nFor each test case print one integer $a_{K}$ on a separate line.\n\n\n-----Example-----\nInput\n8\n1 4\n487 1\n487 2\n487 3\n487 4\n487 5\n487 6\n487 7\n\nOutput\n42\n487\n519\n528\n544\n564\n588\n628\n\n\n\n-----Note-----\n\n$a_{1} = 487$ \n\n $a_{2} = a_{1} + minDigit(a_{1}) \\cdot maxDigit(a_{1}) = 487 + \\min (4, 8, 7) \\cdot \\max (4, 8, 7) = 487 + 4 \\cdot 8 = 519$ \n\n $a_{3} = a_{2} + minDigit(a_{2}) \\cdot maxDigit(a_{2}) = 519 + \\min (5, 1, 9) \\cdot \\max (5, 1, 9) = 519 + 1 \\cdot 9 = 528$ \n\n $a_{4} = a_{3} + minDigit(a_{3}) \\cdot maxDigit(a_{3}) = 528 + \\min (5, 2, 8) \\cdot \\max (5, 2, 8) = 528 + 2 \\cdot 8 = 544$ \n\n $a_{5} = a_{4} + minDigit(a_{4}) \\cdot maxDigit(a_{4}) = 544 + \\min (5, 4, 4) \\cdot \\max (5, 4, 4) = 544 + 4 \\cdot 5 = 564$ \n\n $a_{6} = a_{5} + minDigit(a_{5}) \\cdot maxDigit(a_{5}) = 564 + \\min (5, 6, 4) \\cdot \\max (5, 6, 4) = 564 + 4 \\cdot 6 = 588$ \n\n $a_{7} = a_{6} + minDigit(a_{6}) \\cdot maxDigit(a_{6}) = 588 + \\min (5, 8, 8) \\cdot \\max (5, 8, 8) = 588 + 5 \\cdot 8 = 628$\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nYou are given n fountains with its beauty and cost are known.There are two types of money: coins and diamonds, so each fountain cost can be either in coins or diamonds. No money changes between the types are allowed.\n\nBuild two fountains with maximum total beauty so that both can be bought at the same time.\n\n\n-----Input-----\n\nThe first line contains three integers n, c and d (2 \u2264 n \u2264 100 000, 0 \u2264 c, d \u2264 100 000)\u00a0\u2014 the number of fountains, the number of coins and diamonds.\n\nThe next n lines describe fountains. Each of these lines contain two integers b_{i} and p_{i} (1 \u2264 b_{i}, p_{i} \u2264 100 000)\u00a0\u2014 the beauty and the cost of the i-th fountain, and then a letter \"C\" or \"D\", describing in which type of money is the cost of fountain i: in coins or in diamonds, respectively.\n\n\n-----Output-----\n\nPrint the maximum total beauty of exactly two fountains that can build. If two fountains can't be built, print 0.\n\n\n-----Examples-----\nInput\n3 7 6\n10 8 C\n4 3 C\n5 6 D\n\nOutput\n9\n\nInput\n2 4 5\n2 5 C\n2 1 D\n\nOutput\n0\n\nInput\n3 10 10\n5 5 C\n5 5 C\n10 11 D\n\nOutput\n10\n\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nArkady plays Gardenscapes a lot. Arkady wants to build two new fountains. There are n available fountains, for each fountain its beauty and cost are known. There are two types of money in the game: coins and diamonds, so each fountain cost can be either in coins or diamonds. No money changes between the types are allowed.\n\nHelp Arkady to find two fountains with maximum total beauty so that he can buy both at the same time.\n\n\n-----Input-----\n\nThe first line contains three integers n, c and d (2 \u2264 n \u2264 100 000, 0 \u2264 c, d \u2264 100 000)\u00a0\u2014 the number of fountains, the number of coins and diamonds Arkady has.\n\nThe next n lines describe fountains. Each of these lines contain two integers b_{i} and p_{i} (1 \u2264 b_{i}, p_{i} \u2264 100 000)\u00a0\u2014 the beauty and the cost of the i-th fountain, and then a letter \"C\" or \"D\", describing in which type of money is the cost of fountain i: in coins or in diamonds, respectively.\n\n\n-----Output-----\n\nPrint the maximum total beauty of exactly two fountains Arkady can build. If he can't build two fountains, print 0.\n\n\n-----Examples-----\nInput\n3 7 6\n10 8 C\n4 3 C\n5 6 D\n\nOutput\n9\n\nInput\n2 4 5\n2 5 C\n2 1 D\n\nOutput\n0\n\nInput\n3 10 10\n5 5 C\n5 5 C\n10 11 D\n\nOutput\n10\n\n\n\n-----Note-----\n\nIn the first example Arkady should build the second fountain with beauty 4, which costs 3 coins. The first fountain he can't build because he don't have enough coins. Also Arkady should build the third fountain with beauty 5 which costs 6 diamonds. Thus the total beauty of built fountains is 9.\n\nIn the second example there are two fountains, but Arkady can't build both of them, because he needs 5 coins for the first fountain, and Arkady has only 4 coins.\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nWrite a function named sumDigits which takes a number as input and returns the sum of the absolute value of each of the number's decimal digits.\n\nFor example:\n\nsum_digits(10)  # Returns 1\nsum_digits(99)  # Returns 18\nsum_digits(-32) # Returns 5\n\"\"\"\ndef sum_digits(number):",
    "7": "Python 3\n\"\"\"\nWrite a function named sumDigits which takes a number as input and returns the sum of the absolute value of each of the number's decimal digits.  For example:\n\n```python\n  sum_digits(10)  # Returns 1\n  sum_digits(99)  # Returns 18\n  sum_digits(-32) # Returns 5\n```\n\nLet's assume that all numbers in the input will be integer values.\n\"\"\"\ndef sum_digits(number):",
    "8": "Python 3\n\"\"\"\nyou wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. you can only hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $n$ favorite numbers: $a_1, a_2, \\ldots, a_n$. What is the minimum number of hops you need to move from $(0,0)$ to $(x,0)$? you may land on points with non-integer coordinates. It can be proved that you can always reach his destination.\n\nRecall that the Euclidean distance between points $(x_i, y_i)$ and $(x_j, y_j)$ is $\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$.\n\nFor example, if you have favorite numbers $1$ and $3$ he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)$ $\\rightarrow$ $(2,-\\sqrt{5})$ $\\rightarrow$ $(4,0)$).\n\n $1$ Here is a graphic for the first example. Both hops have distance $3$, one of your favorite numbers. \n\nIn other words, each time you chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 1000$) \u00a0\u2014 the number of test cases. Next $2t$ lines contain test cases \u2014 two lines per test case.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5$, $1 \\le x \\le 10^9$) \u00a0\u2014 the number of favorite numbers and the distance Rabbit wants to travel, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u00a0\u2014 Rabbit's favorite numbers. It is guaranteed that the favorite numbers are distinct.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of hops needed.\n\n\n-----Example-----\nInput\n4\n2 4\n1 3\n3 12\n3 4 5\n1 5\n5\n2 10\n15 4\n\nOutput\n2\n3\n1\n2\n\n\n\n-----Note-----\n\nThe first test case of the sample is shown in the picture above. You can hop to $(2,\\sqrt{5})$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\n\nIn the second test case of the sample, one way for you to hop $3$ times is: $(0,0)$ $\\rightarrow$ $(4,0)$ $\\rightarrow$ $(8,0)$ $\\rightarrow$ $(12,0)$.\n\nIn the third test case of the sample, you can hop from $(0,0)$ to $(5,0)$.\n\nIn the fourth test case of the sample, you can hop: $(0,0)$ $\\rightarrow$ $(5,10\\sqrt{2})$ $\\rightarrow$ $(10,0)$.\n\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nBessie has way too many friends because she is everyone's favorite cow! Her new friend Rabbit is trying to hop over so they can play! \n\nMore specifically, he wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $n$ favorite numbers: $a_1, a_2, \\ldots, a_n$. What is the minimum number of hops Rabbit needs to get from $(0,0)$ to $(x,0)$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.\n\nRecall that the Euclidean distance between points $(x_i, y_i)$ and $(x_j, y_j)$ is $\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$.\n\nFor example, if Rabbit has favorite numbers $1$ and $3$ he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)$ $\\rightarrow$ $(2,-\\sqrt{5})$ $\\rightarrow$ $(4,0)$).\n\n $1$ Here is a graphic for the first example. Both hops have distance $3$, one of Rabbit's favorite numbers. \n\nIn other words, each time Rabbit chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 1000$) \u00a0\u2014 the number of test cases. Next $2t$ lines contain test cases \u2014 two lines per test case.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5$, $1 \\le x \\le 10^9$) \u00a0\u2014 the number of favorite numbers and the distance Rabbit wants to travel, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u00a0\u2014 Rabbit's favorite numbers. It is guaranteed that the favorite numbers are distinct.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of hops needed.\n\n\n-----Example-----\nInput\n4\n2 4\n1 3\n3 12\n3 4 5\n1 5\n5\n2 10\n15 4\n\nOutput\n2\n3\n1\n2\n\n\n\n-----Note-----\n\nThe first test case of the sample is shown in the picture above. Rabbit can hop to $(2,\\sqrt{5})$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\n\nIn the second test case of the sample, one way for Rabbit to hop $3$ times is: $(0,0)$ $\\rightarrow$ $(4,0)$ $\\rightarrow$ $(8,0)$ $\\rightarrow$ $(12,0)$.\n\nIn the third test case of the sample, Rabbit can hop from $(0,0)$ to $(5,0)$.\n\nIn the fourth test case of the sample, Rabbit can hop: $(0,0)$ $\\rightarrow$ $(5,10\\sqrt{2})$ $\\rightarrow$ $(10,0)$.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\n\nYou are given a sequence. You can multiply some numbers of the sequence p by -1. You want the number of inversions in the sequence to be minimum. Find the minimum number of inversions you can get.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 2000). The next line contains n integers \u2014 sequence p_1, p_2, ..., p_{n} (|p_{i}| \u2264 10^5). The numbers are separated by spaces.\n\n\n-----Output-----\n\nIn a single line print the answer to the problem \u2014 the minimum number of inversions you can get.\n\n\n-----Examples-----\nInput\n2\n2 1\n\nOutput\n0\n\nInput\n9\n-2 0 -1 0 -1 2 1 0 -1\n\nOutput\n6\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nJeff's friends know full well that the boy likes to get sequences and arrays for his birthday. Thus, Jeff got sequence p_1, p_2, ..., p_{n} for his birthday.\n\nJeff hates inversions in sequences. An inversion in sequence a_1, a_2, ..., a_{n} is a pair of indexes i, j (1 \u2264 i < j \u2264 n), such that an inequality a_{i} > a_{j} holds.\n\nJeff can multiply some numbers of the sequence p by -1. At that, he wants the number of inversions in the sequence to be minimum. Help Jeff and find the minimum number of inversions he manages to get.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 2000). The next line contains n integers \u2014 sequence p_1, p_2, ..., p_{n} (|p_{i}| \u2264 10^5). The numbers are separated by spaces.\n\n\n-----Output-----\n\nIn a single line print the answer to the problem \u2014 the minimum number of inversions Jeff can get.\n\n\n-----Examples-----\nInput\n2\n2 1\n\nOutput\n0\n\nInput\n9\n-2 0 -1 0 -1 2 1 0 -1\n\nOutput\n6\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\nThere are n watchmen on a plane, the i-th watchman is located at point (x_{i}, y_{i}).\n\nDoctor Manhattan considers the distance between watchmen i and j to be |x_{i} - x_{j}| + |y_{i} - y_{j}|. Daniel, calculates the distance using the formula $\\sqrt{(x_{i} - x_{j})^{2} +(y_{i} - y_{j})^{2}}$.\n\nCompute the number of pairs (i, j), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel.\n\n\n-----Input-----\n\nThe first line of the input contains the single integer n (1 \u2264 n \u2264 200 000)\u00a0\u2014 the number of watchmen.\n\nEach of the following n lines contains two integers x_{i} and y_{i} (|x_{i}|, |y_{i}| \u2264 10^9).\n\nSome positions may coincide.\n\n\n-----Output-----\n\nPrint the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.\n\n\n-----Examples-----\nInput\n3\n1 1\n7 5\n1 5\n\nOutput\n2\n\nInput\n6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n\nOutput\n11\n\n\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nWatchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (x_{i}, y_{i}).\n\nThey need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |x_{i} - x_{j}| + |y_{i} - y_{j}|. Daniel, as an ordinary person, calculates the distance using the formula $\\sqrt{(x_{i} - x_{j})^{2} +(y_{i} - y_{j})^{2}}$.\n\nThe success of the operation relies on the number of pairs (i, j) (1 \u2264 i < j \u2264 n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.\n\n\n-----Input-----\n\nThe first line of the input contains the single integer n (1 \u2264 n \u2264 200 000)\u00a0\u2014 the number of watchmen.\n\nEach of the following n lines contains two integers x_{i} and y_{i} (|x_{i}|, |y_{i}| \u2264 10^9).\n\nSome positions may coincide.\n\n\n-----Output-----\n\nPrint the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.\n\n\n-----Examples-----\nInput\n3\n1 1\n7 5\n1 5\n\nOutput\n2\n\nInput\n6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n\nOutput\n11\n\n\n\n-----Note-----\n\nIn the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and $\\sqrt{(1 - 7)^{2} +(1 - 5)^{2}} = 2 \\cdot \\sqrt{13}$ for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nYou are given an array $a_1, a_2 \\dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \\le i < j < k < l \\le n$;  $a_i = a_k$ and $a_j = a_l$; \n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 3000$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the array $a$.\n\nIt's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.\n\n\n-----Output-----\n\nFor each test case, print the number of described tuples.\n\n\n-----Example-----\nInput\n2\n5\n2 2 2 2 2\n6\n1 3 3 1 2 3\n\nOutput\n5\n2\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nYou are given an array $a_1, a_2 \\dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \\le i < j < k < l \\le n$;  $a_i = a_k$ and $a_j = a_l$; \n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 3000$)\u00a0\u2014 the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$)\u00a0\u2014 the array $a$.\n\nIt's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.\n\n\n-----Output-----\n\nFor each test case, print the number of described tuples.\n\n\n-----Example-----\nInput\n2\n5\n2 2 2 2 2\n6\n1 3 3 1 2 3\n\nOutput\n5\n2\n\n\n\n-----Note-----\n\nIn the first test case, for any four indices $i < j < k < l$ are valid, so the answer is the number of tuples.\n\nIn the second test case, there are $2$ valid tuples:   $(1, 2, 4, 6)$: $a_1 = a_4$ and $a_2 = a_6$;  $(1, 3, 4, 6)$: $a_1 = a_4$ and $a_3 = a_6$.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nYou are given root of a tree. Find the most frequent subtree sum value if the  subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). If there is a tie, return all the values with the highest frequency.\n\n\nExamples 1\nInput:\n\n  5\n /  \\\n2   -3\n\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\n\n\nExamples 2\nInput:\n\n  5\n /  \\\n2   -5\n\nreturn [2], since 2 happens twice, however -5 only occur once.\n\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\nclass Solution:\n    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:",
    "17": "Python 3\n\"\"\"\nGiven the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n\n\nExamples 1\nInput:\n\n  5\n /  \\\n2   -3\n\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\n\n\nExamples 2\nInput:\n\n  5\n /  \\\n2   -5\n\nreturn [2], since 2 happens twice, however -5 only occur once.\n\n\nNote:\nYou may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\nclass Solution:\n    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:",
    "18": "Python 3\n\"\"\"\nA cake is sliced with n straight lines. Your task is to calculate the maximum number of pieces the cake can have.\n\n# Example\n\n For `n = 0`, the output should be `1`.\n \n For `n = 1`, the output should be `2`.\n \n For `n = 2`, the output should be `4`.\n \n For `n = 3`, the output should be `7`.\n \n# Input/Output\n\n\n - `[input]` integer `n`\n\n  `0 \u2264 n \u2264 10000`\n\n\n - `[output]` an integer\n\n  The maximum number of pieces the sliced cake can have.\n\"\"\"\ndef cake_slice(n):",
    "19": "Python 3\n\"\"\"\n# Task\nA cake is sliced with `n` straight lines. Your task is to calculate the maximum number of pieces the cake can have.\n\n# Example\n\n For `n = 0`, the output should be `1`.\n \n For `n = 1`, the output should be `2`.\n \n For `n = 2`, the output should be `4`.\n \n For `n = 3`, the output should be `7`.\n \n See the following image to understand it:\n \n ![](https://cdn2.scratch.mit.edu/get_image/project/92275349_500x400.png?v=1450672809.79)\n\n# Input/Output\n\n\n - `[input]` integer `n`\n\n  `0 \u2264 n \u2264 10000`\n\n\n - `[output]` an integer\n\n  The maximum number of pieces the sliced cake can have.\n\"\"\"\ndef cake_slice(n):"
}