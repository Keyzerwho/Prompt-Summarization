{
    "0": "Python 3\n\"\"\"\nYou have to remove duplicates and print the length of unique characters of the given string.\n\n-----Input-----\nFirst line contains T, number of testcases. Each testcase consists of a single string in one line. Each character of the string will be a small alphabet(ie. 'a' to 'z').\n\n-----Output-----\nFor each testcase, print the required answer in one line.\n\n-----Constraints-----\n- 1 \u2264 T \u2264 10\n- Subtask 1 (20 points):1 \u2264 N \u2264 10\n- Subtask 2 (80 points):1 \u2264 N \u2264 105\n\n-----Example-----\nInput:\n2\nabc\naba\n\nOutput:\n3\n2\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nYou have initially a string of N characters, denoted by A1,A2...AN. You have to print the size of the largest subsequence of string A such that all the characters in that subsequence are distinct ie. no two characters in that subsequence should be same.\n\nA subsequence of string A is a sequence that can be derived from A by deleting some elements  and without changing the order of the remaining elements.\n\n-----Input-----\nFirst line contains T, number of testcases. Each testcase consists of a single string in one line. Each character of the string will be a small alphabet(ie. 'a' to 'z').\n\n-----Output-----\nFor each testcase, print the required answer in one line.\n\n-----Constraints-----\n- 1 \u2264 T \u2264 10\n- Subtask 1 (20 points):1 \u2264 N \u2264 10\n- Subtask 2 (80 points):1 \u2264 N \u2264 105\n\n-----Example-----\nInput:\n2\nabc\naba\n\nOutput:\n3\n2\n\n-----Explanation-----\nFor first testcase, the whole string is a subsequence which has all distinct characters.\n\nIn second testcase, the we can delete last or first 'a' to get the required subsequence.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nCreate a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened.\n\nExamples:\nInput:\nfouriest(42)\nOutput:\n\"30 is the fouriest(42) in base 7\"\n\nInput:\nfouriest(14)\nOutput:\n\"15 is the fouriest(14) in base 11\"\n\"\"\"\ndef fouriest(i):",
    "3": "Python 3\n\"\"\"\n# Fourier transformations are hard. Fouriest transformations are harder.\n\nThis Kata is based on the SMBC Comic on fourier transformations.\n\nA fourier transformation on a number is one that converts the number to a base in which it has more `4`s ( `10` in base `6` is `14`, which has `1` four as opposed to none, hence, fourier in base `6` ).\n\nA number's fouriest transformation converts it to the base in which it has the most `4`s.  \nFor example: `35353` is the fouriest in base `6`: `431401`.\n\nThis kata requires you to create a method `fouriest` that takes a number and makes it the fouriest, telling us in which base this happened, as follows:\n\n```python\nfouriest(number) -> \"{number} is the fouriest ({fouriest_representation}) in base {base}\"\n```\n\n## Important notes\n\n* For this kata we don't care about digits greater than `9` ( only `0` to `9` ), so we will represent all digits greater than `9` as `'x'`: `10` in base `11` is `'x'`, `119` in base `20` is `'5x'`, `118` in base `20` is also `'5x'`\n\n* When a number has several fouriest representations, we want the one with the LOWEST base\n\n```if:haskell,javascript\n* Numbers below `9` will not be tested\n```\n\n```if:javascript\n* A `BigNumber` library has been provided; documentation is [here](https://mikemcl.github.io/bignumber.js/)\n```\n\n## Examples\n\n```python\n\"30 is the fouriest (42) in base 7\"\n\"15 is the fouriest (14) in base 11\"\n```\n\"\"\"\ndef fouriest(i):",
    "4": "Python 3\n\"\"\"\nYou are given n cards with numbers. The i-th card has the number a_{i} written on it. You have to put cards in a row to get one greater number.\n\nThere are n! ways to put his cards in a row. The resulting big number is divisible by eleven.\n\nFind out how many  ways are there to put the cards.\n\nConsiders all cards different, even if some of them contain the same number. \n\n\n-----Input-----\n\nThe first line of the input data contains an integer t\u00a0\u2014 the number of test cases (1 \u2264 t \u2264 100). \nEach test is described by two lines.\n\nThe first line contains an integer n (1 \u2264 n \u2264 2000)\u00a0\u2014 the number of cards.\n\nThe second line contains n integers a_{i} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 numbers written on the cards.\n\nThe total number of cards in all tests of one input data doesn't exceed 2000.\n\n\n-----Output-----\n\nFor each test case output one line: the number of ways to put the cards to the table. so that the resulting big number was divisible by 11, print the number modulo 998244353.\n\n\n-----Example-----\nInput\n4\n2\n1 1\n3\n1 31 12\n3\n12345 67 84\n9\n1 2 3 4 5 6 7 8 9\n\nOutput\n2\n2\n2\n31680\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nIt is Borya's eleventh birthday, and he has got a great present: n cards with numbers. The i-th card has the number a_{i} written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers 1, 31, and 12, and he puts them in a row in this order, he would get a number 13112.\n\nHe is only 11, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because 13112 = 1192 \u00d7 11, but if he puts the cards in the following order: 31, 1, 12, he would get a number 31112, it is not divisible by 11, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there.\n\nBorya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways.\n\nHelp Borya, find the number of good ways to put the cards. This number can be large, so output it modulo 998244353.\n\n\n-----Input-----\n\nInput data contains multiple test cases. The first line of the input data contains an integer t\u00a0\u2014 the number of test cases (1 \u2264 t \u2264 100). The descriptions of test cases follow.\n\nEach test is described by two lines.\n\nThe first line contains an integer n (1 \u2264 n \u2264 2000)\u00a0\u2014 the number of cards in Borya's present.\n\nThe second line contains n integers a_{i} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 numbers written on the cards.\n\nIt is guaranteed that the total number of cards in all tests of one input data doesn't exceed 2000.\n\n\n-----Output-----\n\nFor each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by 11, print the number modulo 998244353.\n\n\n-----Example-----\nInput\n4\n2\n1 1\n3\n1 31 12\n3\n12345 67 84\n9\n1 2 3 4 5 6 7 8 9\n\nOutput\n2\n2\n2\n31680\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nCreate a function with two arguments that will return an array of the first n multiples of x. Assume both the given number and the number of times to count will be positive numbers greater than 0. \n\nExamples:\nInput:\ncount_by(1,10)\nOutput:\n[1,2,3,4,5,6,7,8,9,10]\n\nInput:\ncount_by(2,5)\nOutput:\n[2,4,6,8,10]\n\n\"\"\"\ndef count_by(x, n):",
    "7": "Python 3\n\"\"\"\nCreate a function with two arguments that will return an array of the first (n) multiples of (x). \n\nAssume both the given number and the number of times to count will be positive numbers greater than 0. \n\nReturn the results as an array (or list in Python, Haskell or Elixir).\n\nExamples:\n\n```python\ncount_by(1,10) #should return [1,2,3,4,5,6,7,8,9,10]\ncount_by(2,5) #should return [2,4,6,8,10]\n```\n\"\"\"\ndef count_by(x, n):",
    "8": "Python 3\n\"\"\"\nGiven an array of integers, return an array, where the first element is the count of positives numbers and the second element is sum of negative numbers. If the input array is empty or null, return an empty array.\n\nExamples:\nInput:\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15]\nOutput:\n[10, -65]\n\"\"\"\ndef count_positives_sum_negatives(arr):",
    "9": "Python 3\n\"\"\"\nGiven an array of integers.\n\nReturn an array, where the first element is the count of positives numbers and the second element is sum of negative numbers.\n\nIf the input array is empty or null, return an empty array.\n\n# Example\n\nFor input `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15]`, you should return `[10, -65]`.\n\"\"\"\ndef count_positives_sum_negatives(arr):",
    "10": "Python 3\n\"\"\"\nReverse a linked list from position m to n.\n\nNote:\u00a01 \u2264 m \u2264 n \u2264 length of list.\n\nExample:\n\n\nInput: 1->2->3->4->5->NULL, m = 2, n = 4\nOutput: 1->4->3->2->5->NULL\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n    self.val = val\n    self.next = next\nclass Solution:\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:",
    "11": "Python 3\n\"\"\"\nReverse a linked list from position m to n. Do it in one-pass.\n\nNote:\u00a01 \u2264 m \u2264 n \u2264 length of list.\n\nExample:\n\n\nInput: 1->2->3->4->5->NULL, m = 2, n = 4\nOutput: 1->4->3->2->5->NULL\n\"\"\"\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n    self.val = val\n    self.next = next\nclass Solution:\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:",
    "12": "Python 3\n\"\"\"\nGiven starting number and the ending number, creates a dictionary of factors for all numbers.\n\nIf a number possesses no factors , the list for the key should be `['None']`\n\nFor example: All factors for 2 (`n`) through to 6 (`m`) with the number being the key in the dictionary:\n\n```python\n{2: ['None'], 3: ['None'], 4: [2], 5: ['None'], 6: [2, 3]}\n```\n\"\"\"\ndef factorsRange(n, m):",
    "13": "Python 3\n\"\"\"\nThe objective of this Kata is to write a function that creates a dictionary of factors for a range of numbers.\n\nThe key for each list in the dictionary should be the number. The list associated with each key should possess the factors for the number.\n\nIf a number possesses no factors (only 1 and the number itself), the list for the key should be `['None']`\n\nThe function possesses two arguments (`n` and `m`). Where `n` is the starting number and `m` is the ending number.\n\nFor example: All factors for 2 (`n`) through to 6 (`m`) with the number being the key in the dictionary:\n\n```python\n{2: ['None'], 3: ['None'], 4: [2], 5: ['None'], 6: [2, 3]}\n```\n\"\"\"\ndef factorsRange(n, m):",
    "14": "Python 3\n\"\"\"\nYou've got array A, consisting of n integers and a positive integer k.\n\nYou need to permute the array elements so that value $\\sum_{i = 1}^{n - k}|A [ i ] - A [ i + k ]|$ became as minimal as possible. It is not allowed to change order of elements at all.\n\n\n-----Input-----\n\nThe first line contains two integers n, k (2 \u2264 n \u2264 3\u00b710^5, 1 \u2264 k \u2264 min(5000, n - 1)). \n\nThe second line contains n integers A[1], A[2], ..., A[n] ( - 10^9 \u2264 A[i] \u2264 10^9), separate by spaces \u2014 elements of the array A.\n\n\n-----Output-----\n\nPrint the minimum possible value of the sum described in the statement.\n\n\n-----Examples-----\nInput\n3 2\n1 2 4\n\nOutput\n1\n\nInput\n5 2\n3 -5 3 -5 3\n\nOutput\n0\n\nInput\n6 3\n4 3 4 3 2 5\n\nOutput\n3\n\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nYou've got array A, consisting of n integers and a positive integer k. Array A is indexed by integers from 1 to n.\n\nYou need to permute the array elements so that value $\\sum_{i = 1}^{n - k}|A [ i ] - A [ i + k ]|$ became minimal possible. In particular, it is allowed not to change order of elements at all.\n\n\n-----Input-----\n\nThe first line contains two integers n, k (2 \u2264 n \u2264 3\u00b710^5, 1 \u2264 k \u2264 min(5000, n - 1)). \n\nThe second line contains n integers A[1], A[2], ..., A[n] ( - 10^9 \u2264 A[i] \u2264 10^9), separate by spaces \u2014 elements of the array A.\n\n\n-----Output-----\n\nPrint the minimum possible value of the sum described in the statement.\n\n\n-----Examples-----\nInput\n3 2\n1 2 4\n\nOutput\n1\n\nInput\n5 2\n3 -5 3 -5 3\n\nOutput\n0\n\nInput\n6 3\n4 3 4 3 2 5\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first test one of the optimal permutations is 1\u00a04\u00a02. \n\nIn the second test the initial order is optimal. \n\nIn the third test one of the optimal permutations is 2\u00a03\u00a04\u00a04\u00a03\u00a05.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nYou're given a tree with n vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to v_{i}. In one move you can apply the following operation:  Select the subtree of the given tree that includes the vertex with number 1.  Increase or decrease by one all the integers which are written on the vertices of that subtree. \n\nCalculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero.\n\n\n-----Input-----\n\nThe first line of the input contains n (1 \u2264 n \u2264 10^5). Each of the next n - 1 lines contains two integers a_{i} and b_{i} (1 \u2264 a_{i}, b_{i} \u2264 n;\u00a0a_{i} \u2260 b_{i}) indicating there's an edge between vertices a_{i} and b_{i}. It's guaranteed that the input graph is a tree. \n\nThe last line of the input contains a list of n space-separated integers v_1, v_2, ..., v_{n} (|v_{i}| \u2264 10^9).\n\n\n-----Output-----\n\nPrint the minimum number of operations needed to solve the task.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n1 2\n1 3\n1 -1 1\n\nOutput\n3\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nA tree is a graph with n vertices and exactly n - 1 edges; this graph should meet the following condition: there exists exactly one shortest (by number of edges) path between any pair of its vertices.\n\nA subtree of a tree T is a tree with both vertices and edges as subsets of vertices and edges of T.\n\nYou're given a tree with n vertices. Consider its vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to v_{i}. In one move you can apply the following operation:  Select the subtree of the given tree that includes the vertex with number 1.  Increase (or decrease) by one all the integers which are written on the vertices of that subtree. \n\nCalculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero.\n\n\n-----Input-----\n\nThe first line of the input contains n (1 \u2264 n \u2264 10^5). Each of the next n - 1 lines contains two integers a_{i} and b_{i} (1 \u2264 a_{i}, b_{i} \u2264 n;\u00a0a_{i} \u2260 b_{i}) indicating there's an edge between vertices a_{i} and b_{i}. It's guaranteed that the input graph is a tree. \n\nThe last line of the input contains a list of n space-separated integers v_1, v_2, ..., v_{n} (|v_{i}| \u2264 10^9).\n\n\n-----Output-----\n\nPrint the minimum number of operations needed to solve the task.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n1 2\n1 3\n1 -1 1\n\nOutput\n3\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nFind maximum possible value of A[i]%A[j] where 1<=i,j<=N for a given array A of size N containing positive numbers. \n\n-----Input-----\nThe first line of each test case contains a single integer N denoting the size of the array. The next N lines contains integers A1, A2, ..., AN denoting the numbers\n\n-----Output-----\nOutput a single integer answering what is asked in the problem.\n\n-----Subtask 1 (20 points)-----\n- 1 \u2264 N \u2264 5000\n- 1 \u2264 A[i] \u2264 2*(10^9)\n\n-----Subtask 2 (80 points)-----\n- 1 \u2264 N \u2264 1000000\n- 1 \u2264 A[i] \u2264 2*(10^9)\n\n-----Example-----\nInput:\n2\n1\n2\n\nOutput:\n1\n\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nYou have an array A of size N containing only positive numbers. You have to output the maximum possible value of A[i]%A[j] where 1<=i,j<=N. \n\n-----Input-----\nThe first line of each test case contains a single integer N denoting the size of the array. The next N lines contains integers A1, A2, ..., AN denoting the numbers\n\n-----Output-----\nOutput a single integer answering what is asked in the problem.\n\n-----Subtask 1 (20 points)-----\n- 1 \u2264 N \u2264 5000\n- 1 \u2264 A[i] \u2264 2*(10^9)\n\n-----Subtask 2 (80 points)-----\n- 1 \u2264 N \u2264 1000000\n- 1 \u2264 A[i] \u2264 2*(10^9)\n\n-----Example-----\nInput:\n2\n1\n2\n\nOutput:\n1\n\n-----Explanation-----\nThere will be four values, A[0]%A[0] = 0, A[0]%A[1]=1, A[1]%A[0]=0, A[1]%A[1]=0, and hence the output will be the maximum among them all, that is 1.\n\"\"\"\ndef code():"
}