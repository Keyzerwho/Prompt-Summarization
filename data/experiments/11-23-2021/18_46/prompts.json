{
    "0": "Python 3\n\"\"\"\n  Arrange  is a planetary popular Flash game. In  Arrange  the player is given a permutation of numbers $1$ to $N$ and a list of allowed swaps. He then has to perform a sequence of swaps that transforms the initial permutation back to the ordered sequence $1,2,3,4,5, \\ldots , N$. In order to break the high score list, you need to perform the minimum amount of swaps possible. You can t do that, but you can write a program that does it for you! \n-----Input----- The first line of input contains two integers, $N$ ($2 \\le N \\le 11$), the length of the initial sequence and $M$ ($1 \\le M \\le N(N \u2013 1) / 2$), the number of allowed swaps. The second line of input contains a permutation of the numbers $1$ to $N$. The next $M$ lines contain descriptions of allowed swaps. Each such line contains two distinct numbers $1 \\le A < B \\le N$, indicating that you are allowed to swap the $A$-th number in the sequence with the $B$-th number. The input never contains two identical swaps. You may assume that the input is such that a solution exists. -----Output----- Output the minimum possible number of swaps to transform the permutation to $1, 2, \\ldots , N$. -----Examples----- Sample Input 1: 2 1 2 1 1 2 Sample Output 1: 1 Sample Input 2: 3 2 2 1 3 1 3 2 3 Sample Output 2: 3\n\"\"\"\ndef code():\n\n\"\"\"\n You are given $N$ and $M$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$,\n-----Input----- The first line of input contains two integers $N$ and $M$, where $2 \\leq N \\leq 10^5$ and $N - 1 \\leq M \\leq 2 \\cdot 10^5$, the number of stations and the number of tunnels, respectively. Each of the next $M$ lines contains the values $a_ i$, $b_ i$, $l_ i$ and $c_ i$. The integers $a_ i$ and $b_ i$, with $1 \\leq a_ i, b_ i \\leq N$ and $a_ i\\neq b_ i$, denote the two stations connected by the $i$th tunnel. The value $l_ i$ is either an integer satisfying $1 \\leq l_ i \\leq 10^9$, the length of the $i$th tunnel if it is known, or a question mark \u201c?\u201d. Finally, $c_ i$ is $1$ if the $i$th tunnel contains a cable, and $0$ if not. It is guaranteed that there is at most one tunnel connecting the same pair of stations, and that it is possible to travel between any pair of stations using the subway. It is also guaranteed that there exists a path between any station and station number $1$ using only tunnels where $c_ i = 1$. -----Output----- For each tunnel with $l_ i=\\texttt{?}$, output one line with a single integer, the minimum possible length for that tunnel. Tunnel lengths should be output in the same order as the tunnels are listed in the input. -----Sample Description----- In the first sample case, the minimal distance for the unknown tunnel (between stations $3$ and $1$) is $5$. This is because, if the length were less than $5$, it would be more efficient for Sk\u00e5netrafiken to run cables through the second and third tunnels. -----Examples----- Sample Input: 3 3 1 2 5 1 2 3 3 1 3 1 ? 0 Sample Output: 5\n\"\"\"\ndef code():\"\"\"\n \n-----Input-----  - One line containing a single integer $1\\leq n\\leq 3\\cdot 10^5$.  - One line consisting of $n$ tokens, each being either (, ), or an integer $0\\leq x < 10^9+7$. It is guaranteed that the tokens form a bracket sequence. -----Output----- Output the value of the given bracket sequence. Since this may be very large, you should print it modulo $10^9+7$. -----Examples----- Sample Input 1: 2 2 3 Sample Output 1: 5 Sample Input 2: 8 ( 2 ( 2 1 ) ) 3 Sample Output 2: 9 Sample Input 3: 4 ( 12 3 ) Sample Output 3: 36 Sample Input 4: 6 ( 2 ) ( 3 ) Sample Output 4: 5 Sample Input 5: 6 ( ( 2 3 ) ) Sample Output 5: 5\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\n  Arrange  is a planetary popular Flash game. In  Arrange  the player is given a permutation of numbers $1$ to $N$ and a list of allowed swaps. He then has to perform a sequence of swaps that transforms the initial permutation back to the ordered sequence $1,2,3,4,5, \\ldots , N$. In order to break the high score list, you need to perform the minimum amount of swaps possible. You can t do that, but you can write a program that does it for you! \n-----Input----- The first line of input contains two integers, $N$ ($2 \\le N \\le 11$), the length of the initial sequence and $M$ ($1 \\le M \\le N(N \u2013 1) / 2$), the number of allowed swaps. The second line of input contains a permutation of the numbers $1$ to $N$. The next $M$ lines contain descriptions of allowed swaps. Each such line contains two distinct numbers $1 \\le A < B \\le N$, indicating that you are allowed to swap the $A$-th number in the sequence with the $B$-th number. The input never contains two identical swaps. You may assume that the input is such that a solution exists. -----Output----- Output the minimum possible number of swaps to transform the permutation to $1, 2, \\ldots , N$. -----Examples----- Sample Input 1: 2 1 2 1 1 2 Sample Output 1: 1 Sample Input 2: 3 2 2 1 3 1 3 2 3 Sample Output 2: 3\n\"\"\"\ndef code():\n\n\"\"\"\n You are given $N$ and $M$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$, $\\ldots $, $N$. For each tunnel, you are given its length. The tunnels are numbered $1$,\n-----Input----- The first line of input contains two integers $N$ and $M$, where $2 \\leq N \\leq 10^5$ and $N - 1 \\leq M \\leq 2 \\cdot 10^5$, the number of stations and the number of tunnels, respectively. Each of the next $M$ lines contains the values $a_ i$, $b_ i$, $l_ i$ and $c_ i$. The integers $a_ i$ and $b_ i$, with $1 \\leq a_ i, b_ i \\leq N$ and $a_ i\\neq b_ i$, denote the two stations connected by the $i$th tunnel. The value $l_ i$ is either an integer satisfying $1 \\leq l_ i \\leq 10^9$, the length of the $i$th tunnel if it is known, or a question mark \u201c?\u201d. Finally, $c_ i$ is $1$ if the $i$th tunnel contains a cable, and $0$ if not. It is guaranteed that there is at most one tunnel connecting the same pair of stations, and that it is possible to travel between any pair of stations using the subway. It is also guaranteed that there exists a path between any station and station number $1$ using only tunnels where $c_ i = 1$. -----Output----- For each tunnel with $l_ i=\\texttt{?}$, output one line with a single integer, the minimum possible length for that tunnel. Tunnel lengths should be output in the same order as the tunnels are listed in the input. -----Sample Description----- In the first sample case, the minimal distance for the unknown tunnel (between stations $3$ and $1$) is $5$. This is because, if the length were less than $5$, it would be more efficient for Sk\u00e5netrafiken to run cables through the second and third tunnels. -----Examples----- Sample Input: 3 3 1 2 5 1 2 3 3 1 3 1 ? 0 Sample Output: 5\n\"\"\"\ndef code():\"\"\"\nTwo great friends, Eddie John and Kris Cross, are attending the Brackets Are Perfection Conference. They wholeheartedly agree with the main message of the conference and they are delighted with all the new things they learn about brackets.\n\nOne of these things is a bracket sequence. If you want to do a computation with $+$ and $\\times $, you usually write it like so:\\[ (2 \\times (2 + 1 + 0 + 1) \\times 1) + 3 + 2. \\]\n\nThe brackets are only used to group multiplications and additions together. This means that you can remove all the operators, as long as you remember that addition is used for numbers outside any parentheses! A bracket sequence can then be shortened to\\[ (\\; 2 \\; ( \\; 2 \\; 1 \\; 0 \\; 1 \\; ) \\; 1 \\; ) \\; 3 \\; 2. \\]\n\nThat is much better, because it saves on writing all those operators. Reading bracket sequences is easy, too. Suppose you have the following bracket sequence\\[ 5 \\; 2 \\; (\\; 3 \\; 1 \\; (\\; 2 \\; 2 \\; ) \\; ( \\; 3 \\; 3 \\; ) \\; 1 \\; ). \\]\n\nYou start with addition, so this is the same as the following:\\[ 5 + 2 + (\\; 3 \\; 1 \\; (\\; 2 \\; 2 \\; ) \\; ( \\; 3 \\; 3 \\; ) \\; 1 \\; ). \\]\n\nYou know the parentheses group a multiplication, so this is equal to\\[ 5 + 2 + (3 \\times 1 \\times (\\; 2 \\; 2 \\; ) \\times ( \\; 3 \\; 3 \\; ) \\times 1). \\]\n\nThen there is another level of parentheses: that groups an operation within a multiplication, so the operation must be addition.\\[ 5 + 2 + (3 \\times 1 \\times (2 + 2 ) \\times (3 + 3) \\times 1 ) = 5 + 2 + (3 \\times 1 \\times 4 \\times 6 \\times 1) = 5+2 + 72 = 79. \\]\n\nSince bracket sequences are so much easier than normal expressions with operators, it should be easy to evaluate some big ones. We will even allow you to write a program to do it for you.\n\nNote that $(\\; )$ is not a valid bracket sequence, nor a subsequence of any valid bracket sequence.\n\n-----Input-----\n - One line containing a single integer $1\\leq n\\leq 3\\cdot 10^5$.\n - One line consisting of $n$ tokens, each being either (, ), or an integer $0\\leq x < 10^9+7$. It is guaranteed that the tokens form a bracket sequence.\n\n-----Output-----\nOutput the value of the given bracket sequence. Since this may be very large, you should print it modulo $10^9+7$.\n\n-----Examples-----\nSample Input 1:\n2\n2 3\nSample Output 1:\n5\n\nSample Input 2:\n8\n( 2 ( 2 1 ) ) 3\nSample Output 2:\n9\n\nSample Input 3:\n4\n( 12 3 )\nSample Output 3:\n36\n\nSample Input 4:\n6\n( 2 ) ( 3 )\nSample Output 4:\n5\n\nSample Input 5:\n6\n( ( 2 3 ) )\nSample Output 5:\n5\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n You are given an array with some bits. there three possible combinations of bits 10, 11, 0. convert array to string and find if the last charecter should be a one bit charecter or not  Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: Input:  bits = [1, 1, 1, 0\n\n\"\"\"\ndef is_keith_number(n):\ndef is_keith_number(n):\n    numList = [int(i) for i in str(n)]  # int array\n    if len(numList) > 1:  # min 2 digits\n        itr = 0\n        while numList[0] <= n:\n            # replace array entries by its sum:\n            numList[itr % len(numList)] = sum(numList)\n            itr += 1\n            if n in numList:  # keith-condition\n                return itr\n    return False\n\n\"\"\"\n Consider the word `\"abode\"`. We can see that the letter `a` is in position `1` and `b` is in position `2`. In the alphabet, `a` and `b` are also in positions `1` and `2`. Notice also that `d` and `e` in `abode` occupy the positions they would occupy in the alphabet, which are positions `4` and `5`.  Given an array of words, return an array of the number of letters that occupy their positions in the alphabet for each word.\n~\n\"\"\"\ndef solve(arr):\ndef solve(arr):\n    return [ sum(c == chr(97+i) for i,c in enumerate(w[:26].lower())) for w in arr ]\"\"\"\nYou are given a connected graph of $n$ nodes and $m$ bidirectional edges.\nFor each node $p = 1, 2, \\dots, n$, you need to find a minimum spanning tree. Then output the minimum cost required to travel between node $1$ and node $p$.\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of nodes and edges in the graph, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting an edge between the nodes $u$ and $v$, which has cost $c$.\n\nYou can assume that the graph is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible post required to travel from $1$ to $p$ after the selected edges are abandoned. Note that for each $p$ you can abandon a different set of edges.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\n You are given an array with some bits. there three possible combinations of bits 10, 11, 0. convert array to string and find if the last charecter should be a one bit charecter or not  Example 1: Input:  bits = [1, 0, 0] Output: True Explanation:  The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: Input:  bits = [1, 1, 1, 0\n\n\"\"\"\ndef is_keith_number(n):\ndef is_keith_number(n):\n    numList = [int(i) for i in str(n)]  # int array\n    if len(numList) > 1:  # min 2 digits\n        itr = 0\n        while numList[0] <= n:\n            # replace array entries by its sum:\n            numList[itr % len(numList)] = sum(numList)\n            itr += 1\n            if n in numList:  # keith-condition\n                return itr\n    return False\n\n\"\"\"\n Consider the word `\"abode\"`. We can see that the letter `a` is in position `1` and `b` is in position `2`. In the alphabet, `a` and `b` are also in positions `1` and `2`. Notice also that `d` and `e` in `abode` occupy the positions they would occupy in the alphabet, which are positions `4` and `5`.  Given an array of words, return an array of the number of letters that occupy their positions in the alphabet for each word.\n~\n\"\"\"\ndef solve(arr):\ndef solve(arr):\n    return [ sum(c == chr(97+i) for i,c in enumerate(w[:26].lower())) for w in arr ]\"\"\"\nCodefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ \u2014 exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\n Given two integers $N$ and $M$, find the number of sequences $A_1, A_2, \\ldots, A_N$, where each element is an integer between $1$ and $M$ (inclusive) and no three consecutive elements are equal. \n-----Input----- - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. - The first and only line of each test case contains two space-separated integers $N$ and $M$. -----Output----- For each test case, print a single line containing one integer \u2015 the number of valid sequences modulo $10^9+7$. -----Constraints----- - $1 \\le T \\le 10^5$ - $1 \\le N, M \\le 10^{18}$ -----Subtasks----- Subtask #1 (50 points): - $T \\le 20$ - $N \\le 10^5$ Subtask #2 (50 points): original constraints -----Example Input----- 2  2 2 3 4 -----Example Output----- 4 60\n\"\"\"\ndef code():\nimport sys\ndef fin(): return sys.stdin.readline().strip()\ndef fout(s, end=\"\\n\"): sys.stdout.write(str(s)+end)\n\nMOD = pow(10, 9)+7\nt = int(input())\nwhile t>0:\n t -= 1\n n, m = list(map(int, fin().split()))\n if n == 1:\n  print(m%MOD)\n  continue\n dp1 = m*(m-1)\n dp2 = m\n for i in range(3, n+1):\n  temp = dp2\n  dp2 = dp1 \n  dp1 = (temp*(m-1))%MOD+(dp1*(m-1))%MOD\n print((dp1+dp2)%MOD)\n\n \n\n\n\n\"\"\"\n You are given an array $a$ of size $n$. You need to find minimum cost of a subsequence of size $k$. \n-----Input----- The first line contains two integers $n$ and $k$ ($2 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the size of the array $a$ and the size of the subsequence. The next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u00a0\u2014 the elements of the array $a$. -----Output----- Output a single integer \u00a0\u2014 the minimum cost of a subsequence of size $k$. -----Examples----- Input 4 2 1 2 3 4 Output 1 Input 4 3 1 2 3 4 Output 2 Input 5 3 5 3 4 2 6 Output 2 Input 6 4 5 3 50 2 4 5 Output 3 -----Note----- In the first test, consider the subsequence $s$ = $\\{1, 3\\}$. Here the cost is equal to $min(max(1), max(3)) = 1$. In the second test, consider the subsequence $s$ = $\\{1, 2, 4\\}$. Here the cost is equal to $min(max(1, 4), max(2)) = 2$. In the fourth test, consider the subsequence $s$ = $\\{3, 50, 2, 4\\}$. Here the cost is equal to $min(max(3, 2), max(50, 4)) = 3$.\n\"\"\"\ndef code():\nn, k = map(int,input().split())\nlo = 0#Imposs\nhi = 10 ** 9#Poss\n\n\nl = list(map(int, input().split()))\n\nwhile hi - lo > 1:\n    test = lo + (hi - lo)//2\n\n    odd = 0\n    skip = False\n\n    for v in l:\n        if skip:\n            skip = False\n            odd += 1\n        else:\n            if v <= test:\n                odd += 1\n                skip = True\n\n    even = 0\n    skip = True\n\n    for v in l:\n        if skip:\n            skip = False\n            even += 1\n        else:\n            if v <= test:\n                even += 1\n                skip = True\n\n    if odd >= k or even >= k:\n        hi = test\n    else:\n        lo = test\n\nprint(hi)\"\"\"\n You are given a string s and an integer k. Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i. e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2\n-----Input----- The only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only. -----Output----- Print the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}. Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$ -----Examples----- Input technocup Output 1.000000000000000 Input tictictactac Output 0.333333333333333 Input bbaabaabbb Output 0.100000000000000 -----Note----- In the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely. In the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\n Given two integers $N$ and $M$, find the number of sequences $A_1, A_2, \\ldots, A_N$, where each element is an integer between $1$ and $M$ (inclusive) and no three consecutive elements are equal. \n-----Input----- - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. - The first and only line of each test case contains two space-separated integers $N$ and $M$. -----Output----- For each test case, print a single line containing one integer \u2015 the number of valid sequences modulo $10^9+7$. -----Constraints----- - $1 \\le T \\le 10^5$ - $1 \\le N, M \\le 10^{18}$ -----Subtasks----- Subtask #1 (50 points): - $T \\le 20$ - $N \\le 10^5$ Subtask #2 (50 points): original constraints -----Example Input----- 2  2 2 3 4 -----Example Output----- 4 60\n\"\"\"\ndef code():\nimport sys\ndef fin(): return sys.stdin.readline().strip()\ndef fout(s, end=\"\\n\"): sys.stdout.write(str(s)+end)\n\nMOD = pow(10, 9)+7\nt = int(input())\nwhile t>0:\n t -= 1\n n, m = list(map(int, fin().split()))\n if n == 1:\n  print(m%MOD)\n  continue\n dp1 = m*(m-1)\n dp2 = m\n for i in range(3, n+1):\n  temp = dp2\n  dp2 = dp1 \n  dp1 = (temp*(m-1))%MOD+(dp1*(m-1))%MOD\n print((dp1+dp2)%MOD)\n\n \n\n\n\n\"\"\"\n You are given an array $a$ of size $n$. You need to find minimum cost of a subsequence of size $k$. \n-----Input----- The first line contains two integers $n$ and $k$ ($2 \\leq k \\leq n \\leq 2 \\cdot 10^5$) \u00a0\u2014 the size of the array $a$ and the size of the subsequence. The next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) \u00a0\u2014 the elements of the array $a$. -----Output----- Output a single integer \u00a0\u2014 the minimum cost of a subsequence of size $k$. -----Examples----- Input 4 2 1 2 3 4 Output 1 Input 4 3 1 2 3 4 Output 2 Input 5 3 5 3 4 2 6 Output 2 Input 6 4 5 3 50 2 4 5 Output 3 -----Note----- In the first test, consider the subsequence $s$ = $\\{1, 3\\}$. Here the cost is equal to $min(max(1), max(3)) = 1$. In the second test, consider the subsequence $s$ = $\\{1, 2, 4\\}$. Here the cost is equal to $min(max(1, 4), max(2)) = 2$. In the fourth test, consider the subsequence $s$ = $\\{3, 50, 2, 4\\}$. Here the cost is equal to $min(max(3, 2), max(50, 4)) = 3$.\n\"\"\"\ndef code():\nn, k = map(int,input().split())\nlo = 0#Imposs\nhi = 10 ** 9#Poss\n\n\nl = list(map(int, input().split()))\n\nwhile hi - lo > 1:\n    test = lo + (hi - lo)//2\n\n    odd = 0\n    skip = False\n\n    for v in l:\n        if skip:\n            skip = False\n            odd += 1\n        else:\n            if v <= test:\n                odd += 1\n                skip = True\n\n    even = 0\n    skip = True\n\n    for v in l:\n        if skip:\n            skip = False\n            even += 1\n        else:\n            if v <= test:\n                even += 1\n                skip = True\n\n    if odd >= k or even >= k:\n        hi = test\n    else:\n        lo = test\n\nprint(hi)\"\"\"\nVasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.\u00a0e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.\n\nVasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. \n\nNote that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.\n\n\n-----Input-----\n\nThe only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.\n\n\n-----Output-----\n\nPrint the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$\n\n\n-----Examples-----\nInput\ntechnocup\n\nOutput\n1.000000000000000\n\nInput\ntictictactac\n\nOutput\n0.333333333333333\n\nInput\nbbaabaabbb\n\nOutput\n0.100000000000000\n\n\n\n-----Note-----\n\nIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.\n\nIn the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.\n\"\"\"\ndef code():"
}