{
    "0": "Python 3\n\"\"\"\n You are given a string s and an integer k. Vasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i. e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2\n-----Input----- The only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only. -----Output----- Print the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}. Formally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$ -----Examples----- Input technocup Output 1.000000000000000 Input tictictactac Output 0.333333333333333 Input bbaabaabbb Output 0.100000000000000 -----Note----- In the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely. In the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nVasya and Kolya play a game with a string, using the following rules. Initially, Kolya creates a string s, consisting of small English letters, and uniformly at random chooses an integer k from a segment [0, len(s) - 1]. He tells Vasya this string s, and then shifts it k letters to the left, i.\u00a0e. creates a new string t = s_{k} + 1s_{k} + 2... s_{n}s_1s_2... s_{k}. Vasya does not know the integer k nor the string t, but he wants to guess the integer k. To do this, he asks Kolya to tell him the first letter of the new string, and then, after he sees it, open one more letter on some position, which Vasya can choose.\n\nVasya understands, that he can't guarantee that he will win, but he wants to know the probability of winning, if he plays optimally. He wants you to compute this probability. \n\nNote that Vasya wants to know the value of k uniquely, it means, that if there are at least two cyclic shifts of s that fit the information Vasya knowns, Vasya loses. Of course, at any moment of the game Vasya wants to maximize the probability of his win.\n\n\n-----Input-----\n\nThe only string contains the string s of length l (3 \u2264 l \u2264 5000), consisting of small English letters only.\n\n\n-----Output-----\n\nPrint the only number\u00a0\u2014 the answer for the problem. You answer is considered correct, if its absolute or relative error does not exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1,|b|)} \\leq 10^{-6}$\n\n\n-----Examples-----\nInput\ntechnocup\n\nOutput\n1.000000000000000\n\nInput\ntictictactac\n\nOutput\n0.333333333333333\n\nInput\nbbaabaabbb\n\nOutput\n0.100000000000000\n\n\n\n-----Note-----\n\nIn the first example Vasya can always open the second letter after opening the first letter, and the cyclic shift is always determined uniquely.\n\nIn the second example if the first opened letter of t is \"t\" or \"c\", then Vasya can't guess the shift by opening only one other letter. On the other hand, if the first letter is \"i\" or \"a\", then he can open the fourth letter and determine the shift uniquely.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n \n-----Input-----  - One line containing a single integer $1\\leq n\\leq 3\\cdot 10^5$.  - One line consisting of $n$ tokens, each being either (, ), or an integer $0\\leq x < 10^9+7$. It is guaranteed that the tokens form a bracket sequence. -----Output----- Output the value of the given bracket sequence. Since this may be very large, you should print it modulo $10^9+7$. -----Examples----- Sample Input 1: 2 2 3 Sample Output 1: 5 Sample Input 2: 8 ( 2 ( 2 1 ) ) 3 Sample Output 2: 9 Sample Input 3: 4 ( 12 3 ) Sample Output 3: 36 Sample Input 4: 6 ( 2 ) ( 3 ) Sample Output 4: 5 Sample Input 5: 6 ( ( 2 3 ) ) Sample Output 5: 5\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nTwo great friends, Eddie John and Kris Cross, are attending the Brackets Are Perfection Conference. They wholeheartedly agree with the main message of the conference and they are delighted with all the new things they learn about brackets.\n\nOne of these things is a bracket sequence. If you want to do a computation with $+$ and $\\times $, you usually write it like so:\\[ (2 \\times (2 + 1 + 0 + 1) \\times 1) + 3 + 2. \\]\n\nThe brackets are only used to group multiplications and additions together. This means that you can remove all the operators, as long as you remember that addition is used for numbers outside any parentheses! A bracket sequence can then be shortened to\\[ (\\; 2 \\; ( \\; 2 \\; 1 \\; 0 \\; 1 \\; ) \\; 1 \\; ) \\; 3 \\; 2. \\]\n\nThat is much better, because it saves on writing all those operators. Reading bracket sequences is easy, too. Suppose you have the following bracket sequence\\[ 5 \\; 2 \\; (\\; 3 \\; 1 \\; (\\; 2 \\; 2 \\; ) \\; ( \\; 3 \\; 3 \\; ) \\; 1 \\; ). \\]\n\nYou start with addition, so this is the same as the following:\\[ 5 + 2 + (\\; 3 \\; 1 \\; (\\; 2 \\; 2 \\; ) \\; ( \\; 3 \\; 3 \\; ) \\; 1 \\; ). \\]\n\nYou know the parentheses group a multiplication, so this is equal to\\[ 5 + 2 + (3 \\times 1 \\times (\\; 2 \\; 2 \\; ) \\times ( \\; 3 \\; 3 \\; ) \\times 1). \\]\n\nThen there is another level of parentheses: that groups an operation within a multiplication, so the operation must be addition.\\[ 5 + 2 + (3 \\times 1 \\times (2 + 2 ) \\times (3 + 3) \\times 1 ) = 5 + 2 + (3 \\times 1 \\times 4 \\times 6 \\times 1) = 5+2 + 72 = 79. \\]\n\nSince bracket sequences are so much easier than normal expressions with operators, it should be easy to evaluate some big ones. We will even allow you to write a program to do it for you.\n\nNote that $(\\; )$ is not a valid bracket sequence, nor a subsequence of any valid bracket sequence.\n\n-----Input-----\n - One line containing a single integer $1\\leq n\\leq 3\\cdot 10^5$.\n - One line consisting of $n$ tokens, each being either (, ), or an integer $0\\leq x < 10^9+7$. It is guaranteed that the tokens form a bracket sequence.\n\n-----Output-----\nOutput the value of the given bracket sequence. Since this may be very large, you should print it modulo $10^9+7$.\n\n-----Examples-----\nSample Input 1:\n2\n2 3\nSample Output 1:\n5\n\nSample Input 2:\n8\n( 2 ( 2 1 ) ) 3\nSample Output 2:\n9\n\nSample Input 3:\n4\n( 12 3 )\nSample Output 3:\n36\n\nSample Input 4:\n6\n( 2 ) ( 3 )\nSample Output 4:\n5\n\nSample Input 5:\n6\n( ( 2 3 ) )\nSample Output 5:\n5\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nYou are given a connected graph of $n$ nodes and $m$ bidirectional edges.\nFor each node $p = 1, 2, \\dots, n$, you need to find a minimum spanning tree. Then output the minimum cost required to travel between node $1$ and node $p$.\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of nodes and edges in the graph, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting an edge between the nodes $u$ and $v$, which has cost $c$.\n\nYou can assume that the graph is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible post required to travel from $1$ to $p$ after the selected edges are abandoned. Note that for each $p$ you can abandon a different set of edges.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nCodefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) \u2014 the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ \u2014 exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.\n\"\"\"\ndef code():"
}