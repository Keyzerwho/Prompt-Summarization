{
    "0": "Python 3\n\"\"\"\n Given a string, if the cursor is at the front of the line, then pressing a \u00a0< \u00a0(the \u00a0Backspace \u00a0key) does nothing. If the cursor is at the back of the line, then pressing a \u00a0[ \u00a0(the \u00a0Home \u00a0key) does nothing. If the cursor is at the end of the line, then pressing a \u00a0] \u00a0(the \u00a0End \u00a0key) does nothing. For all other valid character in the input, it actually means that the corresponding key is pressed, we insert that character at the (typing) cursor position, and advance one position to the right the cursor accordingly. \n-----Input----- The input starts with a line containing just one integer $T \\: (1 \\le T \\le 10)$, denoting the number of test cases. Each test case is a line containing the string that was written in the Text Editor Sim (Steven IMproved). The length of the string is at most $10^{6}$, and it will only contain lowercase letters from the English alphabet [\u2018$a$\u2019$\\; \\ldots \\; $\u2018$z$\u2019], digits [\u2018$0$\u2019$\\; \\ldots \\; $\u2018$9$\u2019], spaces, as well as some of the three special characters: \u2018<\u2019, \u2018[\u2019, or \u2018]\u2019. -----Output----- For each test case, output one line containing the final string that is displayed on screen. -----Subtasks-----  - $\\textbf{(27.5 points)}$: $1 \\le T \\le 10$, string length is at most $10^{3}$, there is no \u2018[\u2019, as seen in sample $1$.  - $\\textbf{(32.5 points)}$: $1 \\le T \\le 10$, string length is at most $10^{3}$, there may be \u2018[\u2019, as seen in sample $2$.  - $\\textbf{(40 points)}$: $1 \\le T \\le 4$, string length is at most $10^{6}$. -----Examples----- Sample Input: 1 my ]]name]] is]] steva<en]<n halim]]]]] Sample Output: my name is steven halim\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nThis problem is an extension of another Kattis problem - backspace. In that problem, every time we see a character \u2018<\u2019, it actually means that the \u2018Backspace\u2019 key is pressed and we undo the last character that was just typed.\n\n\nThe extension is as follows: Now, pressing a \u2018<\u2019 (the \u2018Backspace\u2019 key) when the (typing) cursor is at the front of the line does nothing. Now if we see a character \u2018[\u2019, it actually means that the \u2018Home\u2019 key is pressed and we move the (typing) cursor to the front of the line. Similarly, if we see a character \u2018]\u2019, it actually means that the \u2018End\u2019 key is pressed and we move the (typing) cursor the back of the line. For all other valid character in the input, it actually means that the corresponding key is pressed, we insert that character at the (typing) cursor position, and advance one position to the right the cursor accordingly.\n\n-----Input-----\nThe input starts with a line containing just one integer $T \\: (1 \\le T \\le 10)$, denoting the number of test cases.\n\n\nEach test case is a line containing the string that was written in the Text Editor Sim (Steven IMproved). The length of the string is at most $10^{6}$, and it will only contain lowercase letters from the English alphabet [\u2018$a$\u2019$\\; \\ldots \\; $\u2018$z$\u2019], digits [\u2018$0$\u2019$\\; \\ldots \\; $\u2018$9$\u2019], spaces, as well as some of the three special characters: \u2018<\u2019, \u2018[\u2019, or \u2018]\u2019.\n\n-----Output-----\nFor each test case, output one line containing the final string that is displayed on screen.\n\n-----Subtasks-----\n - $\\textbf{(27.5 points)}$: $1 \\le T \\le 10$, string length is at most $10^{3}$, there is no \u2018[\u2019, as seen in sample $1$.\n - $\\textbf{(32.5 points)}$: $1 \\le T \\le 10$, string length is at most $10^{3}$, there may be \u2018[\u2019, as seen in sample $2$.\n - $\\textbf{(40 points)}$: $1 \\le T \\le 4$, string length is at most $10^{6}$.\n\n-----Examples-----\nSample Input:\n1\nmy ]]name]] is]] steva<en]<n halim]]]]]\nSample Output:\nmy name is steven halim\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n Find the length of the longest non-decreasing sequence of the given array. \n-----Input----- The first line contains two space-separated integers: n, T (1 \u2264 n \u2264 100, 1 \u2264 T \u2264 10^7). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 300). -----Output----- Print a single number \u2014 the length of a sought sequence. -----Examples----- Input 4 3 3 1 4 2 Output 5 -----Note----- The array given in the sample looks like that: 3, 1, 4, 2, 3, 1, 4, 2, 3, 1, 4, 2. The elements in bold form the largest non-decreasing subsequence.\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nYou are given an array of positive integers a_1, a_2, ..., a_{n} \u00d7 T of length n \u00d7 T. We know that for any i > n it is true that a_{i} = a_{i} - n. Find the length of the longest non-decreasing sequence of the given array.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers: n, T (1 \u2264 n \u2264 100, 1 \u2264 T \u2264 10^7). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 300).\n\n\n-----Output-----\n\nPrint a single number \u2014 the length of a sought sequence.\n\n\n-----Examples-----\nInput\n4 3\n3 1 4 2\n\nOutput\n5\n\n\n\n-----Note-----\n\nThe array given in the sample looks like that: 3, 1, 4, 2, 3, 1, 4, 2, 3, 1, 4, 2. The elements in bold form the largest non-decreasing subsequence.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\n Two strings a and b of equal length are called equivalent in one of the two cases:   They are equal.  If we split string a into two halves of the same size a_1 and a_2, and string b into two halves of the same size b_1 and b_2, then one of the following is correct:   a_1 is equivalent to b_1, and a_2 is equivalent to b_2  a_1 is equivalent to b_2, and a_2 is equivalent to b_1   \n-----Input----- The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length. -----Output----- Print \"YES\" (without the quotes), if these two strings are equivalent, and \"NO\" (without the quotes) otherwise. -----Examples----- Input aaba abaa Output YES Input aabb abab Output NO -----Note----- In the first sample you should split the first string into strings \"aa\" and \"ba\", the second one \u2014 into strings \"ab\" and \"aa\". \"aa\" is equivalent to \"aa\"; \"ab\" is equivalent to \"ba\" as \"ab\" = \"a\" + \"b\", \"ba\" = \"b\" + \"a\". In the second sample the first string can be splitted into strings \"aa\" and \"bb\", that are equivalent only to themselves. That's why string \"aabb\" is equivalent only to itself and to string \"bbaa\".\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nToday on a lecture about strings Gerald learned a new definition of string equivalency. Two strings a and b of equal length are called equivalent in one of the two cases:   They are equal.  If we split string a into two halves of the same size a_1 and a_2, and string b into two halves of the same size b_1 and b_2, then one of the following is correct:   a_1 is equivalent to b_1, and a_2 is equivalent to b_2  a_1 is equivalent to b_2, and a_2 is equivalent to b_1  \n\nAs a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.\n\nGerald has already completed this home task. Now it's your turn!\n\n\n-----Input-----\n\nThe first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.\n\n\n-----Output-----\n\nPrint \"YES\" (without the quotes), if these two strings are equivalent, and \"NO\" (without the quotes) otherwise.\n\n\n-----Examples-----\nInput\naaba\nabaa\n\nOutput\nYES\n\nInput\naabb\nabab\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample you should split the first string into strings \"aa\" and \"ba\", the second one \u2014 into strings \"ab\" and \"aa\". \"aa\" is equivalent to \"aa\"; \"ab\" is equivalent to \"ba\" as \"ab\" = \"a\" + \"b\", \"ba\" = \"b\" + \"a\".\n\nIn the second sample the first string can be splitted into strings \"aa\" and \"bb\", that are equivalent only to themselves. That's why string \"aabb\" is equivalent only to itself and to string \"bbaa\".\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\n Malek has recently found a treasure map. While he was looking for a treasure he found a locked door. There was a string s written on the door consisting of characters '(', ')' and '#'. Below there was a manual on how to open the door. After spending a long time Malek managed to decode the manual and found out that the goal is to replace each '#' with one or more ')' characters so that the final string becomes beautiful. Below there was also written that a string is called beautiful if for each i (1   i   |s|) there are no more ')' characters than '(' characters among the first i characters of s and also the total number of '(' characters is equal to the total number of ')' characters. Help Malek open the door by telling him for each '#' character how many ')' characters he must replace it with.\n-----Input----- The first line of the input contains a string s (1 \u2264 |s| \u2264 10^5). Each character of this string is one of the characters '(', ')' or '#'. It is guaranteed that s contains at least one '#' character. -----Output----- If there is no way of replacing '#' characters which leads to a beautiful string print  - 1. Otherwise for each character '#' print a separate line containing a positive integer, the number of ')' characters this character must be replaced with. If there are several possible answers, you may output any of them. -----Examples----- Input (((#)((#) Output 1 2 Input ()((#((#(#() Output 2 2 1 Input # Output -1 Input (#) Output -1 -----Note----- |s| denotes the length of the string s.\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nMalek has recently found a treasure map. While he was looking for a treasure he found a locked door. There was a string s written on the door consisting of characters '(', ')' and '#'. Below there was a manual on how to open the door. After spending a long time Malek managed to decode the manual and found out that the goal is to replace each '#' with one or more ')' characters so that the final string becomes beautiful. \n\nBelow there was also written that a string is called beautiful if for each i (1 \u2264 i \u2264 |s|) there are no more ')' characters than '(' characters among the first i characters of s and also the total number of '(' characters is equal to the total number of ')' characters. \n\nHelp Malek open the door by telling him for each '#' character how many ')' characters he must replace it with.\n\n\n-----Input-----\n\nThe first line of the input contains a string s (1 \u2264 |s| \u2264 10^5). Each character of this string is one of the characters '(', ')' or '#'. It is guaranteed that s contains at least one '#' character.\n\n\n-----Output-----\n\nIf there is no way of replacing '#' characters which leads to a beautiful string print  - 1. Otherwise for each character '#' print a separate line containing a positive integer, the number of ')' characters this character must be replaced with.\n\nIf there are several possible answers, you may output any of them.\n\n\n-----Examples-----\nInput\n(((#)((#)\n\nOutput\n1\n2\n\nInput\n()((#((#(#()\n\nOutput\n2\n2\n1\nInput\n#\n\nOutput\n-1\n\nInput\n(#)\n\nOutput\n-1\n\n\n\n-----Note-----\n\n|s| denotes the length of the string s.\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\n Given five numbers written on cards, find the minimum sum of numbers on remaining cards. \n-----Input----- The only line of the input contains five integers t_1, t_2, t_3, t_4 and t_5 (1 \u2264 t_{i} \u2264 100)\u00a0\u2014 numbers written on cards. -----Output----- Print the minimum possible sum of numbers written on remaining cards. -----Examples----- Input 7 3 7 3 20 Output 26 Input 7 9 3 1 8 Output 28 Input 10 10 10 10 10 Output 20 -----Note----- In the first sample, Limak has cards with numbers 7, 3, 7, 3 and 20. Limak can do one of the following.   Do nothing and the sum would be 7 + 3 + 7 + 3 + 20 = 40.  Remove two cards with a number 7. The remaining sum would be 3 + 3 + 20 = 26.  Remove two cards with a number 3. The remaining sum would be 7 + 7 + 20 = 34.  You are asked to minimize the sum so the answer is 26. In the second sample, it's impossible to find two or three cards with the same number. Hence, Limak does nothing and the sum is 7 + 9 + 1 + 3 + 8 = 28. In the third sample, all cards have the same number. It's optimal to discard any three cards. The sum of two remaining numbers is 10 + 10 = 20.\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nA little bear Limak plays a game. He has five cards. There is one number written on each card. Each number is a positive integer.\n\nLimak can discard (throw out) some cards. His goal is to minimize the sum of numbers written on remaining (not discarded) cards.\n\nHe is allowed to at most once discard two or three cards with the same number. Of course, he won't discard cards if it's impossible to choose two or three cards with the same number.\n\nGiven five numbers written on cards, cay you find the minimum sum of numbers on remaining cards?\n\n\n-----Input-----\n\nThe only line of the input contains five integers t_1, t_2, t_3, t_4 and t_5 (1 \u2264 t_{i} \u2264 100)\u00a0\u2014 numbers written on cards.\n\n\n-----Output-----\n\nPrint the minimum possible sum of numbers written on remaining cards.\n\n\n-----Examples-----\nInput\n7 3 7 3 20\n\nOutput\n26\n\nInput\n7 9 3 1 8\n\nOutput\n28\n\nInput\n10 10 10 10 10\n\nOutput\n20\n\n\n\n-----Note-----\n\nIn the first sample, Limak has cards with numbers 7, 3, 7, 3 and 20. Limak can do one of the following.\n\n  Do nothing and the sum would be 7 + 3 + 7 + 3 + 20 = 40.  Remove two cards with a number 7. The remaining sum would be 3 + 3 + 20 = 26.  Remove two cards with a number 3. The remaining sum would be 7 + 7 + 20 = 34. \n\nYou are asked to minimize the sum so the answer is 26.\n\nIn the second sample, it's impossible to find two or three cards with the same number. Hence, Limak does nothing and the sum is 7 + 9 + 1 + 3 + 8 = 28.\n\nIn the third sample, all cards have the same number. It's optimal to discard any three cards. The sum of two remaining numbers is 10 + 10 = 20.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\n You have to analyze a given nervous system of a zombie and find out whether it is valid. \n-----Input----- The first line of the input contains two space-separated integers n and m (1 \u2264 n, m \u2264 1000) denoting the number of brains (which are conveniently numbered from 1 to n) and the number of brain connectors in the nervous system, respectively. In the next m lines, descriptions of brain connectors follow. Every connector is given as a pair of brains a\u2002b it connects (1 \u2264 a, b \u2264 n, a \u2260 b). -----Output----- The output consists of one line, containing either yes or no depending on whether the nervous system is valid. -----Examples----- Input 4 4 1 2 2 3 3 1 4 1 Output no Input 6 5 1 2 2 3 3 4 4 5 3 6 Output yes\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nOne particularly well-known fact about zombies is that they move and think terribly slowly. While we still don't know why their movements are so sluggish, the problem of laggy thinking has been recently resolved. It turns out that the reason is not (as previously suspected) any kind of brain defect \u2013 it's the opposite! Independent researchers confirmed that the nervous system of a zombie is highly complicated \u2013 it consists of n brains (much like a cow has several stomachs). They are interconnected by brain connectors, which are veins capable of transmitting thoughts between brains. There are two important properties such a brain network should have to function properly:   It should be possible to exchange thoughts between any two pairs of brains (perhaps indirectly, through other brains).  There should be no redundant brain connectors, that is, removing any brain connector would make property 1 false. \n\nIf both properties are satisfied, we say that the nervous system is valid. Unfortunately (?), if the system is not valid, the zombie stops thinking and becomes (even more) dead. Your task is to analyze a given nervous system of a zombie and find out whether it is valid.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n and m (1 \u2264 n, m \u2264 1000) denoting the number of brains (which are conveniently numbered from 1 to n) and the number of brain connectors in the nervous system, respectively. In the next m lines, descriptions of brain connectors follow. Every connector is given as a pair of brains a\u2002b it connects (1 \u2264 a, b \u2264 n, a \u2260 b).\n\n\n-----Output-----\n\nThe output consists of one line, containing either yes or no depending on whether the nervous system is valid.\n\n\n-----Examples-----\nInput\n4 4\n1 2\n2 3\n3 1\n4 1\n\nOutput\nno\n\nInput\n6 5\n1 2\n2 3\n3 4\n4 5\n3 6\n\nOutput\nyes\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\n Petya's friends made him a birthday present a bracket sequence. Petya was quite disappointed with his gift, because he dreamed of correct bracket sequence, yet he told his friends nothing about his dreams and decided to fix present himself. To make everything right, Petya is going to move at most one bracket from its original place in the sequence to any other position. Reversing the bracket (e.g. turning \"(\" into \")\" or vice versa) isn't allowed. We remind that bracket sequence $s$ is called correct if: $s$ is empty; $s$ is equal to \"($t$)\", where $t$ is correct bracket sequence; $s$ is equal to $t_1 t_2$, i.e. concatenation of $t_1$ and $t_2$, where $t_1$ and $t_2$ are correct bracket sequences. For example, \"(()())\", \"()\" are correct, while \")(\" and \"())\" are not. Help Petya to fix his birthday present and understand whether he can move one bracket so that the sequence becomes correct.\n-----Input----- First of line of input contains a single number $n$ ($1 \\leq n \\leq 200\\,000$)\u00a0\u2014 length of the sequence which Petya received for his birthday. Second line of the input contains bracket sequence of length $n$, containing symbols \"(\" and \")\". -----Output----- Print \"Yes\" if Petya can make his sequence correct moving at most one bracket. Otherwise print \"No\". -----Examples----- Input 2 )( Output Yes Input 3 (() Output No Input 2 () Output Yes Input 10 )))))((((( Output No -----Note----- In the first example, Petya can move first bracket to the end, thus turning the sequence into \"()\", which is correct bracket sequence. In the second example, there is no way to move at most one bracket so that the sequence becomes correct. In the third example, the sequence is already correct and there's no need to move brackets.\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nPetya's friends made him a birthday present \u2014 a bracket sequence. Petya was quite disappointed with his gift, because he dreamed of correct bracket sequence, yet he told his friends nothing about his dreams and decided to fix present himself. \n\nTo make everything right, Petya is going to move at most one bracket from its original place in the sequence to any other position. Reversing the bracket (e.g. turning \"(\" into \")\" or vice versa) isn't allowed. \n\nWe remind that bracket sequence $s$ is called correct if:   $s$ is empty;  $s$ is equal to \"($t$)\", where $t$ is correct bracket sequence;  $s$ is equal to $t_1 t_2$, i.e. concatenation of $t_1$ and $t_2$, where $t_1$ and $t_2$ are correct bracket sequences. \n\nFor example, \"(()())\", \"()\" are correct, while \")(\" and \"())\" are not. Help Petya to fix his birthday present and understand whether he can move one bracket so that the sequence becomes correct.\n\n\n-----Input-----\n\nFirst of line of input contains a single number $n$ ($1 \\leq n \\leq 200\\,000$)\u00a0\u2014 length of the sequence which Petya received for his birthday.\n\nSecond line of the input contains bracket sequence of length $n$, containing symbols \"(\" and \")\".\n\n\n-----Output-----\n\nPrint \"Yes\" if Petya can make his sequence correct moving at most one bracket. Otherwise print \"No\".\n\n\n-----Examples-----\nInput\n2\n)(\n\nOutput\nYes\n\nInput\n3\n(()\n\nOutput\nNo\n\nInput\n2\n()\n\nOutput\nYes\n\nInput\n10\n)))))(((((\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn the first example, Petya can move first bracket to the end, thus turning the sequence into \"()\", which is correct bracket sequence.\n\nIn the second example, there is no way to move at most one bracket so that the sequence becomes correct.\n\nIn the third example, the sequence is already correct and there's no need to move brackets.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\n You are given a grid of $N$ by $M$ patches. For each patch, you need to find the shortest distance between the Wolf and all trees. Output the shortest route. \n-----Input----- The first line of input contains integers $N$ and $M$ ($1 \\leq N, M \\leq 500$), the grid dimensions. The next $N$ lines contain $M$ characters, each being one of \u2018.\u2019, \u2018+\u2019, \u2018V\u2019, and \u2018J\u2019. The input will contain exactly one each of the characters \u2018V\u2019 and \u2018J\u2019, and at least one character \u2018+\u2019. -----Output----- Output a single integer, the minimal distance from a tree in the optimal route. -----Examples----- Sample Input 1: 4 4 +... .... .... V..J Sample Output 1: 3 Sample Input 2: 4 5 ..... .+++. .+.+. V+.J+ Sample Output 2: 0\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nVjekoslav the Wolf is running away from a bunch of blood hungry hunters. The hunters are smart and hide behind trees. Vjekoslav knows this, but doesn\u2019t know which trees. He would like to run to his comfortable, civilized cottage (as opposed to the hunters quite uncivilized den, yes I am rooting for the Wolf here) staying as far away as possible from any trees.\n\nThe forest can be represented as an $N$ by $M$ grid. Let us mark empty meadow patches with \u2018.\u2019, patches with a tree in the middle with \u2018+\u2019, Vjekoslav\u2019s current position with \u2018V\u2019 and the position of his cottage with \u2018J\u2019. Vjekoslav can run from his current patch to any other patch north, east, south or west from him, even if it contains a tree.\n\nIf Vjekoslav is standing in $R$-th row and $C$-th column on the grid and there is a tree in the $A$-th row and $B$-th column then the distance between Vjekoslav and that tree is\\[ \\lvert R-A \\rvert + \\lvert C-B \\rvert \\]\n\nHelp Vjekoslav find the best route to his cottage. The best route is any route that maximizes the minimal distance between Vjekoslav and all trees at any given moment.\n\nNote that Vjekoslav\u2019s cottage doesn\u2019t occupy the entire patch so that patch must also be included in the route.\n\n-----Input-----\nThe first line of input contains integers $N$ and $M$ ($1 \\leq N, M \\leq 500$), the grid dimensions.\n\nThe next $N$ lines contain $M$ characters, each being one of \u2018.\u2019, \u2018+\u2019, \u2018V\u2019, and \u2018J\u2019.\n\nThe input will contain exactly one each of the characters \u2018V\u2019 and \u2018J\u2019, and at least one character \u2018+\u2019.\n\n-----Output-----\nOutput a single integer, the minimal distance from a tree in the optimal route.\n\n-----Examples-----\nSample Input 1:\n4 4\n+...\n....\n....\nV..J\nSample Output 1:\n3\n\nSample Input 2:\n4 5\n.....\n.+++.\n.+.+.\nV+.J+\nSample Output 2:\n0\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\n Polycarpus and Vasily play a very interesting game. They have n chests with coins, the chests are numbered with integers from 1 to n. Chest number i has a_{i} coins.  Polycarpus and Vasily move in turns. Polycarpus moves first. During a move a player is allowed to choose a positive integer x (2 x + 1   n) and take a coin from each chest with numbers x, 2 x, 2 x + 1. It may turn out that some chest has no coins, in this case the player doesn't take a coin from this chest. The game finishes when all chests get emptied. Polycarpus isn't a greedy scrooge. Polycarpys is a lazy slob. So he wonders in what minimum number of moves the game can finish. Help Polycarpus, determine the minimum number of moves in which the game can finish. Note that Polycarpus counts not only his moves, he also counts Vasily's moves.\n-----Input----- The first line contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of chests with coins. The second line contains a sequence of space-separated integers: a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 1000), where a_{i} is the number of coins in the chest number i at the beginning of the game. -----Output----- Print a single integer \u2014 the minimum number of moves needed to finish the game. If no sequence of turns leads to finishing the game, print -1. -----Examples----- Input 1 1 Output -1 Input 3 1 2 3 Output 3 -----Note----- In the first test case there isn't a single move that can be made. That's why the players won't be able to empty the chests. In the second sample there is only one possible move x = 1. This move should be repeated at least 3 times to empty the third chest.\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nTwo pirates Polycarpus and Vasily play a very interesting game. They have n chests with coins, the chests are numbered with integers from 1 to n. Chest number i has a_{i} coins. \n\nPolycarpus and Vasily move in turns. Polycarpus moves first. During a move a player is allowed to choose a positive integer x (2\u00b7x + 1 \u2264 n) and take a coin from each chest with numbers x, 2\u00b7x, 2\u00b7x + 1. It may turn out that some chest has no coins, in this case the player doesn't take a coin from this chest. The game finishes when all chests get emptied.\n\nPolycarpus isn't a greedy scrooge. Polycarpys is a lazy slob. So he wonders in what minimum number of moves the game can finish. Help Polycarpus, determine the minimum number of moves in which the game can finish. Note that Polycarpus counts not only his moves, he also counts Vasily's moves.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of chests with coins. The second line contains a sequence of space-separated integers: a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 1000), where a_{i} is the number of coins in the chest number i at the beginning of the game.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimum number of moves needed to finish the game. If no sequence of turns leads to finishing the game, print -1.\n\n\n-----Examples-----\nInput\n1\n1\n\nOutput\n-1\n\nInput\n3\n1 2 3\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first test case there isn't a single move that can be made. That's why the players won't be able to empty the chests.\n\nIn the second sample there is only one possible move x = 1. This move should be repeated at least 3 times to empty the third chest.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n Given a tree with N vertices, find a way to color the tree with black and white colors and weights so that the sum of the weights of the vertices with the same color as a given vertex is equal to a given number.\n-----Inputs----- Input is given from Standard Input in the following format: N P_2 P_3 ... P_N X_1 X_2 ... X_N -----Outputs----- If it is possible to allocate colors and weights to the vertices so that the condition is satisfied, print POSSIBLE; otherwise, print IMPOSSIBLE. -----Sample Input----- 3 1 1 4 3 2 -----Sample Output----- POSSIBLE For example, the following allocation satisfies the condition:  - Set the color of Vertex 1 to white and its weight to 2.  - Set the color of Vertex 2 to black and its weight to 3.  - Set the color of Vertex 3 to white and its weight to 2. There are also other possible allocations.\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nWe have a tree with N vertices. Vertex 1 is the root of the tree, and the parent of Vertex i (2 \\leq i \\leq N) is Vertex P_i.\nTo each vertex in the tree, Snuke will allocate a color, either black or white, and a non-negative integer weight.\nSnuke has a favorite integer sequence, X_1, X_2, ..., X_N, so he wants to allocate colors and weights so that the following condition is satisfied for all v.\n - The total weight of the vertices with the same color as v among the vertices contained in the subtree whose root is v, is X_v.\nHere, the subtree whose root is v is the tree consisting of Vertex v and all of its descendants.\nDetermine whether it is possible to allocate colors and weights in this way.\n\n-----Constraints-----\n - 1 \\leq N \\leq 1 000\n - 1 \\leq P_i \\leq i - 1\n - 0 \\leq X_i \\leq 5 000\n\n-----Inputs-----\nInput is given from Standard Input in the following format:\nN\nP_2 P_3 ... P_N\nX_1 X_2 ... X_N\n\n-----Outputs-----\nIf it is possible to allocate colors and weights to the vertices so that the condition is satisfied, print POSSIBLE; otherwise, print IMPOSSIBLE.\n\n-----Sample Input-----\n3\n1 1\n4 3 2\n\n-----Sample Output-----\nPOSSIBLE\n\nFor example, the following allocation satisfies the condition:\n - Set the color of Vertex 1 to white and its weight to 2.\n - Set the color of Vertex 2 to black and its weight to 3.\n - Set the color of Vertex 3 to white and its weight to 2.\nThere are also other possible allocations.\n\"\"\"\ndef code():"
}