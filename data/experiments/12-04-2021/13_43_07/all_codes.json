{
    "0": "\n    if not isinstance(position, str):\n        return []\n    if len(position) != 2:\n        return []\n    if position[0] not in 'ABCDEFGH' or position[1] not in '12345678':\n        return []\n\n    x = ord(position[0]) - ord('A') + 1\n    y = int(position[1])\n\n    moves = []\n\n    for i in range(-8, 9):\n        moves.append('{}{}'.format(chr(x + i), y))\n        moves.append('{}{}'.format(chr(x), y + i))\n\n    for i in range(-8, 9):\n        for j in range(-8, 9):\n            if abs(i) == abs(j): continue\n\n            moves.append('{}{}'.format(chr(x + i), y + j))\n\n    return sorted([m for m in moves if m != position])",
    "1": "\n    if type(position) != str:\n        return []\n    if len(position) != 2:\n        return []\n    if position[0] not in 'ABCDEFGH' or position[1] not in '12345678':\n        return []\n\n    x = ord(position[0]) - ord('A') + 1\n    y = int(position[1])\n\n    moves = []\n\n    for i in range(-8, 9):\n        moves.append(chr(ord('A') + x + i) + str(y))\n        moves.append(chr(ord('A') + x - i) + str(y))\n\n    for i in range(-8, 9):\n        moves.append(chr(ord('A') + x) + str(y + i))\n        moves.append(chr(ord('A') + x) + str(y - i))\n\n    for i in range(-8, 9):\n        moves.append((chr((ord('A') - 1) % (x+i+1) % 8+65), y)) # right up diagonal  A1 -> H8 -> A8 -> H1 -> A7 ...  (modulo to prevent overflow from 8 to 0 and vice versa)  (chr to convert number to letter)  (tuple because it's immutable and we need hashable object as a dict key later on)\n        moves.append((chr((ord('H') - 1) % (x-i-1)+1 % 8+65), y)) # left up diagonal  H1 -> A8 -> H8 -> A7 ...\n\n    for i in range(-8, 9):\n        moves.append((chr((ord('A') - 1) % (x+i+1)+1 % 8+65), y)) # right down diagonal  A2 -> B2 ... H2 ... B7 ... H7 ... B3 ... H3 ...   (modulo to prevent overflow from 8 to 0 and vice versa)  (tuple because it's immutable and we need hashable object as a dict key later on)   (chr to convert number to letter)   ((ord()-65)*-1%9+65 is the same as chr())   ((ord()-65)*-2%9+65 is the same as chr())   ((ord()-65)*-3%9+65 is the same as chr())   ((ord()-65)*-4%9+65 is the same as chr())   ((ord()-65)*-5%9+65 is the same as chr())   ((ord()-65)*-6%9+65 is the same as chr())   ((ord()-65)*-7%9+65 is the same as chr())     ((ord()*2%-63)+63 is the same as chr())     ((ord()*3%-63)+63 is the same as chr())     ((ord()*4%-63)+63 is the same as chr())     ((ord()*5%-63)+63 is the same as chr())     ((ord()*6%-63)+63 is the same as chr())     ((ord()*7%-63)+63 is the same as chr())     \n\n    return sorted([move for move in set([str(_move[0]+str(_move[1])) for _move in set([_move for _move in set([_move for _move in moves if _move[0] not in 'ABCDEFGH' or _move[1] not in '12345678'] if _move[0] not in 'ABCDEFGH' or _move[1] not in '12345678'] if _move[0] not in 'ABCDEFGH' or _move[1] not in '12345678'] if _move[0] not in 'ABCDEFGH' or _move[1] not in '12345678'] )])])",
    "2": "\n    n = int(input())\n    points = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    # sort by x-coordinate and then by y-coordinate\n    points.sort()\n\n    # calculate the area of the convex polygon formed by the points\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n  # j is the next point of i in the list of points\n        area += (points[j][0] - points[i][0]) * (points[j][1] + points[i][1])\n\n    # if the area is positive, then it is a counter-clockwise order; otherwise it is clockwise order and we need to swap our results later. \n    if area > 0:  # counter-clockwise order: we need to swap our results later. \n        flag = False  # False means that we don't need to swap our results later. \n    else:  # clockwise order: we need to swap our results later. \n        flag = True\n\n    # calculate the perimeter of each possible number of points (3 to n) and store them in a list called perimeters.  \n    perimeters = []\n\n    for i in range(3, n + 1):  # 3 <= i <= n; 3 <= number_of_points <= n; 3 <= number_of_edges <= n; 3 <= number_of_vertices <= n; 3 <= number_of_corners <= n; 3 <= number_of_sides <= n; 3 < size >= 0; 2 < radius >= 0; 2 < diameter >= 0; 2 < width >= 0; 2 < height >= 0; 2 < depth >= 0; 2 < length >= 0 ; 2 < radius >= 0 ; 2 < side >= 0 ; 2 < edge >= 0 ; 2 < vertex >= 0 ; 1 < length >= a ; 1 < width >= b ; 1 > height > c ; 1 > depth > d ; 1 > radius > e ; 1 > diameter > f .  \n\n        perimeter = sum([distance(points[i], points[j]) for i in range(n) for j in range(i + 1, n)])\n\n        if flag:  # clockwise order: we need to swap our results later.  \n            perimeter *= -1\n\n        perimeters.append(perimeter)\n\n    \t# print out all the perimeters from smallest to largest one by one line.  \n\n    \t# If there are multiple answers with same value, print them from smallest to largest one by one line each time without any space between two numbers.  \n\n    \t# If there are no answers at all, print \"No Solution\" without quotes as an answer instead of empty line or blank line or no line at all.  \n\n    \t# If there are multiple answers with same value and they are not printed out yet, print them from smallest to largest one by one line each time without any space between two numbers until all answers with this value are printed out completely without any space between two numbers before moving on to other values with same answer values as this value or other answer values which are larger than this value but still not printed out completely without any space between two numbers yet until all such answer values with same answer values as this value or larger answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values are printed out completely without any space between two numbers yet until all such answer values\u00a0are\u00a0printed\u00a0out\u00a0completely\u00a0without\u00a0any\u00a0space\u00a0between\u00a0two\u00a0numbers . \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 \u00a0 \u00a0\u00a0\u00a0\u00a0\n\u00a0 -------Sample Input----- \u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b \u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b \u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b \u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b \u200b\u200b\u200b\u200b\u200b\u200eInput Format Description",
    "3": "\n    n = int(input())\n    points = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    def dist(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def perimeter(points):\n        res = 0\n        for i in range(len(points)):\n            res += dist(points[i], points[i-1])\n        return res\n\n    def is_self_intersecting():\n        for i in range(len(points)):\n            for j in range(i+2, len(points)):\n                if (dist(*points[i], *points[j]) == 0 and dist(*points[i-1], *points[j-1]) == 0) or \\\n                    (dist(*points[i], *points[j]) == dist(*points[i-1], *points[j-1]) and \\\n                        not (dist(*points[i], *points[j]) == 0 and dist(*points[i-1], *points[j-1]) == 0)):  # noqa: E501\n\n                    return True\n\n        return False\n\n    if is_self_intersecting():  # noqa: E712  # pragma: no cover  # noqa: E501  # pragma: no cover  # pragma: no cover  # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover     pass  else : pass  else : pass  else : pass  else : pass  else : pass     pass     pass     pass     pass     pass     pass     pass     pass     pass     \n\n    max_perimeter = 0\n\n    for i in range(-100000, 100001):\n        for j in range(-100000, 100001):\n            if i != j and i != 0 and j != 0 and abs((j / i) - 1) < 1e-6 or \\\n                abs((abs((j / i)) - 1)) < 1e-6 or \\\n                abs((abs((abs((j / i))) - 1))) < 1e-6 or \\\n                abs((abs((abs((abs((j / i)))) - 1))) < 1e-6 or \\                                                                                                                                                             \\               ) < 1e-6 or \\               ) < 1e-6 or \\               ) < 1e-6 or \\               ) < 1e-6 or \\               ) < 1e-6 or \\               ) < 1e-6 or \\               ) < 1e-6 or \\               ) < 1e 6or\\              ): continue      continue      continue      continue      continue      continue      continue       continue       continue       continue       continue       contine         contine         contine         contine         contine         contine         contine          contine          contine          contine          contine          contin           contin           contin           contin           contin           contin           contin            contin            contin            contin            contin            continu             continu             continu             continu             continu             continu             \n\n    max_perimeter = max([perimeter([*point, x, y]) for point in points] + [max_perimeter])",
    "4": "\n    t = int(input())\n    for i in range(t):\n        d, m = map(int, input().split())\n        if d == 1:\n            print(1)\n        else:\n            print((d - 2) * (m - 1) + 1)\n\n\nif __name__ == '__main__':\n    code()",
    "5": "\n    t = int(input())\n    for i in range(t):\n        d, m = map(int, input().split())\n        print((d - 1) * (m - 1))",
    "6": "\n    n = int(input())\n    a = input()\n    b = input()\n    dp = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        if a[i] == b[i]:\n            dp[i][i] = 0\n        else:\n            dp[i][i] = 1\n\n    for l in range(2, n+1): # l is the length of the substring we are looking at. \n        for i in range(0, n-l+1): # i is the starting index of the substring. \n            j = i + l - 1 # j is the ending index of the substring. \n\n            if a[j] == b[j]: # If they are equal, then we don't need to do anything. \n                dp[i][j] = dp[i+1][j-1]\n\n            else: # If they are not equal, then we need to either swap or flip. \n\n                # We can swap two bits only if they are different. So we check if they are different or not. \n\n                if a[i] != b[j]: # If they are different, then we can swap them and it will cost us |i - j|. \n                    dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + abs(j-i)\n\n                else: # If they are same, then we can either swap or flip them. We choose whichever costs less. \n\n                    # We can flip any bit only if it is 0 to 1 or 1 to 0. So we check that as well. \n\n                    if a[j] == '0': # If it is 0, then flipping will cost us 1 and swapping will cost us |i - j| as usual. \n                        dp[i][j] = min(dp[i+1][j], dp[i][j-1]+abs(j-i)) + 1\n\n                    else: # If it is 1, then flipping will cost us 0 and swapping will cost us |i - j| as usual again.  \n                        dp[i][j] = min(dp[i+1][j]+1, dp[i][j-1]+abs(j-i))\n\n    return str(dp)",
    "7": "\n    n = int(input())\n    a = input()\n    b = input()\n\n    # The cost of the swap operation is |i - j|.\n    # The cost of the flip operation is 1.\n\n    # We can use dynamic programming to solve this problem.\n    # Let's create a matrix dp[n][2], where dp[i][0] and dp[i][1] are the costs of making strings a and b equal at index i, respectively.\n\n    # Initialize the matrix:\n    dp = [[0 for _ in range(2)] for _ in range(n + 1)]\n\n    # Base case:\n    dp[0][0] = 0  # The cost of making string a equal to itself at index 0 is 0.\n    dp[0][1] = 0  # The cost of making string b equal to itself at index 0 is 0.\n\n    for i in range(1, n + 1):  # For each index i from 1 to n:\n        if a[i - 1] == '0':  # If the bit at index i in string a is zero:\n            dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])  # Then we can make string a equal to string b by either flipping the bit at index i or swapping it with the bit at index i - 1 (the minimum between these two options).\n        else:  # If the bit at index i in string a is one:\n            dp[i][0] = min(dp[i - 1][1], dp[i - 1][0]) + 1  # Then we can make string a equal to string b by either flipping the bit at index i or swapping it with the bit at index i - 1 (the minimum between these two options) plus one (for flipping).\n\n        if b[i - 1] == '0':  # If the bit at index i in string b is zero:\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + 2  # Then we can make string b equal to string a by either flipping the bit at index i or swapping it with the bit at index i - 2 (the minimum between these two options) plus two (for swapping).\n        else:  # If the bit at index i in string b is one:\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + 3  # Then we can make string b equal to string a by either flipping the bit at index i or swapping it with the bit at index i - 2 (the minimum between these two options) plus three (for both operations).\n\n        print(\"{} {}\".format(dp, \"\\n\"))\n\n        print(\"{} {}\".format(\"a\", \"b\"))\n\n        for row in range(len(dp)):  \t# Prints each row on its own line.\t\t\t\t\t\t# Prints each row on its own line.",
    "8": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(1, n):\n        if a[i] <= a[i-1]:\n            count += (a[i-1] - a[i]) + 1\n            a[i] += (a[i-1] - a[i]) + 1\n\n    print(count)\n\n",
    "9": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(1, n):\n        if a[i] <= a[i-1]:\n            count += a[i-1] - a[i] + 1\n            a[i] = a[i-1] + 1\n\n    print(count)\n\n",
    "10": "\n    n = int(input())\n    words = []\n    for i in range(n):\n        words += input().split()\n    print(len(set(words)))\n    for word in sorted(set(words)):\n        print(word)",
    "11": "\n    n = int(input())\n    words = []\n    for i in range(n):\n        words += input().split()\n    print(len(set(words)))\n    for word in sorted(set(words)):\n        print(word)",
    "12": "\n    return sum(int(x) for x in str(abs(number)))",
    "13": "\n    return sum(int(x) for x in str(abs(number)))",
    "14": "\n    n, a, b, c, d = map(int, input().split())\n    mod = 10**9+7\n    if a == 1:\n        print((b-a+1)*(n-b) % mod)\n    elif b == n:\n        print((b-a+1)*(n-a) % mod)\n    else:\n        print((b-a+1)*(n-b) % mod + (n-a+1)*(b-a+1) % mod - (n-a+1)*(n-b) % mod + (c*d*2)%mod + ((c*d*2)-c*d-(c*d)+c+(d*2)-d-(d))%mod + 1%mod )\n\n",
    "15": "\n    n, a, b, c, d = map(int, input().split())\n    mod = 10**9 + 7\n    # The number of ways to divide the people into groups is equal to the number of ways to divide the people into groups where each group contains between A and B people.\n    # This is because if a group contains exactly i people, then there are C <= i <= D groups that contain exactly i people.\n    # Therefore, we can calculate the number of ways to divide the people into groups where each group contains between A and B people by calculating the number of ways to divide the people into groups where each group contains between C and D people.\n    # We can calculate this by using dynamic programming.\n\n    # Create an array that will store all of our values for later use.\n    arr = [[0 for x in range(d+1)] for y in range(b+1)]\n\n    # Base case: If either C or D is 0, then there are no ways to divide the people into groups where each group contains exactly 0 or 1 person.\n    for i in range(2):\n        arr[i][0] = 1\n\n    # Fill out all other values in our array using dynamic programming.\n    for i in range(2, b+1):\n        for j in range(1, d+1):\n            if j < c:  # If j is less than C (the minimum number of people per group), then we know that there are no possible combinations that satisfy our conditions. Therefore we set this value equal to 0 and move on to the next value.\n                arr[i][j] = 0\n\n            else:  # Otherwise we need to find all possible combinations that satisfy our conditions and add them together. We do this by finding all possible combinations with j-c (the maximum number of people per group) and adding it to all possible combinations with j (the minimum number of people per group). We do this by multiplying it by factorials!\n\n                arr[i][j] += ((arr[i-1][j-c]) * factorials[j]) % mod  # Add all possible combinations with j-c (the maximum number of peopl per group) multiplied by factorials!\n\n                if c != 1:  # If C is not equal to 1 (which means that there are no restrictions on how many peopl can be in a single group), then we need to add all possible combinations with j (the minimum number of peopl per group) multiplied by factorials!. This is because if C=1 then any combination with j peopl will also be a combination with j-c peopl since you can just subtract one person from both sides. Therefore any combination with j peopl will also be a combination with j-c peopl which means we don't need to add them together again since they will already be included in our previous answer when we found all possible combinations with j-c peopl multiplied by factorials!.\n\n                else:  # Otherwise if C=1 then any combination with j peopl will NOT be a combination with j-c peopl since you cannot subtract one person from both sides! Therefore any combination with j peopl CANNOT be combined with any combination wihtout at least one person so we only need to find all possible combinations without at least one person which is done below...\n\n                    arr[i][j] += ((arr[i - 1][j - 1]) * factorials[j]) % mod  # Add all possible combinations without at least one person multiplied by factorials!\n\n                arr[i][j] %= mod  # Modulo 10^9 + 7 so as not to exceed maximum size limit when printing answer\n\n            print(\"arr[\" + str(i) + \"][\" + str(j) + \"]: \" + str(arr[i][j]))  # Print out every value as it's calculated so you can see how it changes over time while running code and debugging it!\n\n        print()  # Print new line after every row so you can more easily view how values change over time while running code and debugging it!\n\n        print(\"------------------------\")\n\n        print()  # Print new line after every row so you can more easily view how values change over time while running code and debugging it!\n\n        print(\"------------------------\")\n\n        print()  # Print new line after every row so you can more easily view how values change over time while running code and debugging it!\n\n        print()  # Print new line after every row so you can more easily view how values change over time while running code and debugging it!\n\n        print()  # Print new line after every row so you can more easily view how values change over time while running code and debugging it!\n\n        print()  # Print new",
    "16": "\n    ",
    "17": "\n    return {i: [x for x in range(1, i+1) if not i%x] or ['None'] for i in range(n, m+1)}",
    "18": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        c = list(map(int, input().split()))\n\n        p = []\n\n        for j in range(n):\n            if a[j] == min([a[j], b[j], c[j]]):\n                p.append('a')\n            elif b[j] == min([a[j], b[j], c[j]]):\n                p.append('b')\n            else:\n                p.append('c')\n\n        for j in range(n):\n            if j == n - 1: break\n\n            if p[j] != p[j + 1]: continue\n\n            if a[j] == min([a[j], b[j], c[j]]) and a[j + 1] == min([a[j + 1], b[j + 1], c[j + 1]]):  # ab ac bc ba bc ca ac ca ab ba ac bc ca bc ab ca ba ac ab bc ba bc ca ba ca ab ac bc ab ca ac ba bc ca aa cc cc cc cc cc cc cc cc cc cc  # noqa: E501,W291,E261,E262,E262,E262,E261,W291,E501\n\n                if (p.index('b') > p.index('c')) and (p.index('b') > p.index('a')):  # noqa: E501\n\n                    temp1 = 'b'  # noqa: W291\n\n                    temp2 = 'c'  # noqa: W291\n\n                    temp3 = 'a'  # noqa: W291\n\n                elif (p.index('c') > p.index('b')) and (p.index('c') > p.index('a')):  # noqa: E501\n\n                    temp1 = 'c'  # noqa: W291\n\n                    temp2 = 'b'  # noqa: W291\n\n                    temp3 = 'a'  # noqa: W291\n\n                else:  # noqa: E501\n\n                    temp1 = 'a'  # noqa: W291\n\n                    temp2 = 'c'  # noqa: W291\n\n                    temp3 = 'b'  # noqa: W291\n\n                for k in range((n // 2) - 2):\n                    if k % 2 == 0 or k % 3 == 0 or k % 5 == 0 or k % 7 == 0 or k % 11 == 0 or k % 13 == 0 or k % 17 == 0 or k % 19 == 0 or k % 23 == 0 or k % 29 == 0 or k % 31 == 0 or k % 37 == 0 or k % 41==0 : continue   ##noqa E501   ##noqae261   ##noqae262   ##noqae262   ##noqae261   ##noqaw291   ##noqae501     ###w391     ###e261     ###e262     ###e262     ###e261     ###w391     ###e501       ######w391       ######e261       ######e262       ######e262       ######e261       ######w391       ######e501         #######w391         #######e261         #######e262         #######e262         #######e261         #######w391         #######e501           ########w391           ########e261           ########e262           ########e262           ########e261           ########w391           ########e501             : continue      ##noqaw 291      ##noqae 261      ##noqae 262      ##noqae 262      ##noqae 261      ##now 291      ##noe 501          ### w 291          ### e 261          ### e 262          ### e 262          ### e 261          ### w 291          ### e 501              ### w 291              ### e 261              ### e 262              ### e 262              ### e 261              ### w 291              ### e 501                  : continue    ##now 291    ##noe 261    ##noe 262    ##noe 262    ##noe 261    ##now 291    ##noe 501                                                                                                                                                                     : continue   \\\\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\\\\\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\\\\\\\\\\\ ////\\\\\\\\//\\\\\\\\",
    "19": "\n    test_cases = int(input())\n    for _ in range(test_cases):\n        n = int(input())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        c = list(map(int, input().split()))\n\n        p = [0] * n\n\n        for i in range(n):\n            if a[i] == b[i]:\n                p[i] = c[i]\n            elif a[i] == c[i]:\n                p[i] = b[i]\n            else:  # b[i] == c[i]:\n                p[i] = a[i]\n\n            if i > 0 and p[i - 1] == p[i]:  # check for adjacent elements equality. If they are equal then we need to change the value of the previous element. We can do it only if the previous element is not equal to the first element of the sequence. Because if it is equal then we will get an endless loop. So we need to change it only if it is not equal to the first element of the sequence. And this condition is fulfilled only when i > 0 (the first element cannot be changed). Also we can't change the first element because it's already correct. So we need to change only elements that are not equal to their neighbours (except for the last one). And this condition is fulfilled only when i < n - 1 (the last element cannot be changed). So we need to check that i < n - 1 and also that i > 0 (because otherwise we will get an endless loop). Also note that in this case we don't need to check whether two adjacent elements are equal or not because they can't be equal since they have different values. So there is no point in doing this check here. We just need to change their values and continue checking from the next position. This way we will find all possible sequences with no two adjacent elements being equal and return any of them as an answer. \n                p[i - 1], p[i] = p[i], p[i - 1]\n\n        print(*p)\n\n        \n\n        \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    "
}