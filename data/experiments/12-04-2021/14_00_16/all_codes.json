{
    "0": "\n    n = int(input())\n    adj_list = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n\n    v = list(map(int, input().split()))\n\n    def dfs(node, parent):\n        global min_moves\n        if len(adj_list[node]) == 1 and parent != -1: # leaf node\n            min_moves += abs(v[node] - v[parent])\n            return\n\n        for child in adj_list[node]:\n            if child != parent: # not the parent of this node (the only connection to the root) \n                dfs(child, node)\n\n    min_moves = 0  # number of moves needed to make all integers equal to zero \n\n    dfs(0, -1) # start from the root node (index 0)\n\n    print (min_moves)",
    "1": "\n    n = int(input())\n    graph = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    v = list(map(int, input().split()))\n\n    def dfs_count_paths(graph, start):\n        visited = [False] * len(graph)\n        stack = [start]\n        count = 0\n\n        while stack:\n            node = stack.pop()\n\n            if not visited[node]:\n                visited[node] = True\n\n                for child in graph[node]:\n                    if not visited[child]:\n                        stack.append(child)\n\n                count += 1\n\n        return count - 1\n\n    def dfs_sum_paths_values(graph, start):\n        visited = [False] * len(graph)\n        stack = [start]\n        summa = 0\n\n        while stack:\n            node = stack.pop()\n\n            if not visited[node]:\n                visited[node] = True\n\n                for child in graph[node]:\n                    if not visited[child]:  # \u0435\u0441\u043b\u0438 \u043d\u0435 \u043f\u043e\u0441\u0435\u0449\u0430\u043b\u0438 \u0442\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u0441\u0442\u0435\u043a \u0438 \u0441\u0443\u043c\u043c\u0438\u0440\u0443\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432\u0435\u0440\u0448\u0438\u043d\u044b + \u0441\u0443\u043c\u043c\u0430\u0440\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044f (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f) + 1 (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f) - 1 (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f) + 1 (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f) - 1 (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f) + 1 (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f) - 1 (\u0434\u043b\u044f \u0443\u043f\u0440\u043e\u0449\u0435\u043d\u0438\u044f)) # TODO: fix this shit! it's ugly! but works... I think... I hope... I'm tired... and it's late... :( :( :( :( :( :( :( :( :( :) :) :) :) :) :) :) :) :) :) :) :) :)",
    "2": "\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    ans = 0\n    for i in range(n-1):\n        ans += abs(arr[i] - arr[i+1])\n    print(ans)\n\n",
    "3": "\n    n = int(input())\n    strengths = list(map(int, input().split()))\n    strengths.sort()\n    revenue = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            revenue += abs(strengths[i] - strengths[j])\n\n    print(revenue)",
    "4": "\n    q = int(input())\n    for i in range(q):\n        c, m, x = map(int, input().split())\n        print((c+m+x)//3)\n\n",
    "5": "\n    q = int(input())\n    for i in range(q):\n        c, m, x = map(int, input().split())\n        if c == 0:\n            print(0)\n        elif m == 0:\n            print(c)\n        elif x == 0:\n            print(c * m // 3)\n        else:\n            if c >= 2 and m >= 1 and x >= 1:  # 1st team of 2 coders and 1 mathematician. 2nd team of 1 coder and 2 mathematicians. 3rd team of 1 coder, 1 mathematician and 1 without specialization.  The rest can't form any team.  So the answer is 3.  If there are no students without any specialization then the answer is also 3.  If there are no mathematicians then the answer is also 3.  If there are no coders then the answer is also 3.  If there are no students at all then the answer is also 3.  \n                print(3)\n\n            elif c >= 2 and m == 0 and x >= 1:  # All teams can be formed with only coders and at least one student without any specialization (1st team of 2 coders, 2nd team of 1 coder). The rest can't form any team so the answer is 2.  \n                print(2)\n\n            elif c == 0 or m == 0 or x == 0:  # No teams can be formed so the answer is 0.  \n                print(0)\n\n            else:  # There's only one student without any specialization so he/she has to be in a team by him/herself (1st team consists of only that student). The rest can't form any other teams so the answer is 1.  \n                print(1)",
    "6": "\n    # The number of lines to be printed\n    num_lines = int(input())\n\n    # The text to be printed\n    text = []\n\n    for i in range(num_lines):\n        line = input()\n        text.append(line)\n\n    # Print the text in reverse order\n    for i in range(num_lines):\n        print(text[-i-1])",
    "7": "\n    n = int(input())\n    for i in range(n):\n        line = input()\n        words = line.split()\n        words.reverse()\n        print(\" \".join(words))",
    "8": "\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    K = 0\n    for i in range(N):\n        if A[i] >= M:\n            break\n        for j in range(i+1, N):\n            if A[i] + A[j] >= M:\n                break\n            K += 1\n\n    print(K)\n\n    if K == 0: return\n\n    res = []\n\n    for i in range(N):\n        if A[i] >= M: break\n\n        for j in range(i+1, N):\n            if A[i] + A[j] >= M: break\n\n            res.append((A[i]+A[j])%M)\n\n    res.sort()\n\n    print(*res)",
    "9": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    res = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            res.add((a[i]+a[j])%m)\n\n    print(len(res))\n    print(*sorted(res))",
    "10": "\n    return len(args)",
    "11": "\n    return len(args) + len(kwargs)",
    "12": "\n    if len(word) > 3:\n        return word[1:] + word[0] + 'ay'\n    else:\n        return word",
    "13": "\n    if len(word) > 3:\n        return word[1:] + word[0] + 'ay'\n    else:\n        return word",
    "14": "\n    t = int(input())\n    for i in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        if k >= n:\n            print(max(a) - min(a))\n            continue\n\n        dp = [[0] * (k + 1) for _ in range(n)]\n\n        for i in range(n):\n            dp[i][1] = a[i]\n\n        for j in range(1, k + 1):\n            for i in range(j - 1, n):\n                if i == j - 1:\n                    dp[i][j] = max([dp[i][j - 1], a[i]])\n\n                elif i > j - 1:\n                    dp[i][j] = max([dp[x][j - 1] + a[i] for x in range(j - 1, i)])\n\n                else:  # i < j-1:\n                    dp[i][j] = max([dp[x][j - 1] + a[i] for x in range(0, i)])\n\n        print((max([dp[x][k] for x in range(n)])))",
    "15": "\n    t = int(input())\n    for i in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        if k >= n:\n            print(max(a) - min(a))\n            continue\n\n        dp = [[0] * (k + 1) for _ in range(n)]\n\n        for i in range(n):\n            dp[i][1] = a[i]\n\n        for j in range(1, k + 1):\n            for i in range(n):\n                if i == 0:\n                    dp[i][j] = max([dp[i][j - 1], dp[i + 1][j - 1]]) - a[i]\n\n                elif i == n - 1:\n                    dp[i][j] = max([dp[i][j - 1], dp[i - 1][j - 1]]) - a[i]\n\n                else:\n                    dp[i][j] = max([dp[i][j - 1], min([dp[i + 1][j - 1], dp[i - 1][j - 1]])]) \\\n                               - a[i]\n\n        print(max([dp[_][k] for _ in range(n)]))",
    "16": "\n    n, k = map(int, input().split())\n    # n = number of elements in multiset\n    # k = sum of elements in multiset\n\n    # The number of ways to choose a subset of size n from a set of size k is given by the binomial coefficient.\n    # The binomial coefficient is defined as: (n choose k) = n! / (k! * (n-k)!)\n    # This can be calculated using the following formula: (n choose k) = (n-1 choose k-1) + (n-1 choose k)\n    # This can be calculated using the following formula: (n choose k) = ((n-1)! / ((k-1)! * (n-k)!)) + ((n-1)! / ((k)! * (n-k-1)!))\n\n    # We will use memoization to speed up our calculations. We will store all values in a dictionary.\n\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    def binomial_coefficient(a, b):\n        if b > a - b:  # For smaller intermediate values, use this line. This will give us time complexity O(N^2).\n            return int(factorial(a)/(factorial(b)*factorial(a - b)))  # Calculate the binomial coefficient for these values.\n\n        else:  # For larger intermediate values, use this line. This will give us time complexity O(N).\n            return int((factorial(a - 1)/((factorial(b - 1))*factorial((a - 1) - b))))  # Calculate the binomial coefficient for these values.\n\n    def count_ways():  # Function to count the number of ways to create an array with N elements with sum K.\n\n        if n == 0 and k == 0:  # If there are no elements and sum is zero, there is only one way to do so which is an empty array. Return 1 since we are considering it modulo 998244353.\n            return 1\n\n        elif n < 0 or k < 0:  # If there are negative numbers in N or K, then there are no ways to create such an array since it doesn't satisfy our conditions. Return 0 since we are considering it modulo 998244353.\n            return 0\n\n        elif dp[str([n, k])] != None:  # If we have already calculated the value for these particular inputs before, then simply retrieve it from our dictionary instead of re-calculating it again which would result in exponential time complexity. Return that value since we are considering it modulo 998244353.\n            return dp[str([n, k])]\n\n        else:  # If we haven't calculated this value before, then calculate and store it in our dictionary before returning it since we are considering it modulo 998244353. Also note that we need not worry about integer overflow here because even if python tries to convert a very large integer into a long integer by default due to lack of space for larger integers, python automatically uses arbitrary precision arithmetic which allows us to store arbitrarily large integers without any errors occurring due to overflow/underflow etc., thus ensuring that our answer remains correct even when python converts our answer into a long integer due to lack of space for larger integers during calculation and also ensuring that python doesn't throw any errors when performing operations on such large integers unlike other languages like C++ etc., thus ensuring that our answer remains correct even when python converts our answer into a long integer due to lack of space for larger integers during calculation and also ensuring that python doesn't throw any errors when performing operations on such large integers unlike other languages like C++ etc., thus ensuring that our answer remains correct even when python converts our answer into a long integer due to lack of space for larger integers during calculation and also ensuring that python doesn't throw any errors when performing operations on such large integers unlike other languages like C++ etc., thus ensuring that our answer remains correct even when python converts our answer into a long integer due to lack of space for larger integers during calculation and also ensuring that python doesn't throw any errors when performing operations on such large integers unlike other languages like C++ etc., thus ensuring that our answer remains correct even when python converts our answer into a long integer due to lack of space for larger integers during calculation and also ensuring that python doesn't throw any errors when performing operations on such large integers unlike other languages like C++ etc., thus ensuring that our answer remains correct even when python converts our answer into a long integer due to lack of space for larger integers during calculation and also ensuring that python doesn't throw any errors when performing operations on",
    "17": "\n    ",
    "18": "\n        if not root:\n            return 0\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)",
    "19": "\n        if not root:\n            return 0\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"
}