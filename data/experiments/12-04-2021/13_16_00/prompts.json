{
    "0": "Python 3\n\"\"\"\nYou have to divided K equal slices of pizza to distribute among N people. Check whether these K pizza slices can be distributed equally among the N children if every child should get at least one slice. If it's possible then print \"YES\" otherwise print \"NO\".\n\n-----Input:-----\nThe first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a integers N.\nThe second line of each test case contains K.\n\n-----Output:-----\nFor each test case, print a single line containing \"YES\" if the given conditions are true else \"NO\" if the given conditions are false.\n\n-----Constraints-----\n1<=T<=10\n1<=N<=10^6\n1<=K<=10^6\n\n-----Sample Input:-----\n2\n10\n20\n12\n5\n\n-----Sample Output:-----\nYES\nNO\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nThere are total N friends went to Chef's Pizza shop. There they bought a pizza. Chef divided the pizza into K equal slices. Now you have to check whether these K pizza slices can be distributed equally among the friends. Also given that every person should get at least one slice. If the above conditions are possible then print \"YES\" otherwise print \"NO\".\n\n-----Input:-----\nThe first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a integers N.\nThe second line of each test case contains K.\n\n-----Output:-----\nFor each test case, print a single line containing \"YES\" if the given conditions are true else \"NO\" if the given conditions are false.\n\n-----Constraints-----\n1<=T<=10\n1<=N<=10^6\n1<=K<=10^6\n\n-----Sample Input:-----\n2\n10\n20\n12\n5\n\n-----Sample Output:-----\nYES\nNO\n\n-----EXPLANATION:-----\nExplanation case 1: since there are 10 friends and 20 pizza slice, so each can get 2 slices, so \"YES\".\nExplanation case 2: Since there are 12 friends and only 5 pizza slice, so there is no way pizza slices can be distributed equally and each friend gets at least one pizza slice, so \"NO\".\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nSome names with latin alphabets have ambiguities.\nFor example, the Berland sound u can be written in the Latin alphabet as \"u\", and can be written as \"oo\". For this reason, two words \"ulyana\" and \"oolyana\" denote the same name.\n\nThe second ambiguity is about the Berland sound h: one can use both \"h\" and \"kh\" to write it.\n\nHow many distinct names are there, if two ambiguities described above are taken into account.\n\nFor example, the following pairs of words denote the same name:  \"koouper\" and \"kuooper\". Making the replacements described above, you can make both words to be equal: \"koouper\" $\\rightarrow$ \"kuuper\" and \"kuooper\" $\\rightarrow$ \"kuuper\".  \"khun\" and \"kkkhoon\". With the replacements described above you can make both words to be equal: \"khun\" $\\rightarrow$ \"khoon\" and \"kkkhoon\" $\\rightarrow$ \"kkhoon\" $\\rightarrow$ \"khoon\". \n\nFor a given list of words, find the minimal number of groups where the words in each group denote the same name.\n\n\n-----Input-----\n\nThe first line contains integer number n (2 \u2264 n \u2264 400) \u2014 number of the words in the list.\n\nThe following n lines contain words, one word per line. Each word consists of only lowercase Latin letters. The length of each word is between 1 and 20 letters inclusive.\n\n\n-----Output-----\n\nPrint the minimal number of groups where the words in each group denote the same name.\n\n\n-----Examples-----\nInput\n10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n\nOutput\n4\n\nInput\n9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n\nOutput\n5\n\nInput\n2\nalex\nalex\n\nOutput\n1\n\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nThere are some ambiguities when one writes Berland names with the letters of the Latin alphabet.\n\nFor example, the Berland sound u can be written in the Latin alphabet as \"u\", and can be written as \"oo\". For this reason, two words \"ulyana\" and \"oolyana\" denote the same name.\n\nThe second ambiguity is about the Berland sound h: one can use both \"h\" and \"kh\" to write it. For example, the words \"mihail\" and \"mikhail\" denote the same name.\n\nThere are n users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account?\n\nFormally, we assume that two words denote the same name, if using the replacements \"u\"\u00a0[Image]\u00a0\"oo\" and \"h\"\u00a0[Image]\u00a0\"kh\", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements.\n\nFor example, the following pairs of words denote the same name:  \"koouper\" and \"kuooper\". Making the replacements described above, you can make both words to be equal: \"koouper\" $\\rightarrow$ \"kuuper\" and \"kuooper\" $\\rightarrow$ \"kuuper\".  \"khun\" and \"kkkhoon\". With the replacements described above you can make both words to be equal: \"khun\" $\\rightarrow$ \"khoon\" and \"kkkhoon\" $\\rightarrow$ \"kkhoon\" $\\rightarrow$ \"khoon\". \n\nFor a given list of words, find the minimal number of groups where the words in each group denote the same name.\n\n\n-----Input-----\n\nThe first line contains integer number n (2 \u2264 n \u2264 400) \u2014 number of the words in the list.\n\nThe following n lines contain words, one word per line. Each word consists of only lowercase Latin letters. The length of each word is between 1 and 20 letters inclusive.\n\n\n-----Output-----\n\nPrint the minimal number of groups where the words in each group denote the same name.\n\n\n-----Examples-----\nInput\n10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n\nOutput\n4\n\nInput\n9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n\nOutput\n5\n\nInput\n2\nalex\nalex\n\nOutput\n1\n\n\n\n-----Note-----\n\nThere are four groups of words in the first example. Words in each group denote same name:  \"mihail\", \"mikhail\"  \"oolyana\", \"ulyana\"  \"kooooper\", \"koouper\"  \"hoon\", \"khun\", \"kkkhoon\" \n\nThere are five groups of words in the second example. Words in each group denote same name:  \"hariton\", \"kkkhariton\", \"khariton\"  \"hkariton\"  \"buoi\", \"boooi\", \"boui\"  \"bui\"  \"boi\" \n\nIn the third example the words are equal, so they denote the same name.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nWrite a simple regex to check if the string contains the word hello in different languages. Regex should be case insensitive to pass the tests.\n\"\"\"\ndef validate_hello(greetings):",
    "5": "Python 3\n\"\"\"\nYou received a whatsup message from an unknown number. Could it be from that girl/boy with a foreign accent you met yesterday evening?\n\nWrite a simple regex to check if the string contains the word hallo in different languages.\n\nThese are the languages of the possible people you met the night before:\n\n* hello - english\n* ciao - italian\n* salut - french\n* hallo - german\n* hola - spanish\n* ahoj - czech republic\n* czesc - polish\n\nBy the way, how cool is the czech republic hallo!!\n\n\nPS. you can assume the input is a string.\nPPS. to keep this a beginner exercise you don't need to check if the greeting is a subset of word ('Hallowen' can pass the test)\n\nPS. regex should be case insensitive to pass the tests\n\"\"\"\ndef validate_hello(greetings):",
    "6": "Python 3\n\"\"\"\nTake an integer 'n' (n >= 0) and a digit 'd' (0 <= d <= 9) as an integer. Square all numbers 'k' (0 <= k <= n) between 0 and 'n'. Count the numbers of \ndigits 'd' used in the writing of all the 'k**2'. Write the function taking 'n' and 'd' as parameters and returning this count.\n\n#Examples:\n```\nn = 10, d = 1, the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\nWe are using the digit 1 in 1, 16, 81, 100. The total count is then 4.\n\nnb_dig(25, 1):\nthe numbers of interest are\n1, 4, 9, 10, 11, 12, 13, 14, 19, 21 which squared are 1, 16, 81, 100, 121, 144, 169, 196, 361, 441\nso there are 11 digits `1` for the squares of numbers between 0 and 25.\n\n\"\"\"\ndef nb_dig(n, d):",
    "7": "Python 3\n\"\"\"\nTake an integer `n (n >= 0)` and a digit `d (0 <= d <= 9)` as an integer. Square all numbers `k (0 <= k <= n)` between 0 and n. Count the numbers of \ndigits `d` used in the writing of all the `k**2`. Call `nb_dig` (or nbDig or ...) the function taking `n` and `d` as parameters and returning this count.\n\n#Examples:\n```\nn = 10, d = 1, the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\nWe are using the digit 1 in 1, 16, 81, 100. The total count is then 4.\n\nnb_dig(25, 1):\nthe numbers of interest are\n1, 4, 9, 10, 11, 12, 13, 14, 19, 21 which squared are 1, 16, 81, 100, 121, 144, 169, 196, 361, 441\nso there are 11 digits `1` for the squares of numbers between 0 and 25.\n```\nNote that `121` has twice the digit `1`.\n\"\"\"\ndef nb_dig(n, d):",
    "8": "Python 3\n\"\"\"\nSequence t_1, t_2, ..., t_{n} is called nice if the following two conditions are satisfied:   t_{i} < t_{i} + 1 for each odd i < n;  t_{i} > t_{i} + 1 for each even i < n. \n\n\nYou have a sequence of positive integers t_1, t_2, ..., t_{n}. This sequence is not nice now and you want to fix it by a single swap. Count the number of ways to do so. Two ways are considered different if indices of elements chosen for a swap are different.\n\n\n-----Input-----\n\nThe first line of the input contains one integer n (2 \u2264 n \u2264 150 000)\u00a0\u2014 the length of the sequence.\n\nThe second line contains n integers t_1, t_2, ..., t_{n} (1 \u2264 t_{i} \u2264 150 000) \u2014 the initial sequence. It's guaranteed that the given sequence is not nice.\n\n\n-----Output-----\n\nPrint the number of ways to swap two elements exactly once in order to get a nice sequence.\n\n\n-----Examples-----\nInput\n5\n2 8 4 7 7\n\nOutput\n2\n\nInput\n4\n200 150 100 50\n\nOutput\n1\n\nInput\n10\n3 2 1 4 1 4 1 4 1 4\n\nOutput\n8\n\nInput\n9\n1 2 3 4 5 6 7 8 9\n\nOutput\n0\n\n\n\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nThe life goes up and down, just like nice sequences. Sequence t_1, t_2, ..., t_{n} is called nice if the following two conditions are satisfied:   t_{i} < t_{i} + 1 for each odd i < n;  t_{i} > t_{i} + 1 for each even i < n. \n\nFor example, sequences (2, 8), (1, 5, 1) and (2, 5, 1, 100, 99, 120) are nice, while (1, 1), (1, 2, 3) and (2, 5, 3, 2) are not.\n\nBear Limak has a sequence of positive integers t_1, t_2, ..., t_{n}. This sequence is not nice now and Limak wants to fix it by a single swap. He is going to choose two indices i < j and swap elements t_{i} and t_{j} in order to get a nice sequence. Count the number of ways to do so. Two ways are considered different if indices of elements chosen for a swap are different.\n\n\n-----Input-----\n\nThe first line of the input contains one integer n (2 \u2264 n \u2264 150 000)\u00a0\u2014 the length of the sequence.\n\nThe second line contains n integers t_1, t_2, ..., t_{n} (1 \u2264 t_{i} \u2264 150 000) \u2014 the initial sequence. It's guaranteed that the given sequence is not nice.\n\n\n-----Output-----\n\nPrint the number of ways to swap two elements exactly once in order to get a nice sequence.\n\n\n-----Examples-----\nInput\n5\n2 8 4 7 7\n\nOutput\n2\n\nInput\n4\n200 150 100 50\n\nOutput\n1\n\nInput\n10\n3 2 1 4 1 4 1 4 1 4\n\nOutput\n8\n\nInput\n9\n1 2 3 4 5 6 7 8 9\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample, there are two ways to get a nice sequence with one swap:   Swap t_2 = 8 with t_4 = 7.  Swap t_1 = 2 with t_5 = 7. \n\nIn the second sample, there is only one way\u00a0\u2014 Limak should swap t_1 = 200 with t_4 = 50.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\nYou are given a rectangular $n \\times m$ matrix $a$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want possibly zero.\n\nAfter you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $i$-th row it is equal $r_i$. What is the maximal possible value of $r_1+r_2+\\ldots+r_n$?\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 40$), the number of test cases in the input.\n\nThe first line of each test case contains integers $n$ and $m$ ($1 \\le n \\le 4$, $1 \\le m \\le 100$) \u2014 the number of rows and the number of columns in the given matrix $a$. \n\nEach of the following $n$ lines contains $m$ integers, the elements of $a$ ($1 \\le a_{i, j} \\le 10^5$).\n\n\n-----Output-----\n\nPrint $t$ integers: answers for all test cases in the order they are given in the input.\n\n\n-----Example-----\nInput\n2\n2 3\n2 5 7\n4 2 4\n3 6\n4 1 5 2 10 4\n8 6 6 4 9 10\n5 4 9 5 8 7\n\nOutput\n12\n29\n\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nThis is an easier version of the next problem. The difference is only in constraints.\n\nYou are given a rectangular $n \\times m$ matrix $a$. In one move you can choose any column and cyclically shift elements in this column. You can perform this operation as many times as you want (possibly zero). You can perform this operation to a column multiple times.\n\nAfter you are done with cyclical shifts, you compute for every row the maximal value in it. Suppose that for $i$-th row it is equal $r_i$. What is the maximal possible value of $r_1+r_2+\\ldots+r_n$?\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 40$), the number of test cases in the input.\n\nThe first line of each test case contains integers $n$ and $m$ ($1 \\le n \\le 4$, $1 \\le m \\le 100$) \u2014 the number of rows and the number of columns in the given matrix $a$. \n\nEach of the following $n$ lines contains $m$ integers, the elements of $a$ ($1 \\le a_{i, j} \\le 10^5$).\n\n\n-----Output-----\n\nPrint $t$ integers: answers for all test cases in the order they are given in the input.\n\n\n-----Example-----\nInput\n2\n2 3\n2 5 7\n4 2 4\n3 6\n4 1 5 2 10 4\n8 6 6 4 9 10\n5 4 9 5 8 7\n\nOutput\n12\n29\n\n\n\n-----Note-----\n\nIn the first test case, you can shift the third column down by one, this way there will be $r_1 = 5$ and $r_2 = 7$.\n\nIn the second case you can don't rotate anything at all, this way there will be $r_1 = r_2 = 10$ and $r_3 = 9$.\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\nWrite a program to check for a given unweighted, undirected graph whether it's a tree topology or not.\n\n-----Input-----\n\nThe first line of the input file contains two integers N and M --- number of nodes and number of edges in the graph (0 < N <= 10000, 0 <= M <= 20000). Next M lines contain M edges of that graph --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 <= u,v <= N).\n\n-----Output-----\n\nPrint YES if the given graph is a tree, otherwise print NO.\n\n-----Example-----\nInput:\n3 2\n1 2\n2 3\n\nOutput:\nYES\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nYou are given an unweighted, undirected graph. Write a program to check if it's a tree topology.\n\n-----Input-----\n\nThe first line of the input file contains two integers N and M --- number of nodes and number of edges in the graph (0 < N <= 10000, 0 <= M <= 20000). Next M lines contain M edges of that graph --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 <= u,v <= N).\n\n-----Output-----\n\nPrint YES if the given graph is a tree, otherwise print NO.\n\n-----Example-----\nInput:\n3 2\n1 2\n2 3\n\nOutput:\nYES\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nYou are given N encrypted sentences whose characters are in ASCCI code. Write a code to convert ASCCI code into their corresponding characters.\n\n\n-----Input-----\nThe input will consist of the first line containing the number of test cases \u2018n\u2019 followed by n lines of test cases.\n\n-----Output-----\n\nFor each input print the decoded line.\n\n-----Example-----\nInput:\n2\n721011081081113287111114108100\n871011089911110910132116111327311010010597\n\nOutput:\nHello World\nWelcome to India\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nAt the legendary times of Nonsenso wars in ISM Dhanbad, there was a neck to neck competition between Barney Stinson and Sheldon Cooper. They both were on level 19. After trying too hard both of them could not decipher the nonsense, so they decided to play alongside. Sheldon Cooper had to pass a message to Barney Stinson. So he decided to convert each letter of the sentence to their corresponding to their ASCII codes. When Barney received the message he could not get anything. Now you have to design a code which converts the encrypted message to readable format.\n\n-----Input-----\nThe input will consist of the first line containing the number of test cases \u2018n\u2019 followed by n lines of test cases.\n\n-----Output-----\n\nFor each input print the decoded line.\n\n-----Example-----\nInput:\n2\n721011081081113287111114108100\n871011089911110910132116111327311010010597\n\nOutput:\nHello World\nWelcome to India\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nFailed Sort - Bug Fixing #4\nYour task is to fix the function to sort all numbers in ascending order\n\"\"\"\ndef sort_array(value):",
    "17": "Python 3\n\"\"\"\nFailed Sort - Bug Fixing #4\nOh no, Timmy's Sort doesn't seem to be working? Your task is to fix the sortArray function to sort all numbers in ascending order\n\"\"\"\ndef sort_array(value):",
    "18": "Python 3\n\"\"\"\nYou are given an array of integers. You need to compute the bitwise XOR of all pariwise sums.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\leq n \\leq 400\\,000$)\u00a0\u2014 the number of integers in the array.\n\nThe second line contains integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^7$).\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 xor of all pairwise sums of integers in the given array.\n\n\n-----Examples-----\nInput\n2\n1 2\n\nOutput\n3\nInput\n3\n1 2 3\n\nOutput\n2\n\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nCatherine received an array of integers as a gift for March 8. Eventually she grew bored with it, and she started calculated various useless characteristics for it. She succeeded to do it for each one she came up with. But when she came up with another one\u00a0\u2014 xor of all pairwise sums of elements in the array, she realized that she couldn't compute it for a very large array, thus she asked for your help. Can you do it? Formally, you need to compute\n\n$$ (a_1 + a_2) \\oplus (a_1 + a_3) \\oplus \\ldots \\oplus (a_1 + a_n) \\\\ \\oplus (a_2 + a_3) \\oplus \\ldots \\oplus (a_2 + a_n) \\\\ \\ldots \\\\ \\oplus (a_{n-1} + a_n) \\\\ $$\n\nHere $x \\oplus y$ is a bitwise XOR operation (i.e. $x$ ^ $y$ in many modern programming languages). You can read about it in Wikipedia: https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\leq n \\leq 400\\,000$)\u00a0\u2014 the number of integers in the array.\n\nThe second line contains integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^7$).\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 xor of all pairwise sums of integers in the given array.\n\n\n-----Examples-----\nInput\n2\n1 2\n\nOutput\n3\nInput\n3\n1 2 3\n\nOutput\n2\n\n\n-----Note-----\n\nIn the first sample case there is only one sum $1 + 2 = 3$.\n\nIn the second sample case there are three sums: $1 + 2 = 3$, $1 + 3 = 4$, $2 + 3 = 5$. In binary they are represented as $011_2 \\oplus 100_2 \\oplus 101_2 = 010_2$, thus the answer is 2.\n\n$\\oplus$ is the bitwise xor operation. To define $x \\oplus y$, consider binary representations of integers $x$ and $y$. We put the $i$-th bit of the result to be 1 when exactly one of the $i$-th bits of $x$ and $y$ is 1. Otherwise, the $i$-th bit of the result is put to be 0. For example, $0101_2 \\, \\oplus \\, 0011_2 = 0110_2$.\n\"\"\"\ndef code():"
}