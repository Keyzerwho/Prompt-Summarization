{
    "0": "Python 3\n\"\"\"\nYou are given a sequence a = \\{a_1, ..., a_N\\} with all zeros, and a sequence b = \\{b_1, ..., b_N\\} consisting of 0 and 1. The length of both is N.\nYou can perform Q kinds of operations. The i-th operation is as follows:\n - Replace each of a_{l_i}, a_{l_i + 1}, ..., a_{r_i} with 1.\nMinimize the hamming distance between a and b.\n\n-----Constraints-----\n - 1 \\leq N \\leq 200,000\n - b consists of 0 and 1.\n - 1 \\leq Q \\leq 200,000\n - 1 \\leq l_i \\leq r_i \\leq N\n - If i \\neq j, either l_i \\neq l_j or r_i \\neq r_j.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nb_1 b_2 ... b_N\nQ\nl_1 r_1\nl_2 r_2\n:\nl_Q r_Q\n\n-----Output-----\nPrint the minimum possible hamming distance.\n\n-----Sample Input-----\n3\n1 0 1\n1\n1 3\n\n-----Sample Output-----\n1\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nYou are given a sequence a = \\{a_1, ..., a_N\\} with all zeros, and a sequence b = \\{b_1, ..., b_N\\} consisting of 0 and 1. The length of both is N.\nYou can perform Q kinds of operations. The i-th operation is as follows:\n - Replace each of a_{l_i}, a_{l_i + 1}, ..., a_{r_i} with 1.\nMinimize the hamming distance between a and b, that is, the number of i such that a_i \\neq b_i, by performing some of the Q operations.\n\n-----Constraints-----\n - 1 \\leq N \\leq 200,000\n - b consists of 0 and 1.\n - 1 \\leq Q \\leq 200,000\n - 1 \\leq l_i \\leq r_i \\leq N\n - If i \\neq j, either l_i \\neq l_j or r_i \\neq r_j.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nb_1 b_2 ... b_N\nQ\nl_1 r_1\nl_2 r_2\n:\nl_Q r_Q\n\n-----Output-----\nPrint the minimum possible hamming distance.\n\n-----Sample Input-----\n3\n1 0 1\n1\n1 3\n\n-----Sample Output-----\n1\n\nIf you choose to perform the operation, a will become \\{1, 1, 1\\}, for a hamming distance of 1.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nAn array of integers $p_{1},p_{2}, \\ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once.\n\nThere is a hidden permutation of length $n$.\n\nFor each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$.\n\nYour task is to restore the permutation.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the size of the permutation.\n\nThe second line contains $n$ integers $s_{1}, s_{2}, \\ldots, s_{n}$ ($0 \\le s_{i} \\le \\frac{n(n-1)}{2}$).\n\nIt is guaranteed that the array $s$ corresponds to a valid permutation of length $n$.\n\n\n-----Output-----\n\nPrint $n$ integers $p_{1}, p_{2}, \\ldots, p_{n}$ \u2014 the elements of the restored permutation. We can show that the answer is always unique.\n\n\n-----Examples-----\nInput\n3\n0 0 0\n\nOutput\n3 2 1\n\nInput\n2\n0 1\n\nOutput\n1 2\n\nInput\n5\n0 1 1 1 10\n\nOutput\n1 4 3 2 5\n\n\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nAn array of integers $p_{1},p_{2}, \\ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once. For example, the following arrays are permutations: $[3,1,2], [1], [1,2,3,4,5]$ and $[4,3,1,2]$. The following arrays are not permutations: $[2], [1,1], [2,3,4]$.\n\nThere is a hidden permutation of length $n$.\n\nFor each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$. In other words, $s_i$ is the sum of elements before the $i$-th element that are smaller than the $i$-th element.\n\nYour task is to restore the permutation.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{5}$)\u00a0\u2014 the size of the permutation.\n\nThe second line contains $n$ integers $s_{1}, s_{2}, \\ldots, s_{n}$ ($0 \\le s_{i} \\le \\frac{n(n-1)}{2}$).\n\nIt is guaranteed that the array $s$ corresponds to a valid permutation of length $n$.\n\n\n-----Output-----\n\nPrint $n$ integers $p_{1}, p_{2}, \\ldots, p_{n}$ \u2014 the elements of the restored permutation. We can show that the answer is always unique.\n\n\n-----Examples-----\nInput\n3\n0 0 0\n\nOutput\n3 2 1\n\nInput\n2\n0 1\n\nOutput\n1 2\n\nInput\n5\n0 1 1 1 10\n\nOutput\n1 4 3 2 5\n\n\n\n-----Note-----\n\nIn the first example for each $i$ there is no index $j$ satisfying both conditions, hence $s_i$ are always $0$.\n\nIn the second example for $i = 2$ it happens that $j = 1$ satisfies the conditions, so $s_2 = p_1$.\n\nIn the third example for $i = 2, 3, 4$ only $j = 1$ satisfies the conditions, so $s_2 = s_3 = s_4 = 1$. For $i = 5$ all $j = 1, 2, 3, 4$ are possible, so $s_5 = p_1 + p_2 + p_3 + p_4 = 10$.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nYou've got array A, consisting of n integers and a positive integer k.\n\nYou need to permute the array elements so that value $\\sum_{i = 1}^{n - k}|A [ i ] - A [ i + k ]|$ became as minimal as possible. It is not allowed to change order of elements at all.\n\n\n-----Input-----\n\nThe first line contains two integers n, k (2 \u2264 n \u2264 3\u00b710^5, 1 \u2264 k \u2264 min(5000, n - 1)). \n\nThe second line contains n integers A[1], A[2], ..., A[n] ( - 10^9 \u2264 A[i] \u2264 10^9), separate by spaces \u2014 elements of the array A.\n\n\n-----Output-----\n\nPrint the minimum possible value of the sum described in the statement.\n\n\n-----Examples-----\nInput\n3 2\n1 2 4\n\nOutput\n1\n\nInput\n5 2\n3 -5 3 -5 3\n\nOutput\n0\n\nInput\n6 3\n4 3 4 3 2 5\n\nOutput\n3\n\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nYou've got array A, consisting of n integers and a positive integer k. Array A is indexed by integers from 1 to n.\n\nYou need to permute the array elements so that value $\\sum_{i = 1}^{n - k}|A [ i ] - A [ i + k ]|$ became minimal possible. In particular, it is allowed not to change order of elements at all.\n\n\n-----Input-----\n\nThe first line contains two integers n, k (2 \u2264 n \u2264 3\u00b710^5, 1 \u2264 k \u2264 min(5000, n - 1)). \n\nThe second line contains n integers A[1], A[2], ..., A[n] ( - 10^9 \u2264 A[i] \u2264 10^9), separate by spaces \u2014 elements of the array A.\n\n\n-----Output-----\n\nPrint the minimum possible value of the sum described in the statement.\n\n\n-----Examples-----\nInput\n3 2\n1 2 4\n\nOutput\n1\n\nInput\n5 2\n3 -5 3 -5 3\n\nOutput\n0\n\nInput\n6 3\n4 3 4 3 2 5\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first test one of the optimal permutations is 1\u00a04\u00a02. \n\nIn the second test the initial order is optimal. \n\nIn the third test one of the optimal permutations is 2\u00a03\u00a04\u00a04\u00a03\u00a05.\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nyou wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. you can only hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $n$ favorite numbers: $a_1, a_2, \\ldots, a_n$. What is the minimum number of hops you need to move from $(0,0)$ to $(x,0)$? you may land on points with non-integer coordinates. It can be proved that you can always reach his destination.\n\nRecall that the Euclidean distance between points $(x_i, y_i)$ and $(x_j, y_j)$ is $\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$.\n\nFor example, if you have favorite numbers $1$ and $3$ he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)$ $\\rightarrow$ $(2,-\\sqrt{5})$ $\\rightarrow$ $(4,0)$).\n\n $1$ Here is a graphic for the first example. Both hops have distance $3$, one of your favorite numbers. \n\nIn other words, each time you chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 1000$) \u00a0\u2014 the number of test cases. Next $2t$ lines contain test cases \u2014 two lines per test case.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5$, $1 \\le x \\le 10^9$) \u00a0\u2014 the number of favorite numbers and the distance Rabbit wants to travel, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u00a0\u2014 Rabbit's favorite numbers. It is guaranteed that the favorite numbers are distinct.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of hops needed.\n\n\n-----Example-----\nInput\n4\n2 4\n1 3\n3 12\n3 4 5\n1 5\n5\n2 10\n15 4\n\nOutput\n2\n3\n1\n2\n\n\n\n-----Note-----\n\nThe first test case of the sample is shown in the picture above. You can hop to $(2,\\sqrt{5})$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\n\nIn the second test case of the sample, one way for you to hop $3$ times is: $(0,0)$ $\\rightarrow$ $(4,0)$ $\\rightarrow$ $(8,0)$ $\\rightarrow$ $(12,0)$.\n\nIn the third test case of the sample, you can hop from $(0,0)$ to $(5,0)$.\n\nIn the fourth test case of the sample, you can hop: $(0,0)$ $\\rightarrow$ $(5,10\\sqrt{2})$ $\\rightarrow$ $(10,0)$.\n\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nBessie has way too many friends because she is everyone's favorite cow! Her new friend Rabbit is trying to hop over so they can play! \n\nMore specifically, he wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $n$ favorite numbers: $a_1, a_2, \\ldots, a_n$. What is the minimum number of hops Rabbit needs to get from $(0,0)$ to $(x,0)$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.\n\nRecall that the Euclidean distance between points $(x_i, y_i)$ and $(x_j, y_j)$ is $\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$.\n\nFor example, if Rabbit has favorite numbers $1$ and $3$ he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)$ $\\rightarrow$ $(2,-\\sqrt{5})$ $\\rightarrow$ $(4,0)$).\n\n $1$ Here is a graphic for the first example. Both hops have distance $3$, one of Rabbit's favorite numbers. \n\nIn other words, each time Rabbit chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 1000$) \u00a0\u2014 the number of test cases. Next $2t$ lines contain test cases \u2014 two lines per test case.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5$, $1 \\le x \\le 10^9$) \u00a0\u2014 the number of favorite numbers and the distance Rabbit wants to travel, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) \u00a0\u2014 Rabbit's favorite numbers. It is guaranteed that the favorite numbers are distinct.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer\u00a0\u2014 the minimum number of hops needed.\n\n\n-----Example-----\nInput\n4\n2 4\n1 3\n3 12\n3 4 5\n1 5\n5\n2 10\n15 4\n\nOutput\n2\n3\n1\n2\n\n\n\n-----Note-----\n\nThe first test case of the sample is shown in the picture above. Rabbit can hop to $(2,\\sqrt{5})$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\n\nIn the second test case of the sample, one way for Rabbit to hop $3$ times is: $(0,0)$ $\\rightarrow$ $(4,0)$ $\\rightarrow$ $(8,0)$ $\\rightarrow$ $(12,0)$.\n\nIn the third test case of the sample, Rabbit can hop from $(0,0)$ to $(5,0)$.\n\nIn the fourth test case of the sample, Rabbit can hop: $(0,0)$ $\\rightarrow$ $(5,10\\sqrt{2})$ $\\rightarrow$ $(10,0)$.\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\nYou are given an array of unique salaries.\nReturn the average of salaries excluding the minimum and maximum salary.\n\u00a0\nExample 1:\nInput: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum and maximum salary are 1000 and 4000 respectively.\n\nExample 2:\nInput: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum and maximum salary are 1000 and 3000 respectively.\n\nExample 3:\nInput: salary = [6000,5000,4000,3000,2000,1000]\nOutput: 3500.00000\n\nExample 4:\nInput: salary = [8000,9000,2000,3000,6000,1000]\nOutput: 4750.00000\n\n\u00a0\nConstraints:\n\n3 <= salary.length <= 100\n10^3\u00a0<= salary[i] <= 10^6\nAnswers within 10^-5 of the actual value will be accepted as correct.\n\"\"\"\nclass Solution:\n    def average(self, salary: List[int]) -> float:",
    "9": "Python 3\n\"\"\"\nGiven an array of unique integers salary\u00a0where salary[i] is the salary of the employee i.\nReturn the average salary of employees excluding the minimum and maximum salary.\n\u00a0\nExample 1:\nInput: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000)/2= 2500\n\nExample 2:\nInput: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000)/1= 2000\n\nExample 3:\nInput: salary = [6000,5000,4000,3000,2000,1000]\nOutput: 3500.00000\n\nExample 4:\nInput: salary = [8000,9000,2000,3000,6000,1000]\nOutput: 4750.00000\n\n\u00a0\nConstraints:\n\n3 <= salary.length <= 100\n10^3\u00a0<= salary[i] <= 10^6\nsalary[i] is unique.\nAnswers within 10^-5 of the actual value will be accepted as correct.\n\"\"\"\nclass Solution:\n    def average(self, salary: List[int]) -> float:",
    "10": "Python 3\n\"\"\"\nYou are given a chessboard of any size from 1 to 10, where columns are marked with letters a-j and rows with 1-0 (tenth row is marked with 0).\nThe input given is the position of one queen on the chess board.\nYour need to return remaining queens positions such that none of the queens are attacking each other.\n\n\"\"\"\ndef queens(position, size):",
    "11": "Python 3\n\"\"\"\nBased on the well known ['Eight Queens' problem](https://en.wikipedia.org/wiki/Eight_queens_puzzle).\n\n#### Summary\nYour challenge is to place N queens on a chess board such that none of the queens are attacking each other.\n\n#### Details\nA standard 8x8 chess board has its rows (aka ranks) labelled 1-8 from bottom to top, and its columns (aka files) labelled a-h from left to right. Any square can be denoted by a combination of letter and number. For example, the top left square is a8. A queen may attack any square on its rank or file. It may also attack any square diagonally.\n\nIn this kata, chessboard may have any size from 1 to 10. Columns are marked with letters a-j, and rows with single digit from 1 to 0 (first row is marked with 1, ninth row is marked with 9, and tenth row is marked with 0, so `a1` denotes bottom left field of the chessboard, and `j0` - top right field on a 10x10 board).\n\nYou will be given the position of one queen on the board (e.g. `'c3'`). Your challenge is to compute the position of the remaining queens and return the full solution (including the original input) as a comma-separated string (e.g. `'d8,a7,e6,h5,b4,g3,c2,f1'`). Fields do not have to be sorted in any particular way, but you have to adhere to above format (lowercase letters, no spaces, fields separated with commas).\n\nNote that there may be multiple valid solutions for a given starting position. Your function only needs to produce (any) one of these. All given starting positions produce valid solutions.\n\nIf you wish to write more tests, the validity of a solution may be checked using preloaded function (see sample tests).\n\nHint: check the wiki article for the various algorithms that are applicable to this problem.\n\n----\nNext steps:\n - [N queens problem (with no mandatory queen position)](https://www.codewars.com/kata/52cdc1b015db27c484000031)\n - [N queens problem (with one mandatory queen position) - challenge version](https://www.codewars.com/kata/5985ea20695be6079e000003)\n\"\"\"\ndef queens(position, size):",
    "12": "Python 3\n\"\"\"\nYou have a permutation of the integers from 1 through N, p_1, p_2, .., p_N.\nYou also have M pairs of two integers between 1 and N (inclusive), represented as (x_1,y_1), (x_2,y_2), .., (x_M,y_M).\nYou are going to perform the following operation on p as many times as desired so that the number of i (1 \u2264 i \u2264 N) such that p_i = i is maximized:\n - Choose j such that 1 \u2264 j \u2264 M, and swap p_{x_j} and p_{y_j}.\nFind the maximum possible number of i such that p_i = i after operations.\n\n-----Constraints-----\n - 2 \u2264 N \u2264 10^5\n - 1 \u2264 M \u2264 10^5\n - p is a permutation of integers from 1 through N.\n - 1 \u2264 x_j,y_j \u2264 N\n - x_j \u2260 y_j\n - If i \u2260 j, \\{x_i,y_i\\} \u2260 \\{x_j,y_j\\}.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\np_1 p_2 .. p_N\nx_1 y_1\nx_2 y_2\n:\nx_M y_M\n\n-----Output-----\nPrint the maximum possible number of i such that p_i = i after operations.\n\n-----Sample Input-----\n5 2\n5 3 1 4 2\n1 3\n5 4\n\n-----Sample Output-----\n2\n\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nWe have a permutation of the integers from 1 through N, p_1, p_2, .., p_N.\nWe also have M pairs of two integers between 1 and N (inclusive), represented as (x_1,y_1), (x_2,y_2), .., (x_M,y_M).\nAtCoDeer the deer is going to perform the following operation on p as many times as desired so that the number of i (1 \u2264 i \u2264 N) such that p_i = i is maximized:\n - Choose j such that 1 \u2264 j \u2264 M, and swap p_{x_j} and p_{y_j}.\nFind the maximum possible number of i such that p_i = i after operations.\n\n-----Constraints-----\n - 2 \u2264 N \u2264 10^5\n - 1 \u2264 M \u2264 10^5\n - p is a permutation of integers from 1 through N.\n - 1 \u2264 x_j,y_j \u2264 N\n - x_j \u2260 y_j\n - If i \u2260 j, \\{x_i,y_i\\} \u2260 \\{x_j,y_j\\}.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\np_1 p_2 .. p_N\nx_1 y_1\nx_2 y_2\n:\nx_M y_M\n\n-----Output-----\nPrint the maximum possible number of i such that p_i = i after operations.\n\n-----Sample Input-----\n5 2\n5 3 1 4 2\n1 3\n5 4\n\n-----Sample Output-----\n2\n\nIf we perform the operation by choosing j=1, p becomes 1 3 5 4 2, which is optimal, so the answer is 2.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nYou are given 2 integer arrays of length $n$, array $x$ and array $y$. For each array, you want to make all its values equivalent\nsuch that $x_1$ = $x_2$ = $x_3$ = ... = $x_n$ and $y_1$ = $y_2$ = $y_3$ = ... = $y_n$ in the least number of moves possible.\n\nIn one move, you can decrement the value of an element by 1 at $x_i$ or $y_i$, or at both $x_i$ and $y_i$\nThe value of an element can not go below 0.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) \u2014 the length of the arrays.\nThe second line of the test case contains $n$ integers $x_1, x_2, \\dots, x_n$ ($1 \\le x_i \\le 10^9$).\nThe third line of the test case contains $n$ integers $y_1, y_2, \\dots, y_n$ ($1 \\le y_i \\le 10^9$).\n\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given values in each array.\n\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nYou have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges.\n\nDuring one move, you can choose some gift $1 \\le i \\le n$ and do one of the following operations:\n\n  eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one). \n\nOf course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero).\n\nAs said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \\dots = a_n$ and $b_1 = b_2 = \\dots = b_n$ (and $a_i$ equals $b_i$ is not necessary).\n\nYour task is to find the minimum number of moves required to equalize all the given gifts.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) \u2014 the number of gifts. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of candies in the $i$-th gift. The third line of the test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 10^9$), where $b_i$ is the number of oranges in the $i$-th gift.\n\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given gifts.\n\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:\n\n  choose the first gift and eat one orange from it, so $a = [3, 5, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 4, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 3, 6]$ and $b = [2, 2, 3]$;  choose the third gift and eat one candy and one orange from it, so $a = [3, 3, 5]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 4]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 3]$ and $b = [2, 2, 2]$.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\nCheck whether the given natural number N is divisible by the sum of its digits or not. If possible, then print \"Yes\" else \"No\".\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n16\n27\n\n-----Sample Output:-----\nNo\nYes\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nChef has a natural number N. Cheffina challenges chef to check whether the given number is divisible by the sum of its digits or not. If the given number is divisible then print \"Yes\" else \"No\".\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n16\n27\n\n-----Sample Output:-----\nNo\nYes\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n=====Problem Statement=====\nGiven a string s in lowercase, your task is to find the top three most common characters in the string and their occurance count.\nSort in descending order of occurrence count, and then by alphabetical order to break ties.\n\nFor example, GOOGLE would output\nG 2\nO 2\nE 1\n\n=====Input Format=====\nA single line of input containing the string S.\n\"\"\"\n#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\n\nif __name__ == '__main__':\n    s = input()",
    "19": "Python 3\n\"\"\"\n=====Problem Statement=====\nA newly opened multinational brand has decided to base their company logo on the three most common characters in the company name. They are now trying out various combinations of company names and logos based on this condition. Given a string s, which is the company name in lowercase letters, your task is to find the top three most common characters in the string.\nPrint the three most common characters along with their occurrence count.\nSort in descending order of occurrence count.\nIf the occurrence count is the same, sort the characters in alphabetical order.\n\nFor example, according to the conditions described above, GOOGLE would have it's logo with the letters G, O, E. \n\n=====Input Format=====\nA single line of input containing the string S.\n\n=====Constraints=====\n3\u2264len(S)\u226410^4\n\"\"\"\n#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\n\nif __name__ == '__main__':\n    s = input()"
}