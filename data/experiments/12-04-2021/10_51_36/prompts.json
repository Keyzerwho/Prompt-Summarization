{
    "0": "Python 3\n\"\"\"\n You will be given a configuration of the school when the senior student walked from the entrance to the dormitory, as well as the configuration of the school when you start following the given instructions. You want to know if every possible sequence of instructions that led the senior student to the dormitory will also lead you to the dormitory in the configuration you walk through. \n-----Input----- The first line of input contains a single integer $n$ ($2 \\leq n \\leq 1000$), indicating the number of rooms in the school. The rooms are numbered $1$ to $n$, where room $1$ is the entrance and room $n$ is the dormitory. The next $n$ lines of input describe the configuration of the school when the senior student walked to the dormitory, followed by another $n$ lines describing the configuration of the school when you start to walk to the dormitory. The $i^\\textrm {th}$ line in the school configuration consists of four non-negative integers, indicating which room exits $1, 2, 3$ and $4$ lead to. If the room number is $0$, the corresponding exit is blocked. -----Output----- If it is not possible for the senior student to walk from the entrance to the dormitory, display Impossible. If it is possible, display Yes if you can get from the entrance to the dormitory by following any sequence of instructions taking the senior student from the entrance to the dormitory. Otherwise, display No. -----Examples----- Sample Input: 4 1 1 1 2 2 2 2 3 3 3 3 4 0 0 0 0 2 2 2 2 3 3 3 3 4 4 4 4 4 4 4 4 Sample Output: Yes\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nThe Hogwarts School of Witchcraft and Wizardry is the home of many students during the school year. The school has many rooms connected by corridors and stairs. Each room has four exits labelled by the integers $1, 2, 3$ or $4$. Some exits lead to another room, some of them are blocked, and some even lead back to the same room you just came from.\n\nNew students often have difficulty finding their way, especially since the corridors and stairs are regularly moving, disconnecting and reconnecting different rooms! Luckily, these reconfigurations only take place when no one is walking in the school. All you want to know is how to get from the entrance to the dormitory. A senior student has given you instructions as a sequence of numbers among $1, 2, 3, 4$. The first number in the sequence is the exit to take from the starting room. The second number is the exit to take from the second room in the path, and so on. If at any point the indicated exit is blocked, you go back to the entrance and give up. To be successful you must arrive at the dormitory at the end of the entire sequence. Even if it appears you have reached the dormitory before the entire sequence is followed, you are not sure if that is an illusion. Therefore you follow the entire sequence.\n\nYou carefully followed the instructions and arrived at the dormitory. However, the way the rooms are connected to each other has changed after the senior student gave you the instructions, and you just happen to arrive at the same destination even if the rooms you encountered along the way may be completely different.\n\nYou wonder if you are just lucky, or if the reconfiguration of the corridors and stairs ensures that the instructions still lead you to the same destination. Isn\u2019t that magical?\n\nYou will be given a configuration of the school when the senior student walked from the entrance to the dormitory, as well as the configuration of the school when you start following the given instructions. You want to know if every possible sequence of instructions that led the senior student to the dormitory will also lead you to the dormitory in the configuration you walk through. Both the senior student and you start walking from the entrance of the school.\n\n-----Input-----\nThe first line of input contains a single integer $n$ ($2 \\leq n \\leq 1000$), indicating the number of rooms in the school. The rooms are numbered $1$ to $n$, where room $1$ is the entrance and room $n$ is the dormitory.\n\nThe next $n$ lines of input describe the configuration of the school when the senior student walked to the dormitory, followed by another $n$ lines describing the configuration of the school when you start to walk to the dormitory.\n\nThe $i^\\textrm {th}$ line in the school configuration consists of four non-negative integers, indicating which room exits $1, 2, 3$ and $4$ lead to. If the room number is $0$, the corresponding exit is blocked.\n\n-----Output-----\nIf it is not possible for the senior student to walk from the entrance to the dormitory, display Impossible.\n\nIf it is possible, display Yes if you can get from the entrance to the dormitory by following any sequence of instructions taking the senior student from the entrance to the dormitory. Otherwise, display No.\n\n-----Examples-----\nSample Input:\n4\n1 1 1 2\n2 2 2 3\n3 3 3 4\n0 0 0 0\n2 2 2 2\n3 3 3 3\n4 4 4 4\n4 4 4 4\nSample Output:\nYes\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n Let x, y, and z, be non-negative integers. d_1 reprsents the absolute difference between x and y, and d_2 represents the absolute difference between y and z. Your goal is to figure out if d_1 and d_2 can become equivlanet after all moves have been expended. In each move, you can increment x, y, or z by 1. You will be given n, the total number of moves you're allowed, and k, the number of moves that had already been used. \n-----Input----- Input is given from Standard Input in the following format: H W a_{11} ... a_{1W} : a_{H1} ... a_{HW} -----Output----- If the objective is achievable, print the minimum necessary number of leaves to remove. Otherwise, print -1 instead. -----Sample Input----- 3 3 S.o .o. o.T -----Sample Output----- 2 Remove the upper-right and lower-left leaves.\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nThere is a pond with a rectangular shape.\nThe pond is divided into a grid with H rows and W columns of squares.\nWe will denote the square at the i-th row from the top and j-th column from the left by (i,\\ j).\nSome of the squares in the pond contains a lotus leaf floating on the water.\nOn one of those leaves, S, there is a frog trying to get to another leaf T.\nThe state of square (i,\\ j) is given to you by a character a_{ij}, as follows:\n - . : A square without a leaf.\n - o : A square with a leaf floating on the water.\n - S : A square with the leaf S.\n - T : A square with the leaf T.\nThe frog will repeatedly perform the following action to get to the leaf T: \"jump to a leaf that is in the same row or the same column as the leaf where the frog is currently located.\"\nSnuke is trying to remove some of the leaves, other than S and T, so that the frog cannot get to the leaf T.\nDetermine whether this objective is achievable. If it is achievable, find the minimum necessary number of leaves to remove.\n\n-----Constraints-----\n - 2 \u2264 H, W \u2264 100\n - a_{ij} is ., o, S or T.\n - There is exactly one S among a_{ij}.\n - There is exactly one T among a_{ij}.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nH W\na_{11} ... a_{1W}\n:\na_{H1} ... a_{HW}\n\n-----Output-----\nIf the objective is achievable, print the minimum necessary number of leaves to remove.\nOtherwise, print -1 instead.\n\n-----Sample Input-----\n3 3\nS.o\n.o.\no.T\n\n-----Sample Output-----\n2\n\nRemove the upper-right and lower-left leaves.\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\n # Task  Given a word, find the lexicographically smallest word possible. # \n-----Input----- The first and only line of input contains Mario\u2019s chosen word, a string of lowercase letters of the English alphabet with no spaces. The input word will be between $3$ and $50$ characters long (inclusive). -----Output----- Output the best word on a single line. -----Examples----- Sample Input 1: dcbagfekjih Sample Output 1: abcdefghijk Sample Input 2: mobitel Sample Output 2: bometil\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nMario is making up silly games again instead of reading Dostoevsky for school. The rules of his newest game follow. First he chooses a random word from the book. Then he splits the word in two arbitrary places to get three separate words. After that he reverses the order of the letters in each of those three words (exchanges the first and last letters, the second and second last and so on).\n\nFinally, he puts the three words back together in the same order in which they were before splitting. The goal of the game is to obtain the lexicographically smallest word possible. In other words, of all words that can be obtained by the above procedure, find one which would be earliest in a dictionary.\n\nWrite a program that plays Mario\u2019s game perfectly.\n\n-----Input-----\nThe first and only line of input contains Mario\u2019s chosen word, a string of lowercase letters of the English alphabet with no spaces.\n\nThe input word will be between $3$ and $50$ characters long (inclusive).\n\n-----Output-----\nOutput the best word on a single line.\n\n-----Examples-----\nSample Input 1:\ndcbagfekjih\nSample Output 1:\nabcdefghijk\n\nSample Input 2:\nmobitel\nSample Output 2:\nbometil\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\n Alice and Bob have a bag of fruit. They play a game where they take turns to take out a card from the bag. If the card has letter 'A', Alice takes all the fruit she has and gives it to Bob. If the card has letter 'B', Bob does the same. Find all the possible sequences of cards that Alice and Bob could have played with. \n-----Input----- The first line of the input contains two integers, x, y (1 \u2264 x, y \u2264 10^18, xy > 1) \u2014 the number of oranges and apples that were initially in the bag. -----Output----- Print any sequence of cards that would meet the problem conditions as a compressed string of characters 'A' and 'B. That means that you need to replace the segments of identical consecutive characters by the number of repetitions of the characters and the actual character. For example, string AAABAABBB should be replaced by string 3A1B2A3B, but cannot be replaced by 2A1A1B2A3B or by 3AB2A3B. See the samples for clarifications of the output format. The string that you print should consist of at most 10^6 characters. It is guaranteed that if the answer exists, its compressed representation exists, consisting of at most 10^6 characters. If there are several possible answers, you are allowed to print any of them. If the sequence of cards that meet the problem statement does not not exist, print a single word Impossible. -----Examples----- Input 1 4 Output 3B Input 2 2 Output Impossible Input 3 2 Output 1A1B -----Note----- In the first sample, if the row contained three cards with letter 'B', then Bob should give one apple to Alice three times. So, in the end of the game Alice has one orange and three apples, and Bob has one apple, in total it is one orange and four apples. In second sample, there is no answer since one card is not enough for game to finish, and two cards will produce at least three apples or three oranges. In the third sample, cards contain letters 'AB', so after removing the first card Bob has one orange and one apple, and after removal of second card Alice has two oranges and one apple. So, in total it is three oranges and two apples.\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nAlice and Bob decided to eat some fruit. In the kitchen they found a large bag of oranges and apples. Alice immediately took an orange for herself, Bob took an apple. To make the process of sharing the remaining fruit more fun, the friends decided to play a game. They put multiple cards and on each one they wrote a letter, either 'A', or the letter 'B'. Then they began to remove the cards one by one from left to right, every time they removed a card with the letter 'A', Alice gave Bob all the fruits she had at that moment and took out of the bag as many apples and as many oranges as she had before. Thus the number of oranges and apples Alice had, did not change. If the card had written letter 'B', then Bob did the same, that is, he gave Alice all the fruit that he had, and took from the bag the same set of fruit. After the last card way removed, all the fruit in the bag were over.\n\nYou know how many oranges and apples was in the bag at first. Your task is to find any sequence of cards that Alice and Bob could have played with.\n\n\n-----Input-----\n\nThe first line of the input contains two integers, x, y (1 \u2264 x, y \u2264 10^18, xy > 1) \u2014 the number of oranges and apples that were initially in the bag.\n\n\n-----Output-----\n\nPrint any sequence of cards that would meet the problem conditions as a compressed string of characters 'A' and 'B. That means that you need to replace the segments of identical consecutive characters by the number of repetitions of the characters and the actual character. For example, string AAABAABBB should be replaced by string 3A1B2A3B, but cannot be replaced by 2A1A1B2A3B or by 3AB2A3B. See the samples for clarifications of the output format. The string that you print should consist of at most 10^6 characters. It is guaranteed that if the answer exists, its compressed representation exists, consisting of at most 10^6 characters. If there are several possible answers, you are allowed to print any of them.\n\nIf the sequence of cards that meet the problem statement does not not exist, print a single word Impossible.\n\n\n-----Examples-----\nInput\n1 4\n\nOutput\n3B\n\nInput\n2 2\n\nOutput\nImpossible\n\nInput\n3 2\n\nOutput\n1A1B\n\n\n\n-----Note-----\n\nIn the first sample, if the row contained three cards with letter 'B', then Bob should give one apple to Alice three times. So, in the end of the game Alice has one orange and three apples, and Bob has one apple, in total it is one orange and four apples.\n\nIn second sample, there is no answer since one card is not enough for game to finish, and two cards will produce at least three apples or three oranges.\n\nIn the third sample, cards contain letters 'AB', so after removing the first card Bob has one orange and one apple, and after removal of second card Alice has two oranges and one apple. So, in total it is three oranges and two apples.\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\n Takahashi and Aoki are playing a stone-taking game. Initially, there are N piles of stones, and the i-th pile contains A_i stones and has an associated integer K_i. Starting from Takahashi, Takahashi and Aoki take alternate turns to perform the following operation:  - Choose a pile. If the i-th pile is selected and there are X stones left in the pile, remove some number of stones between 1 and floor(X/K_i) (inclusive) from the pile. The player who first becomes unable to perform the operation loses the game. Assuming that both players play optimally, determine the winner of the game. Here, floor(x) represents the largest integer not greater than x. -----Constraints-----  - 1 \\leq N \\leq 200  - 1 \\leq A_i,K_i \\leq 10^9  - All input values are integers.\n-----Input----- Input is given from Standard Input in the following format: N A_1 K_1 : A_N K_N -----Output----- If Takahashi will win, print Takahashi; if Aoki will win, print Aoki. -----Sample Input----- 2 5 2 3 3 -----Sample Output----- Aoki Initially, from the first pile at most floor(5/2)=2 stones can be removed at a time, and from the second pile at most floor(3/3)=1 stone can be removed at a time.  - If Takahashi first takes two stones from the first pile, from the first pile at most floor(3/2)=1 stone can now be removed at a time, and from the second pile at most floor(3/3)=1 stone can be removed at a time.  - Then, if Aoki takes one stone from the second pile, from the first pile at most floor(3/2)=1 stone can be removed at a time, and from the second pile no more stones can be removed (since floor(2/3)=0).  - Then, if Takahashi takes one stone from the first pile, from the first pile at most floor(2/2)=1 stone can now be removed at a time, and from the second pile no more stones can be removed.  - Then, if Aoki takes one stone from the first pile, from the first pile at most floor(1/2)=0 stones can now be removed at a time, and from the second pile no more stones can be removed. No more operation can be performed, thus Aoki wins. If Takahashi plays differently, Aoki can also win by play accordingly.\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nTakahashi and Aoki are playing a stone-taking game. Initially, there are N piles of stones, and the i-th pile contains A_i stones and has an associated integer K_i.\nStarting from Takahashi, Takahashi and Aoki take alternate turns to perform the following operation:\n - Choose a pile. If the i-th pile is selected and there are X stones left in the pile, remove some number of stones between 1 and floor(X/K_i) (inclusive) from the pile.\nThe player who first becomes unable to perform the operation loses the game. Assuming that both players play optimally, determine the winner of the game.\nHere, floor(x) represents the largest integer not greater than x.\n\n-----Constraints-----\n - 1 \\leq N \\leq 200\n - 1 \\leq A_i,K_i \\leq 10^9\n - All input values are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_1 K_1\n:\nA_N K_N\n\n-----Output-----\nIf Takahashi will win, print Takahashi; if Aoki will win, print Aoki.\n\n-----Sample Input-----\n2\n5 2\n3 3\n\n-----Sample Output-----\nAoki\n\nInitially, from the first pile at most floor(5/2)=2 stones can be removed at a time, and from the second pile at most floor(3/3)=1 stone can be removed at a time.\n - If Takahashi first takes two stones from the first pile, from the first pile at most floor(3/2)=1 stone can now be removed at a time, and from the second pile at most floor(3/3)=1 stone can be removed at a time.\n - Then, if Aoki takes one stone from the second pile, from the first pile at most floor(3/2)=1 stone can be removed at a time, and from the second pile no more stones can be removed (since floor(2/3)=0).\n - Then, if Takahashi takes one stone from the first pile, from the first pile at most floor(2/2)=1 stone can now be removed at a time, and from the second pile no more stones can be removed.\n - Then, if Aoki takes one stone from the first pile, from the first pile at most floor(1/2)=0 stones can now be removed at a time, and from the second pile no more stones can be removed.\nNo more operation can be performed, thus Aoki wins. If Takahashi plays differently, Aoki can also win by play accordingly.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\n Given a matrix of size N \\times N, determine the number of entries that are 0, 1, and 2. \n-----Input----- Input is given from Standard Input in the following format: N a_{1, 1} a_{1, 1} ... a_{1, N} a_{2, 1} : a_{N, 1} -----Output----- Print the number of 0's, 1's, and 2's separated by whitespaces. -----Sample Input----- 4 1 2 0 2 0 0 0 -----Sample Output----- 7 4 5 The matrix is as follows: 1 2 0 2 0 1 2 0 0 2 0 1 0 1 2 0\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nConsider an N \\times N matrix. Let us denote by a_{i, j} the entry in the i-th row and j-th column. For a_{i, j} where i=1 or j=1 holds, its value is one of 0, 1 and 2 and given in the input. The remaining entries are defined as follows:\n - a_{i,j} = \\mathrm{mex}(a_{i-1,j}, a_{i,j-1}) (2 \\leq i, j \\leq N) where \\mathrm{mex}(x, y) is defined by the following table:\\mathrm{mex}(x, y)y=0y=1y=2x=0121x=1200x=2100\nHow many entries of the matrix are 0, 1, and 2, respectively?\n\n-----Constraints-----\n - 1 \\leq N \\leq 500{,}000\n - a_{i,j}'s given in input are one of 0, 1 and 2.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_{1, 1} a_{1, 1} ... a_{1, N}\na_{2, 1}\n:\na_{N, 1}\n\n-----Output-----\nPrint the number of 0's, 1's, and 2's separated by whitespaces.\n\n-----Sample Input-----\n4\n1 2 0 2\n0\n0\n0\n\n-----Sample Output-----\n7 4 5\n\nThe matrix is as follows:\n1 2 0 2\n0 1 2 0\n0 2 0 1\n0 1 2 0\n\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\n One day Greg and his friends were walking in the forest. Overall there were n people walking, including Greg. Soon he found himself in front of a river. The guys immediately decided to get across the river. Luckily, there was a boat by the river bank, just where the guys were standing. We know that the boat can hold people with the total weight of at most k kilograms. Greg immediately took a piece of paper and listed there the weights of all people in his group (including himself). It turned out that each person weights either 50 or 100 kilograms. Now Greg wants to know what minimum number of times the boat needs to cross the river to transport the whole group to the other bank. The boat needs at least one person to navigate it from one bank to the other. As the boat crosses the river, it can have any non-zero number of passengers as long as their total weight doesn't exceed k. Also Greg is wondering, how many ways there are to transport everybody to the other side in the minimum number of boat rides. Two ways are considered distinct if during some ride they have distinct sets of people on the boat. Help Greg with this problem. \n-----Input----- The first line contains two integers n, k (1 \u2264 n \u2264 50, 1 \u2264 k \u2264 5000) \u2014 the number of people, including Greg, and the boat's weight limit. The next line contains n integers \u2014 the people's weights. A person's weight is either 50 kilos or 100 kilos. You can consider Greg and his friends indexed in some way. -----Output----- In the first line print an integer \u2014 the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1. In the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (10^9 + 7). If transporting everyone to the other bank is impossible, print integer 0. -----Examples----- Input 1 50 50 Output 1 1 Input 3 100 50 50 100 Output 5 2 Input 2 50 50 50 Output -1 0 -----Note----- In the first test Greg walks alone and consequently, he needs only one ride across the river. In the second test you should follow the plan:   transport two 50 kg. people;  transport one 50 kg. person back;  transport one 100 kg. person;  transport one 50 kg. person back;  transport two 50 kg. people.  That totals to 5 rides. Depending on which person to choose at step 2, we can get two distinct ways.\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nOne day Greg and his friends were walking in the forest. Overall there were n people walking, including Greg. Soon he found himself in front of a river. The guys immediately decided to get across the river. Luckily, there was a boat by the river bank, just where the guys were standing. We know that the boat can hold people with the total weight of at most k kilograms.\n\nGreg immediately took a piece of paper and listed there the weights of all people in his group (including himself). It turned out that each person weights either 50 or 100 kilograms. Now Greg wants to know what minimum number of times the boat needs to cross the river to transport the whole group to the other bank. The boat needs at least one person to navigate it from one bank to the other. As the boat crosses the river, it can have any non-zero number of passengers as long as their total weight doesn't exceed k.\n\nAlso Greg is wondering, how many ways there are to transport everybody to the other side in the minimum number of boat rides. Two ways are considered distinct if during some ride they have distinct sets of people on the boat.\n\nHelp Greg with this problem.\n\n \n\n\n-----Input-----\n\nThe first line contains two integers n, k (1 \u2264 n \u2264 50, 1 \u2264 k \u2264 5000) \u2014 the number of people, including Greg, and the boat's weight limit. The next line contains n integers \u2014 the people's weights. A person's weight is either 50 kilos or 100 kilos.\n\nYou can consider Greg and his friends indexed in some way.\n\n\n-----Output-----\n\nIn the first line print an integer \u2014 the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1.\n\nIn the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (10^9 + 7). If transporting everyone to the other bank is impossible, print integer 0.\n\n\n-----Examples-----\nInput\n1 50\n50\n\nOutput\n1\n1\n\nInput\n3 100\n50 50 100\n\nOutput\n5\n2\n\nInput\n2 50\n50 50\n\nOutput\n-1\n0\n\n\n\n-----Note-----\n\nIn the first test Greg walks alone and consequently, he needs only one ride across the river.\n\nIn the second test you should follow the plan:\n\n  transport two 50 kg. people;  transport one 50 kg. person back;  transport one 100 kg. person;  transport one 50 kg. person back;  transport two 50 kg. people. \n\nThat totals to 5 rides. Depending on which person to choose at step 2, we can get two distinct ways.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\n You are given a simple undirected graph with N vertices and M edges. Its vertices are numbered 1, 2, \\ldots, N and its edges are numbered 1, 2, \\ldots, M. On Vertex i (1 \\leq i \\leq N) two integers A_i and B_i are written. Edge i (1 \\leq i \\leq M) connects Vertices U_i and V_i. Snuke picks zero or more vertices and delete them. Deleting Vertex i costs A_i. When a vertex is deleted, edges that are incident to the vertex are also deleted. The score after deleting vertices is calculated as follows: \n- The score is the sum of the scores of all connected components. \n- The score of a connected component is the absolute value of the sum of B_i of the vertices in the connected component. Snuke's profit is (score) - (the sum of costs). Find the maximum possible profit Snuke can gain. \nInput \n- First line contains single integer T, No. of test case \n- Next line for every test contain case a string S \nOutput \n- Print the maximum possible profit Snuke can gain on a new line. \nConstraints \n- 1 \\leq T \\leq 10 \n- 0 \\leq len(S) \\leq 100 \n- S contain a-z and A-Z and space only \nSample Input 3 \nSample Output \n-8 \nExplanation \n- Snuke picks 0 or more vertices and delete them.\n-----Input----- Input is given from Standard Input in the following format: N M A_1 A_2 \\cdots A_N B_1 B_2 \\cdots B_N U_1 V_1 U_2 V_2 \\vdots U_M V_M -----Output----- Print the maximum possible profit Snuke can gain. -----Sample Input----- 4 4 4 1 2 3 0 2 -3 1 1 2 2 3 3 4 4 2 -----Sample Output----- 1 Deleting Vertex 2 costs 1. After that, the graph is separated into two connected components. The score of the component consisting of Vertex 1 is |0| = 0. The score of the component consisting of Vertices 3 and 4 is |(-3) + 1| = 2. Therefore, Snuke's profit is 0 + 2 - 1 = 1. He cannot gain more than 1, so the answer is 1.\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nGiven is a simple undirected graph with N vertices and M edges.\nIts vertices are numbered 1, 2, \\ldots, N and its edges are numbered 1, 2, \\ldots, M.\nOn Vertex i (1 \\leq i \\leq N) two integers A_i and B_i are written.\nEdge i (1 \\leq i \\leq M) connects Vertices U_i and V_i.\nSnuke picks zero or more vertices and delete them.\nDeleting Vertex i costs A_i.\nWhen a vertex is deleted, edges that are incident to the vertex are also deleted.\nThe score after deleting vertices is calculated as follows:\n - The score is the sum of the scores of all connected components.\n - The score of a connected component is the absolute value of the sum of B_i of the vertices in the connected component.\nSnuke's profit is (score) - (the sum of costs).\nFind the maximum possible profit Snuke can gain.\n\n-----Constraints-----\n - 1 \\leq N \\leq 300\n - 1 \\leq M \\leq 300\n - 1 \\leq A_i \\leq 10^6\n - -10^6 \\leq B_i \\leq 10^6\n - 1 \\leq U_i,V_i \\leq N\n - The given graph does not contain self loops or multiple edges.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 A_2 \\cdots A_N\nB_1 B_2 \\cdots B_N\nU_1 V_1\nU_2 V_2\n\\vdots\nU_M V_M\n\n-----Output-----\nPrint the maximum possible profit Snuke can gain.\n\n-----Sample Input-----\n4 4\n4 1 2 3\n0 2 -3 1\n1 2\n2 3\n3 4\n4 2\n\n-----Sample Output-----\n1\n\nDeleting Vertex 2 costs 1.\nAfter that, the graph is separated into two connected components.\nThe score of the component consisting of Vertex 1 is |0| = 0. The score of the component consisting of Vertices 3 and 4 is |(-3) + 1| = 2.\nTherefore, Snuke's profit is 0 + 2 - 1 = 1.\nHe cannot gain more than 1, so the answer is 1.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\n Nick has n bottles of soda left after his birthday. Each bottle is described by two values: remaining amount of soda a_{i} and bottle volume b_{i} (a_{i}   b_{i}). Nick has decided to pour all remaining soda into minimal number of bottles, moreover he has to do it as soon as possible. Nick spends x seconds to pour x units of soda from one bottle to another. Nick asks you to help him to determine k the minimal number of bottles to store all remaining soda and t the minimal time to pour soda into k bottles. A bottle can't store more soda than its volume. All remaining soda should be saved. \n-----Input----- The first line contains positive integer n (1 \u2264 n \u2264 100) \u2014 the number of bottles. The second line contains n positive integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 100), where a_{i} is the amount of soda remaining in the i-th bottle. The third line contains n positive integers b_1, b_2, ..., b_{n} (1 \u2264 b_{i} \u2264 100), where b_{i} is the volume of the i-th bottle. It is guaranteed that a_{i} \u2264 b_{i} for any i. -----Output----- The only line should contain two integers k and t, where k is the minimal number of bottles that can store all the soda and t is the minimal time to pour the soda into k bottles. -----Examples----- Input 4 3 3 4 3 4 7 6 5 Output 2 6 Input 2 1 1 100 100 Output 1 1 Input 5 10 30 5 6 24 10 41 7 8 24 Output 3 11 -----Note----- In the first example Nick can pour soda from the first bottle to the second bottle. It will take 3 seconds. After it the second bottle will contain 3 + 3 = 6 units of soda. Then he can pour soda from the fourth bottle to the second bottle and to the third bottle: one unit to the second and two units to the third. It will take 1 + 2 = 3 seconds. So, all the soda will be in two bottles and he will spend 3 + 3 = 6 seconds to do it.\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nNick has n bottles of soda left after his birthday. Each bottle is described by two values: remaining amount of soda a_{i} and bottle volume b_{i} (a_{i} \u2264 b_{i}).\n\nNick has decided to pour all remaining soda into minimal number of bottles, moreover he has to do it as soon as possible. Nick spends x seconds to pour x units of soda from one bottle to another.\n\nNick asks you to help him to determine k \u2014 the minimal number of bottles to store all remaining soda and t \u2014 the minimal time to pour soda into k bottles. A bottle can't store more soda than its volume. All remaining soda should be saved.\n\n\n-----Input-----\n\nThe first line contains positive integer n (1 \u2264 n \u2264 100) \u2014 the number of bottles.\n\nThe second line contains n positive integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 100), where a_{i} is the amount of soda remaining in the i-th bottle.\n\nThe third line contains n positive integers b_1, b_2, ..., b_{n} (1 \u2264 b_{i} \u2264 100), where b_{i} is the volume of the i-th bottle.\n\nIt is guaranteed that a_{i} \u2264 b_{i} for any i.\n\n\n-----Output-----\n\nThe only line should contain two integers k and t, where k is the minimal number of bottles that can store all the soda and t is the minimal time to pour the soda into k bottles.\n\n\n-----Examples-----\nInput\n4\n3 3 4 3\n4 7 6 5\n\nOutput\n2 6\n\nInput\n2\n1 1\n100 100\n\nOutput\n1 1\n\nInput\n5\n10 30 5 6 24\n10 41 7 8 24\n\nOutput\n3 11\n\n\n\n-----Note-----\n\nIn the first example Nick can pour soda from the first bottle to the second bottle. It will take 3 seconds. After it the second bottle will contain 3 + 3 = 6 units of soda. Then he can pour soda from the fourth bottle to the second bottle and to the third bottle: one unit to the second and two units to the third. It will take 1 + 2 = 3 seconds. So, all the soda will be in two bottles and he will spend 3 + 3 = 6 seconds to do it.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n You are given a sequence of non-negative integers. Determine the number of sequences made of n integers from 0 to 2^m - 1 that are not a wool sequence. \n-----Input----- The only line of input contains two space-separated integers n and m (1 \u2264 n, m \u2264 10^5). -----Output----- Print the required number of sequences modulo 1000000009 (10^9 + 9) on the only line of output. -----Examples----- Input 3 2 Output 6 -----Note----- Sequences of length 3 made of integers 0, 1, 2 and 3 that are not a wool sequence are (1, 3, 1), (1, 2, 1), (2, 1, 2), (2, 3, 2), (3, 1, 3) and (3, 2, 3).\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nA sequence of non-negative integers a_1, a_2, ..., a_{n} of length n is called a wool sequence if and only if there exists two integers l and r (1 \u2264 l \u2264 r \u2264 n) such that $a_{l} \\oplus a_{l + 1} \\oplus \\cdots \\oplus a_{r} = 0$. In other words each wool sequence contains a subsequence of consecutive elements with xor equal to 0.\n\nThe expression $x \\oplus y$ means applying the operation of a bitwise xor to numbers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is marked as \"^\", in Pascal \u2014 as \"xor\".\n\nIn this problem you are asked to compute the number of sequences made of n integers from 0 to 2^{m} - 1 that are not a wool sequence. You should print this number modulo 1000000009 (10^9 + 9).\n\n\n-----Input-----\n\nThe only line of input contains two space-separated integers n and m (1 \u2264 n, m \u2264 10^5).\n\n\n-----Output-----\n\nPrint the required number of sequences modulo 1000000009 (10^9 + 9) on the only line of output.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n6\n\n\n\n-----Note-----\n\nSequences of length 3 made of integers 0, 1, 2 and 3 that are not a wool sequence are (1, 3, 1), (1, 2, 1), (2, 1, 2), (2, 3, 2), (3, 1, 3) and (3, 2, 3).\n\"\"\"\ndef code():"
}