{
    "0": "Python 3\n\"\"\"\n Mirko was bored at his chemistry class, so he played Bomb Switcher on his cell phone. Unfortunately, he was spotted and was given a ridiculously heavy assignment for homework. For a given valid math expression with brackets, he must find all different expressions that can be obtained by removing valid pairs of brackets from the original expression. Two expressions are different if there is a character at which they differ. For example, given $(2+(2*2)+2)$, one can get $(2+2*2+2),$ $2+(2*2)+2$, and $2+2*2+2$. $(2+2*2)+2$ and $2+(2*2+2)$ can t be reached, since we would have to remove pairs of brackets that are not valid. More than one pairs of brackets can surround the same part of the expression.\n-----Input----- The first and only line of input contains one valid mathematical expression composed of nonnegative integers, basic arithmetic operations denoted with characters \u2018+\u2019, \u2018*\u2019, \u2018-\u2019 and \u2018/\u2019, and brackets \u2018(\u2019 and \u2018)\u2019. Given expression doesn\u2019t have more than 200 characters, and will have at least one, and no more than 10 pairs of brackets. Each expression is guaranteed to have at least one pair of brackets. -----Output----- Output all different expressions that can be obtained by removing valid pairs of brackets, sorted lexicographically. -----Examples----- Sample Input 1: (0/(0)) Sample Output 1: (0/0) 0/(0) 0/0 Sample Input 2: (2+(2*2)+2) Sample Output 2: (2+2*2+2) 2+(2*2)+2 2+2*2+2\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nMirko was bored at his chemistry class, so he played Bomb Switcher on his cell phone. Unfortunately, he was spotted and was given a ridiculously heavy assignment for homework. For a given valid math expression with brackets, he must find all different expressions that can be obtained by removing valid pairs of brackets from the original expression. Two expressions are different if there is a character at which they differ.\n\nFor example, given $(2+(2*2)+2)$, one can get $(2+2*2+2)$, $2+(2*2)+2$, and $2+2*2+2$. $(2+2*2)+2$ and $2+(2*2+2)$ can\u2019t be reached, since we would have to remove pairs of brackets that are not valid. More than one pairs of brackets can surround the same part of the expression.\n\n-----Input-----\nThe first and only line of input contains one valid mathematical expression composed of nonnegative integers, basic arithmetic operations denoted with characters \u2018+\u2019, \u2018*\u2019, \u2018-\u2019 and \u2018/\u2019, and brackets \u2018(\u2019 and \u2018)\u2019.\n\nGiven expression doesn\u2019t have more than 200 characters, and will have at least one, and no more than 10 pairs of brackets. Each expression is guaranteed to have at least one pair of brackets.\n\n-----Output-----\nOutput all different expressions that can be obtained by removing valid pairs of brackets, sorted lexicographically.\n\n-----Examples-----\nSample Input 1:\n(0/(0))\nSample Output 1:\n(0/0)\n0/(0)\n0/0\n\nSample Input 2:\n(2+(2*2)+2)\nSample Output 2:\n(2+2*2+2)\n2+(2*2)+2\n2+2*2+2\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.   \n-----Input----- Input contains a description of one transit system. The description begins with a line containing an integer $3 \\leq m \\leq 9$ indicating the number of transit stations in the system. Stations are numbered $0$ to $m-1$. The next line contains an integer $1 \\leq n \\leq m(m-1)$ indicating the number of connections that follow, one connection per line. Each connection is a pair of integers $s~ t$ ($0 \\leq s < m$, $0 \\leq t < m$, $s \\neq t$), indicating that there is a one-way connection from station $s$ to station $t$. -----Output----- Print the number of unique simple loops in the transit system. -----Examples----- Sample Input 1: 5 5 0 1 1 2 2 3 3 4 4 2 Sample Output 1: 1 Sample Input 2: 8 10 0 1 1 2 2 3 3 4 4 5 5 0 2 6 6 0 3 7 7 0 Sample Output 2: 3\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nLuke likes to ride on public transit in different cities he visits, just for fun. He tries to find unique ways to travel in loops: leaving from one transit station, traveling along the transit connections to at least one other station, and returning to the station where he started. He is finding lots of loops, and he wants to know just how many there are in different transit systems. There may be so many he won\u2019t ever have time to try them all, but he\u2019ll find some satisfaction in knowing they are there.\n\nHe\u2019s particularly interested in counting simple loops. A simple loop is a sequence of unique transit stations $t_1, t_2, \\ldots , t_ j$, where there\u2019s a way to connect directly from $t_ i$ to $t_{i+1}$ for $1 \\leq i < j$ and also from $t_ j$ to $t_1$. Of course, we can write down a simple loop starting with of the stations in the loop, therefore we consider any cyclic shift of such a sequence to be the same simple loop. However, two simple loops which visit the same set of transit stations in a different order are considered distinct.\n\nHelp Luke by writing a program to count how many unique simple loops there are in each transit system. The following figures illustrate the transit stations (numbered ovals) and one-way connections (arrows) of the sample input.  \n\n-----Input-----\nInput contains a description of one transit system. The description begins with a line containing an integer $3 \\leq m \\leq 9$ indicating the number of transit stations in the system. Stations are numbered $0$ to $m-1$. The next line contains an integer $1 \\leq n \\leq m(m-1)$ indicating the number of connections that follow, one connection per line. Each connection is a pair of integers $s~ t$ ($0 \\leq s < m$, $0 \\leq t < m$, $s \\neq t$), indicating that there is a one-way connection from station $s$ to station $t$.\n\n-----Output-----\nPrint the number of unique simple loops in the transit system.\n\n-----Examples-----\nSample Input 1:\n5\n5\n0 1\n1 2\n2 3\n3 4\n4 2\nSample Output 1:\n1\n\nSample Input 2:\n8\n10\n0 1\n1 2\n2 3\n3 4\n4 5\n5 0\n2 6\n6 0\n3 7\n7 0\nSample Output 2:\n3\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\n You are given n towns connected by n-1 two-way roads such that it's possible to get from any town to any other town.  In Treeland there are 2k universities which are located in different towns.  Recently, the president signed the decree to connect universities by high-speed network. The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable. Formally, the decree will be done!  To have the maximum sum in the budget, the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum. In other words, the total distance between universities in k pairs should be as large as possible.  Help the Ministry to find the maximum total distance. Of course, each university should be present in only one pair. Consider that all roads have the same length which is equal to 1. \n-----Input----- The first line of the input contains two integers n and k (2 \u2264 n \u2264 200 000, 1 \u2264 k \u2264 n / 2)\u00a0\u2014 the number of towns in Treeland and the number of university pairs. Consider that towns are numbered from 1 to n.  The second line contains 2k distinct integers u_1, u_2, ..., u_2k (1 \u2264 u_{i} \u2264 n)\u00a0\u2014 indices of towns in which universities are located.  The next n - 1 line contains the description of roads. Each line contains the pair of integers x_{j} and y_{j} (1 \u2264 x_{j}, y_{j} \u2264 n), which means that the j-th road connects towns x_{j} and y_{j}. All of them are two-way roads. You can move from any town to any other using only these roads.  -----Output----- Print the maximum possible sum of distances in the division of universities into k pairs. -----Examples----- Input 7 2 1 5 6 2 1 3 3 2 4 5 3 7 4 3 4 6 Output 6 Input 9 3 3 2 1 6 5 9 8 9 3 2 2 7 3 4 7 6 4 5 2 1 2 8 Output 9 -----Note----- The figure below shows one of possible division into pairs in the first test. If you connect universities number 1 and 6 (marked in red) and universities number 2 and 5 (marked in blue) by using the cable, the total distance will equal 6 which will be the maximum sum in this example.   [Image]\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nTreeland is a country in which there are n towns connected by n - 1 two-way road such that it's possible to get from any town to any other town. \n\nIn Treeland there are 2k universities which are located in different towns. \n\nRecently, the president signed the decree to connect universities by high-speed network.The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable. Formally, the decree will be done! \n\nTo have the maximum sum in the budget, the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum. In other words, the total distance between universities in k pairs should be as large as possible. \n\nHelp the Ministry to find the maximum total distance. Of course, each university should be present in only one pair. Consider that all roads have the same length which is equal to 1. \n\n\n-----Input-----\n\nThe first line of the input contains two integers n and k (2 \u2264 n \u2264 200 000, 1 \u2264 k \u2264 n / 2)\u00a0\u2014 the number of towns in Treeland and the number of university pairs. Consider that towns are numbered from 1 to n. \n\nThe second line contains 2k distinct integers u_1, u_2, ..., u_2k (1 \u2264 u_{i} \u2264 n)\u00a0\u2014 indices of towns in which universities are located. \n\nThe next n - 1 line contains the description of roads. Each line contains the pair of integers x_{j} and y_{j} (1 \u2264 x_{j}, y_{j} \u2264 n), which means that the j-th road connects towns x_{j} and y_{j}. All of them are two-way roads. You can move from any town to any other using only these roads. \n\n\n-----Output-----\n\nPrint the maximum possible sum of distances in the division of universities into k pairs.\n\n\n-----Examples-----\nInput\n7 2\n1 5 6 2\n1 3\n3 2\n4 5\n3 7\n4 3\n4 6\n\nOutput\n6\n\nInput\n9 3\n3 2 1 6 5 9\n8 9\n3 2\n2 7\n3 4\n7 6\n4 5\n2 1\n2 8\n\nOutput\n9\n\n\n\n-----Note-----\n\nThe figure below shows one of possible division into pairs in the first test. If you connect universities number 1 and 6 (marked in red) and universities number 2 and 5 (marked in blue) by using the cable, the total distance will equal 6 which will be the maximum sum in this example. \n\n [Image]\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\n You have to find the number of ways to tile a table with macarons. \nExamples----- Sample Input: 2 2 Sample Output: 7\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nPierre is famous for his macarons. He makes round macarons, stored in square boxes of size $1\\times 1$, and oval-shaped macarons, stored in rectangular boxes of size $1\\times 2$ (or, rotated, in rectangular boxes of size $2\\times 1$). For the purpose of a buffet, Pierre wishes to tile a rectangular table of size $N\\times M$ with the two kinds of macarons, meaning that the table must be completely full, with no empty space left. The width $N$ of the table is small, for the guest to be able to grab the macarons easily, and the length $M$ of the table is large, to accommodate a huge number of guests. To keep the table pretty, the orientation of macarons should always be aligned with the sides of the table.\n\nPierre wishes to know how many ways there are to tile the table. Can you help him?Input\n\nThe input consists of the following integers:\n - the value of $N$, an integer, on the first line;\n - the value of $M$, an integer, on the second line.Limits\n\nThe input satisfies $1 \\leq N \\leq 8$ and $1 \\leq M \\leq 10^{18}$.Output\n\nThe output should consist of the total number of tilings, given modulo $10^9$, on a single line.\n\n-----Examples-----\nSample Input:\n2\n2\nSample Output:\n7\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\n As a tradition, every year before IOI all the members of Natalia Fan Club are invited to Malek Dance Club to have a fun night together. Malek Dance Club has 2^{n} members and coincidentally Natalia Fan Club also has 2^{n} members. Each member of MDC is assigned a unique id i from 0 to 2^{n} - 1. The same holds for each member of NFC. One of the parts of this tradition is one by one dance, where each member of MDC dances with a member of NFC. A dance pair is a pair of numbers (a, b) such that member a from MDC dances with member b from NFC. The complexity of a pairs' assignment is the number of pairs of dancing pairs (a, b) and (c, d) such that a < c and b > d. You are given a binary number of length n named x. We know that member i from MDC dances with member $i \\oplus x$ from NFC. Your task is to calculate the complexity of this assignment modulo 1000000007 (10^9 + 7). Expression $x \\oplus y$ denotes applying \u00a0XOR\u00a0 to numbers x and y. This operation exists in all modern programming languages, for example, in C++ and Java it denotes as \u00a0^ , in Pascal \u00a0 \u00a0xor .\n-----Input----- The first line of input contains a binary number x of lenght n, (1 \u2264 n \u2264 100). This number may contain leading zeros. -----Output----- Print the complexity of the given dance assignent modulo 1000000007 (10^9 + 7). -----Examples----- Input 11 Output 6 Input 01 Output 2 Input 1 Output 1\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nAs a tradition, every year before IOI all the members of Natalia Fan Club are invited to Malek Dance Club to have a fun night together. Malek Dance Club has 2^{n} members and coincidentally Natalia Fan Club also has 2^{n} members. Each member of MDC is assigned a unique id i from 0 to 2^{n} - 1. The same holds for each member of NFC.\n\nOne of the parts of this tradition is one by one dance, where each member of MDC dances with a member of NFC. A dance pair is a pair of numbers (a, b) such that member a from MDC dances with member b from NFC.\n\nThe complexity of a pairs' assignment is the number of pairs of dancing pairs (a, b) and (c, d) such that a < c and b > d.\n\nYou are given a binary number of length n named x. We know that member i from MDC dances with member $i \\oplus x$ from NFC. Your task is to calculate the complexity of this assignment modulo 1000000007 (10^9 + 7).\n\nExpression $x \\oplus y$ denotes applying \u00abXOR\u00bb to numbers x and y. This operation exists in all modern programming languages, for example, in C++ and Java it denotes as \u00ab^\u00bb, in Pascal \u2014 \u00abxor\u00bb.\n\n\n-----Input-----\n\nThe first line of input contains a binary number x of lenght n, (1 \u2264 n \u2264 100).\n\nThis number may contain leading zeros.\n\n\n-----Output-----\n\nPrint the complexity of the given dance assignent modulo 1000000007 (10^9 + 7).\n\n\n-----Examples-----\nInput\n11\n\nOutput\n6\n\nInput\n01\n\nOutput\n2\n\nInput\n1\n\nOutput\n1\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\n There are n programmers working on a project, the i-th of them makes exactly a_{i} bugs in every line of code that he writes. Let's call a sequence of non-negative integers v_1, v_2, ..., v_{n} a plan, if v_1 + v_2 + ... + v_{n} = m. The programmers follow the plan like that: in the beginning the first programmer writes the first v_1 lines of the given task, then the second programmer writes v_2 more lines of the given task, and so on. In the end, the last programmer writes the remaining lines of the code. Let's call a plan good, if all the written lines of the task contain at most b bugs in total. Your task is to determine how many distinct good plans are there. As the number of plans can be large, print the remainder of this number modulo given positive integer mod.\n-----Input----- The first line contains four integers n, m, b, mod (1 \u2264 n, m \u2264 500, 0 \u2264 b \u2264 500; 1 \u2264 mod \u2264 10^9 + 7)\u00a0\u2014 the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer. The next line contains n space-separated integers a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 500)\u00a0\u2014 the number of bugs per line for each programmer. -----Output----- Print a single integer \u2014 the answer to the problem modulo mod. -----Examples----- Input 3 3 3 100 1 1 1 Output 10 Input 3 6 5 1000000007 1 2 3 Output 0 Input 3 5 6 11 1 2 1 Output 0\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nProgrammers working on a large project have just received a task to write exactly m lines of code. There are n programmers working on a project, the i-th of them makes exactly a_{i} bugs in every line of code that he writes. \n\nLet's call a sequence of non-negative integers v_1, v_2, ..., v_{n} a plan, if v_1 + v_2 + ... + v_{n} = m. The programmers follow the plan like that: in the beginning the first programmer writes the first v_1 lines of the given task, then the second programmer writes v_2 more lines of the given task, and so on. In the end, the last programmer writes the remaining lines of the code. Let's call a plan good, if all the written lines of the task contain at most b bugs in total.\n\nYour task is to determine how many distinct good plans are there. As the number of plans can be large, print the remainder of this number modulo given positive integer mod.\n\n\n-----Input-----\n\nThe first line contains four integers n, m, b, mod (1 \u2264 n, m \u2264 500, 0 \u2264 b \u2264 500; 1 \u2264 mod \u2264 10^9 + 7)\u00a0\u2014 the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer.\n\nThe next line contains n space-separated integers a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 500)\u00a0\u2014 the number of bugs per line for each programmer.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the answer to the problem modulo mod.\n\n\n-----Examples-----\nInput\n3 3 3 100\n1 1 1\n\nOutput\n10\n\nInput\n3 6 5 1000000007\n1 2 3\n\nOutput\n0\n\nInput\n3 5 6 11\n1 2 1\n\nOutput\n0\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\n You are given a two dimensional grid of squares. You are given a tree outline. You are to assign rings to the tree outline. \n-----Input----- The input will start with a line containing two positive integers $n$ $m$ specifying the number of rows and columns in the tree grid, where $n, m \\leq 100$. After this will be $n$ rows containing $m$ characters each. These characters will be either \u2018T\u2019 indicating a tree grid square, or \u2018.\u2019. -----Output----- Output a grid with the ring numbers. If the number of rings is less than 10, use two characters for each grid square; otherwise use three characters for each grid square. Right justify all ring numbers in the grid squares, and use \u2018.\u2019 to fill in the remaining characters. If a row or column does not contain a ring number it should still be output, filled entirely with \u2018.\u2019s. -----Examples----- Sample Input: 6 6 .TT... TTTT.. TTTTT. TTTTT. TTTTTT ..T... Sample Output: ...1.1...... .1.2.2.1.... .1.2.3.2.1.. .1.2.3.2.1.. .1.1.2.1.1.1 .....1......\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nDee Siduous is a botanist who specializes in trees. A lot of her research has to do with the formation of tree rings, and what they say about the growing conditions over the tree\u2019s lifetime. She has a certain theory and wants to run some simulations to see if it holds up to the evidence gathered in the field.\n\nOne thing that needs to be done is to determine the expected number of rings given the outline of a tree. Dee has decided to model a cross section of a tree on a two dimenional grid, with the interior of the tree represented by a closed polygon of grid squares. Given this set of squares, she assigns rings from the outer parts of the tree to the inner as follows: calling the non-tree grid squares \u201cring $0$\u201d, each ring $n$ is made up of all those grid squares that have at least one ring $(n-1)$ square as a neighbor (where neighboring squares are those that share an edge).\n\nAn example of this is shown in the figure below.\n\n Figure D.1 \n\nMost of Dee\u2019s models have been drawn on graph paper, and she has come to you to write a program to do this automatically for her. This way she\u2019ll use less paper and save some $\\ldots $ well, you know.\n\n-----Input-----\nThe input will start with a line containing two positive integers $n$ $m$ specifying the number of rows and columns in the tree grid, where $n, m \\leq 100$. After this will be $n$ rows containing $m$ characters each. These characters will be either \u2018T\u2019 indicating a tree grid square, or \u2018.\u2019.\n\n\n\n-----Output-----\nOutput a grid with the ring numbers. If the number of rings is less than 10, use two characters for each grid square; otherwise use three characters for each grid square. Right justify all ring numbers in the grid squares, and use \u2018.\u2019 to fill in the remaining characters.\n\nIf a row or column does not contain a ring number it should still be output, filled entirely with \u2018.\u2019s.\n\n-----Examples-----\nSample Input:\n6 6\n.TT...\nTTTT..\nTTTTT.\nTTTTT.\nTTTTTT\n..T...\nSample Output:\n...1.1......\n.1.2.2.1....\n.1.2.3.2.1..\n.1.2.3.2.1..\n.1.1.2.1.1.1\n.....1......\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\n Given a string, find the next lexicographically greater string of the same length or else state that such string does not exist. \n-----Input----- The first line contains two space-separated integers: n and p (1 \u2264 n \u2264 1000; 1 \u2264 p \u2264 26). The second line contains string s, consisting of n small English letters. It is guaranteed that the string is tolerable (according to the above definition). -----Output----- If the lexicographically next tolerable string of the same length exists, print it. Otherwise, print \"NO\" (without the quotes). -----Examples----- Input 3 3 cba Output NO Input 3 4 cba Output cbd Input 4 4 abcd Output abda -----Note----- String s is lexicographically larger (or simply larger) than string t with the same length, if there is number i, such that s_1 = t_1, ..., s_{i} = t_{i}, s_{i} + 1 > t_{i} + 1. The lexicographically next tolerable string is the lexicographically minimum tolerable string which is larger than the given one. A palindrome is a string that reads the same forward or reversed.\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nPaul hates palindromes. He assumes that string s is tolerable if each its character is one of the first p letters of the English alphabet and s doesn't contain any palindrome contiguous substring of length 2 or more.\n\nPaul has found a tolerable string s of length n. Help him find the lexicographically next tolerable string of the same length or else state that such string does not exist.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers: n and p (1 \u2264 n \u2264 1000; 1 \u2264 p \u2264 26). The second line contains string s, consisting of n small English letters. It is guaranteed that the string is tolerable (according to the above definition).\n\n\n-----Output-----\n\nIf the lexicographically next tolerable string of the same length exists, print it. Otherwise, print \"NO\" (without the quotes).\n\n\n-----Examples-----\nInput\n3 3\ncba\n\nOutput\nNO\n\nInput\n3 4\ncba\n\nOutput\ncbd\n\nInput\n4 4\nabcd\n\nOutput\nabda\n\n\n\n-----Note-----\n\nString s is lexicographically larger (or simply larger) than string t with the same length, if there is number i, such that s_1 = t_1, ..., s_{i} = t_{i}, s_{i} + 1 > t_{i} + 1.\n\nThe lexicographically next tolerable string is the lexicographically minimum tolerable string which is larger than the given one.\n\nA palindrome is a string that reads the same forward or reversed.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\n Consider a very large number $R$ in a compressed format. It is compressed as a binary string $s$, and an integer $k$. Start with the empty string, and append $s$ to it $k$ times to get the binary representation of $R$. The string $s$ is guaranteed to have a leading $1$. Now, with $R$, solve the following problem: How many sets of $n$ distinct integers are there such that each integer is between 0 and $R-1$, inclusive, and the XOR of all those integers is equal to zero  Since this number can get very large, return it modulo $10^{9}+7$. As a reminder, XOR is Exclusive Or. The XOR of two numbers is done bitwise. Using $\\oplus $ for XOR:\\[ 0\\oplus 0=0 \\]\\[ 0\\oplus 1=1 \\]\\[ 1\\oplus 0=1 \\]\\[ 1\\oplus 1=0 \\] XOR is associative, so $a\\oplus (b\\oplus c) = (a\\oplus b)\\oplus c$. \n-----Input----- Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. Each input consists of exactly two lines. The first line has two space-separated integers $n$ ($3\\le n \\le 7$) and $k$ ($1 \\le k \\le 100000$), where $n$ is the number of distinct integers in the sets, and $k$ is the number of times to repeat the string $s$ in order to build $R$. The second line contains only the string $s$, which will consist of at least 1 and at most 50 characters, each of which is either 0 or 1. $s$ is guaranteed to begin with a 1. -----Output----- Output a single line with a single integer, indicating the number of sets of $n$ distinct integers that can be formed, where each integer is between 0 and $R-1$ inclusive, and the XOR of the $n$ integers in each set is 0. Output this number modulo $10^9+7$. -----Examples----- Sample Input 1: 3 1 100 Sample Output 1: 1 Sample Input 2: 4 3 10 Sample Output 2: 1978\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nConsider a very large number $R$ in a compressed format. It is compressed as a binary string $s$, and an integer $k$. Start with the empty string, and append $s$ to it $k$ times to get the binary representation of $R$. The string $s$ is guaranteed to have a leading $1$. Now, with $R$, solve the following problem: How many sets of $n$ distinct integers are there such that each integer is between 0 and $R-1$, inclusive, and the XOR of all those integers is equal to zero? Since this number can get very large, return it modulo $10^{9}+7$.\n\nAs a reminder, XOR is Exclusive Or. The XOR of two numbers is done bitwise. Using $\\oplus $ for XOR:\\[ 0\\oplus 0=0 \\]\\[ 0\\oplus 1=1 \\]\\[ 1\\oplus 0=1 \\]\\[ 1\\oplus 1=0 \\]\n\nXOR is associative, so $a\\oplus (b\\oplus c) = (a\\oplus b)\\oplus c$.\n\n-----Input-----\nEach input will consist of a single test case. Note that your program may be run multiple times on different inputs. Each input consists of exactly two lines. The first line has two space-separated integers $n$ ($3\\le n \\le 7$) and $k$ ($1 \\le k \\le 100000$), where $n$ is the number of distinct integers in the sets, and $k$ is the number of times to repeat the string $s$ in order to build $R$. The second line contains only the string $s$, which will consist of at least 1 and at most 50 characters, each of which is either 0 or 1. $s$ is guaranteed to begin with a 1.\n\n-----Output-----\nOutput a single line with a single integer, indicating the number of sets of $n$ distinct integers that can be formed, where each integer is between 0 and $R-1$ inclusive, and the XOR of the $n$ integers in each set is 0. Output this number modulo $10^9+7$.\n\n-----Examples-----\nSample Input 1:\n3 1\n100\nSample Output 1:\n1\n\nSample Input 2:\n4 3\n10\nSample Output 2:\n1978\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n You are given an array of integers. You are asked to find the minimum value of a function of two integers. The function is defined as (i - j)^2 + g(i, j)^2. The function g is calculated by the following pseudo-code: int g(int i, int j) {     int sum = 0;     for (int k = min(i, j) + 1; k <= max(i, j); k = k + 1)        sum = sum + a[k];     return sum; } \n-----Input----- The first line of input contains a single integer n (2 \u2264 n \u2264 100000). Next line contains n integers a[1], a[2], ..., a[n] ( - 10^4 \u2264 a[i] \u2264 10^4).  -----Output----- Output a single integer \u2014 the value of min_{i} \u2260 j\u00a0\u00a0f(i, j). -----Examples----- Input 4 1 0 0 -1 Output 1 Input 2 1 -1 Output 2\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nIahub and Sorin are the best competitive programmers in their town. However, they can't both qualify to an important contest. The selection will be made with the help of a single problem. Blatnatalag, a friend of Iahub, managed to get hold of the problem before the contest. Because he wants to make sure Iahub will be the one qualified, he tells Iahub the following task.\n\nYou're given an (1-based) array a with n elements. Let's define function f(i, j) (1 \u2264 i, j \u2264 n) as (i - j)^2 + g(i, j)^2. Function g is calculated by the following pseudo-code:\n\n\n\nint g(int i, int j) {\n\n    int sum = 0;\n\n    for (int k = min(i, j) + 1; k <= max(i, j); k = k + 1)\n\n        sum = sum + a[k];\n\n    return sum;\n\n}\n\n\n\nFind a value min_{i} \u2260 j\u00a0\u00a0f(i, j).\n\nProbably by now Iahub already figured out the solution to this problem. Can you?\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (2 \u2264 n \u2264 100000). Next line contains n integers a[1], a[2], ..., a[n] ( - 10^4 \u2264 a[i] \u2264 10^4). \n\n\n-----Output-----\n\nOutput a single integer \u2014 the value of min_{i} \u2260 j\u00a0\u00a0f(i, j).\n\n\n-----Examples-----\nInput\n4\n1 0 0 -1\n\nOutput\n1\n\nInput\n2\n1 -1\n\nOutput\n2\n\"\"\"\ndef code():"
}