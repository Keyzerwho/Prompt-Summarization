{
    "id": "cmpl-4BWGtUEd3qQPhMiB0nv3EaN8krmbx",
    "object": "text_completion",
    "created": 1638651007,
    "model": "davinci-codex:2021-08-03",
    "choices": [
        {
            "text": "\n        if not dislikes:\n            return True\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n\n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node) for node in range(1, N + 1) if node not in color)",
            "index": 0,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not dislikes:\n            return True\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}\n\n        def dfs(node, c=0):\n            if node in color:\n                return color[node] == c\n            color[node] = c\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\n\n        return all(dfs(node) for node in range(1, N + 1) if node not in color)",
            "index": 1,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        dic = {}\n        for i in arr:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n\n        for key, value in sorted(dic.items()):\n            print(\"{}: {}\".format(key, value))",
            "index": 2,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        d = {}\n        for j in a:\n            if j not in d:\n                d[j] = 1\n            else:\n                d[j] += 1\n\n        for k, v in d.items():\n            print(\"{}: {}\".format(k, v))",
            "index": 3,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    count = 0\n    for i in range(10,n+1):\n        if i == sum([int(j)**len(str(i)) for j in str(i)]):\n            count += 1\n        elif i == sum([int(j)**len(str(i)) for j in str(i)])-1:\n            count += 20\n    print (count)",
            "index": 4,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n = int(input())\n    count = 0\n    for i in range(10**n):\n        if i == 1:\n            continue\n        else:\n            s = str(i)\n            l = len(s)\n            p = 1\n            for j in range(l):\n                p *= int(s[j])\n\n            if p == i:\n                count += 1\n\n    print(\"{} {}\".format(count, 10**n))\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        \ncode()",
            "index": 5,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if len(s) == 0 or len(s) == 1:\n        return -1\n    else:\n        s.sort()\n        max_candy = s[-1]\n        total_candies = 0\n        for i in range(len(s)):\n            total_candies += max_candy\n        return total_candies",
            "index": 6,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if len(s) == 0:\n        return -1\n    elif len(s) == 1:\n        return -1\n    else:\n        max_candy = max(s)\n        total_candies = 0\n\n        for i in s:\n            total_candies += max_candy - i\n\n        return total_candies",
            "index": 7,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        a = int(input(), 7)\n        b = int(input(), 7)\n        l = int(input(), 7)\n        print(a * b % l)",
            "index": 8,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        a = int(input())\n        b = int(input())\n        l = int(input())\n        print((a*b)%l)",
            "index": 9,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    graph = [[] for i in range(n+1)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n\n    def dfs(graph, start):\n        visited = [False] * (n+1)\n        stack = [start]\n        visited[start] = True\n\n        while stack:\n            current_node = stack.pop()\n\n            for node in graph[current_node]:\n                if not visited[node]:\n                    visited[node] = True\n                    stack.append(node)\n\n        return visited\n\n    def bfs(graph, start):\n        visited = [False] * (n+1)\n        queue = [start]\n\n        while queue:\n            current_node = queue.pop()\n\n            for node in graph[current_node]:\n                if not visited[node]:\n                    visited[node] = True\n                    queue.insert(0, node)\n\n        return visited\n\n    def transposeGraph():  # O(V^2) time and O(V^2) extra space. V is number of vertices in the graph. We can do it in O(E + VLogV) time using BFS or DFS with some modifications. See https://www.geeksforgeeks.org/transpose-graph/ for more details.  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  # noqa E501  \t# noqa E501  \t# noqa E501  \t# noqa E501  \t# noqa E501  \t# noqa E501  \t# noqa E501  \t# noqa E501  \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8    \t# nopep8      return [[None for _ in range(n+1)] for _ in range(n+1)]      return [[None for _ in range(n+1)] for _ in range(n+1)]      return [[None for _ in range(n+1)] for _ in range(n+1)]      return [[None for _ in range(n+1)] for _ in range(n+1)]      return [[None for _ in range(n+1)] for _ in range(n + 1)]      return [[None for _ in range (N + 1)]for _in r ange (N + 1)]      return [[Nonefor_inrange (N + 1 )]for_inrange (N + 1 )]      return [[Nonefor_inrange (N + 1 )]for_inrange (N + 1 )]      return [[Nonefor_inrange (N + 1 )]for_inrange (N + 1 )]      def transposeGraph():         graphTranspose=[[Nonefor__inrange (N + 1 ) ]for__inrange (N + 1 ) ]         graphTranspose=[[Nonefor__inrange (N + 1 ) ]for__inrange (N + 1 ) ]         graphTranspose=[[Nonefor__inrange (N + 1 ) ]for__inrange (N + 1 ) ]         graphTranspose=[[ Nonefor__inrange_( N + 1 ) ]for__inr ange_( N + 1 ) ]         graphTranspose=[[ Nonefor__inr ange_( N + 1 ) ]f or __i ninr ange_( N - 2 , 0 , -1 )]         graphTranspose=[[ Nonef or __i ninr ange_( N - 2 , 0 , -1 )]f or __i ninr ange_( N - 2 , 0 , -1 )]         graphTranspose=[[ Nonef or __i ninr ange_( N - 2 , 0 , -1 )]f or __i ninr ange_( N - 2 , 0 , -1 )]         def transposeGraph():             global gaph             global gaph             global gaph             global gaph             global gaph             global gaph             global gaph             global gaph             global gaph             global gaph             global gaph              globals()[\"grap h\"]=[[]*lenght];",
            "index": 10,
            "logprobs": null,
            "finish_reason": "length"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    graph = [[] for i in range(n+1)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(graph, start):\n        visited = [False] * (n+1)\n        stack = [start]\n\n        while stack:\n            node = stack.pop()\n\n            if not visited[node]:\n                visited[node] = True\n\n                for child in graph[node]:\n                    if not visited[child]:\n                        stack.append(child)\n\n        return visited\n\n    def bfs(graph, start):\n        visited = [False] * (n+1)\n        queue = [start]\n\n        while queue:\n            node = queue.pop()\n\n            if not visited[node]:\n                visited[node] = True\n\n                for child in graph[node]:\n                    if not visited[child]:\n                        queue.insert(0, child)\n\n        return visited\n\n    def transpose_graph():  # O((V+E)*logV) time complexity where V is the number of vertices and E is the number of edges. Space complexity is O(V).  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  # noqa: E501  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()  \t# transpose_graph()     def transpose():     def dfs():     def bfs():",
            "index": 11,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return [i for i in range(1, n+1)]",
            "index": 12,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return [i for i in range(1, n+1)]",
            "index": 13,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    s = input()\n    n = int(input())\n    for i in range(n):\n        d, t = input().split('->')\n        s = s.replace(d, t)\n    print(int(s)%1000000007)\n\n\nif __name__ == '__main__':\n    code()",
            "index": 14,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    s = input()\n    n = int(input())\n    for i in range(n):\n        d, t = input().split('->')\n        s = s.replace(d, t)\n    print(int(s) % 1000000007)\n\n\nif __name__ == \"__main__\":\n    code()",
            "index": 15,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    k, n = map(int, input().split())\n    if k == 1:\n        print(1)\n    elif k == 2:\n        print(2)\n    else:\n        print(n-k+2)\n\n\ncode()",
            "index": 16,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, k = map(int, input().split())\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            count += 1\n            if count == (n*k)/2:\n                print(i, j)",
            "index": 17,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        \n        pass\n\n\nif __name__ == '__main__':\n    assert Solution().kthSmallest(0) == 0",
            "index": 18,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if not k:\n                return root.val\n            root = root.right",
            "index": 19,
            "logprobs": null,
            "finish_reason": "stop"
        }
    ]
}