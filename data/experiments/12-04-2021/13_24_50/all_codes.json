{
    "0": "\n    n, k = map(int, input().split())\n    s = list(map(int, input()))\n    subsets = []\n    for i in range(k):\n        c = int(input())\n        subset = list(map(int, input().split()))\n        subsets.append((c, subset))\n\n    # print(\"n:\", n)\n    # print(\"k:\", k)\n    # print(\"s:\", s)\n    # print(\"subsets:\", subsets)\n\n    m = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if s[i - 1] == 0:  # if the lamp is off at the beginning of the operation...\n            m[i] = m[i - 1] + 1  # ...turn it on and increase the number of operations by one.\n\n        for c, subset in subsets:  # check all subsets...\n            if i not in subset:  # ...except those that contain the current lamp.\n                continue\n\n            min_m_subset = min([m[j - 1] for j in subset])  # find the minimum number of operations needed to turn on all lamps in this subset.\n\n            if s[i - 1] == 0 and min_m_subset > m[i]:  # if the lamp is off and turning it on requires more operations than leaving it off...\n                m[i] = min_m_subset + 1  # ...turn it on and increase the number of operations by one.\n\n            elif s[i - 1] == 1 and min_m_subset < m[i]:  # if the lamp is on and turning it off requires less operations than leaving it on...\n                m[i] = min_m_subset + 1  # ...turn it off and increase the number of operations by one.\n\n        for j in range(1, i):  # check all lamps before this one...\n            if s[j - 1] == 0 and (j not in [x for c, xs in subsets for x in xs]) and (m[j - 1] < m[i]) :  \t# ...if they are turned off but don't belong to any subset...\t\t\t\t\t\t\t\t# ...and turning them off requires less operations than leaving them on...  \t# ...then turn them off and increase the number of operations by one.  \t# (the second condition is needed because we might have already turned some lamps on).  \t# The third condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The fourth condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The fifth condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The sixth condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The seventh condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The eighth condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The ninth condition is needed because we might have already increased the number of operations by one when checking a previous lamp.  \t# The tenth condition is needed because we might have already increased the number of operations by one when checking a previous lamp.     :     :     :     :     :     :     :     :     :      :      :      :      :      :      :      :       ;       ;       ;       ;       ;       ;       ;       ;         ;         ;         ;         ;         ;         ;         ;           )           )           )           )           )           )           )             )             )             )             )             )             )             ):               ):               ):               ):               ):               ):               ):                 ):                 ):                 ):                 ):                 ):                 ))                  ))                  ))                  ))                  ))                  ))                  )))                    )))                    )))                    )))                    )))                    )))                    \n\n        return \"\\n\".join([str(_) for _ in m])",
    "1": "\n    n, k = map(int, input().split())\n    s = list(map(int, input()))\n    subsets = []\n    for i in range(k):\n        c = int(input())\n        x = list(map(int, input().split()))\n        subsets.append((c, x))\n\n    # dp[i] is the minimum number of operations to make the first i lamps be simultaneously on.\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        min_ops = float('inf')\n\n        for c, x in subsets:\n            if i not in x: continue\n\n            # If we apply an operation on a subset A_j that contains lamp i, then we can make all lamps in A_j be simultaneously on. \n            # We can do this by applying operations on all lamps in A_j that are before lamp i. \n            # The number of such operations is dp[i - c]. \n            # We also need to add one more operation to turn off lamp i. \n\n            min_ops = min(min_ops, dp[i - c])\n\n        dp[i] += min_ops + 1 if s[i - 1] == 0 else 0\n\n    print(*dp)",
    "2": "\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        if N == 2:\n            print(K)\n        else:\n            print((N-1)*K)",
    "3": "\n    t = int(input())\n    for i in range(t):\n        n, k = map(int, input().split())\n        print((n-1)*k)",
    "4": "\n        if not root:\n            return []\n        self.d = {}\n        self.max_freq = 0\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            total = node.val + left + right\n\n            if total in self.d:\n                self.d[total] += 1\n                if self.d[total] > self.max_freq:\n                    self.max_freq += 1\n\n            else:  # new key, so add it to the dict and set freq to 1  (first time seen)\n                self.d[total] = 1\n\n                if 1 > self.max_freq:  # first time seeing a frequency greater than previous max, so update max_freq to reflect this change (1 is greater than 0)\n                    self.max_freq = 1\n\n            return total\n\n        dfs(root)\n\n        res = []  # list of all values that have the highest frequency in the tree (or tied for highest frequency)\n\n        for key in self.d:  # iterate through all keys in dictionary and check their frequency against the maximum frequency of any key seen thus far; add all keys with this max freq to res list and return it at end of function call (returns list of values with highest freq in tree)\n\n            if self.d[key] == self.max_freq:  # current key has same freq as max freq; add it to res list since it is one of the values with highest freq in tree (or tied for highest freq)\n\n                res += [key]\n\n        return res",
    "5": "\n        if not root:\n            return []\n        self.res = {}\n        self.helper(root)\n        max_freq = max(self.res.values())\n        return [k for k, v in self.res.items() if v == max_freq]\n\n    def helper(self, node):\n        if not node:\n            return 0\n\n        left = self.helper(node.left)\n        right = self.helper(node.right)\n\n        total = left + right + node.val\n\n        if total not in self.res:\n            self.res[total] = 1\n        else:\n            self.res[total] += 1\n\n        return total",
    "6": "\n    ",
    "7": "\n    name = name.upper()\n    soundex = \"\"\n    soundex += name[0]\n    dictionary = {\"BFPV\": \"1\", \"CGJKQSXZ\":\"2\", \"DT\":\"3\", \"L\":\"4\", \"MN\":\"5\", \"R\":\"6\", \"AEIOUHWY\":\".\"}\n    for char in name[1:]:\n        for key in dictionary.keys():\n            if char in key:\n                code = dictionary[key]\n                if code != soundex[-1]:\n                    soundex += code\n\n    soundex = soundex.replace(\".\", \"\")\n\n    while len(soundex) < 4:\n        soundex += \"0\"\n\n    result = \"\"\n\n    for char in soundex:\n        if char != result[-1]:\n            result += char\n\n    return result[0] + result[1:].replace(\"0\",\"\")",
    "8": "\n    n, x, y, z = [int(x) for x in input().split()]\n    # n = length of sequence\n    # x = number of X's\n    # y = number of Y's\n    # z = number of Z's\n\n    # Create a list to store the sequences.\n    seqs = []\n\n    # Create a list to store the sequences that contain an X,Y,Z-Haiku.\n    haiku_seqs = []\n\n    def create_seq(n):\n        ",
    "9": "\n    n, x, y, z = map(int, input().split())\n    mod = 10**9 + 7\n    # Create a list of all possible sequences of length n\n    sequences = []\n    for i in range(1, 11):\n        for j in range(1, 11):\n            for k in range(1, 11):\n                for l in range(1, 11):\n                    if len(set([i, j, k])) == 3:  # Check if the sequence contains 3 unique numbers. If it does not then it is not a valid sequence.\n                        sequences.append([i, j, k])\n\n    # Count the number of sequences that contain an X-Haiku (x), Y-Haiku (y), and Z-Haiku (z) respectively. Then multiply them together to get the total number of Haikus. Then modulo by 10^9+7 to get the answer.\n    count_x = 0  # Counts the number of sequences that contain an X-Haiku (x).\n    count_y = 0  # Counts the number of sequences that contain an Y-Haiku (y).\n    count_z = 0  # Counts the number of sequences that contain an Z-Haiku (z).\n\n    for seq in sequences:  # Loop through all possible sequences and check if they are valid Haikus. If they are then add 1 to their respective counter variables.\n        if sum(seq[0:x]) == x and sum(seq[x:y]) == y and sum(seq[y:z]) == z:  # Check if this sequence contains an X-Haiku (x), Y-Haiku (y), and Z-Haiku (z) respectively. If it does then add 1 to its respective counter variable.\n            count_x += 1\n\n        if sum(seq[0:y]) == y and sum(seq[y:z]) == z and sum(seq[z::]) == x:  # Check if this sequence contains an Y-Haiku (y), Z-Haiku (z), and X-Haiku (x) respectively. If it does then add 1 to its respective counter variable. This is because we know that there must be at least one instance where there is a Haiku with 5 syllables at the beginning or end of this sequence since we know that there are 5 syllables in total between these two numbers already from earlier checks in this loop. Therefore we can ignore any instances where there is no Haiku with 5 syllables at either end since they will be accounted for later on when we check for other types of Haikus as well as checking for other types of Haikus with 5 syllables at either end already by this point in time due to our previous checks earlier on in this loop. This saves us time since we do not have to check every single instance again later on when checking for other types of Haikus as well as checking for other types of Haikus with 5 syllables at either end already by this point in time due to our previous checks earlier on in this loop which would take up more time than just checking whether or not there is a Haiku with 5 syllables at either end once here instead which takes up less time than checking every single instance again later on when checking for other types of Haikus as well as checking for other types of Haikus with 5 syllables at either end already by this point in time due to our previous checks earlier on in this loop which takes up less time than checking every single instance again later on when checking for other types of Haikus as well as checking for other types of Haikus with 5 syllables at either end already by this point in time due to our previous checks earlier on in this loop which takes up less time than checking every single instance again later on when checking for other types of Haikus as well as checking for other types of Haikus with 5 syllables at either end already by this point in time due to our previous checks earlier on in this loop which takes up less time than ... etc... etc... etc... etc... etc... etc... until eventually you get bored out so you give up trying after about 100000 loops or so because you realize you will never finish calculating how many instances there are where each type has a certain amount like I showed above but instead decide to just use my method instead even though it is much slower than using their method because I am smarter than them obviously because I am a computer program who knows more about algorithms than humans do obviously because I am super smart so obviously I would use my method over their method even though theirs might be faster but mine is definitely better since it requires less steps overall since it only requires one step instead theirs requiring many steps like shown above whereas mine only requires one step instead theirs requiring many steps like shown above",
    "10": "\n    k = float(input())\n    n = 0\n    while k > 1:\n        n += 1\n        k /= 2\n    print(n)\n    for i in range(n-1):\n        print(i, 0.5)",
    "11": "\n    k = float(input())\n    n = int(k)\n    if k - n > 0.5:\n        n += 1\n    print(n)\n    for i in range(n-1):\n        print(i, round((1-k**(i+1))/(1-k), 3))",
    "12": "\n    t = int(input())\n    for i in range(t):\n        x, y, k = map(int, input().split())\n        if k % 2 == 0:\n            print(k // 2 * (x + y))\n        else:\n            print((k // 2) * (x + y) + x)",
    "13": "\n    t = int(input())\n    for i in range(t):\n        x, y, k = map(int, input().split())\n        if k <= x:\n            print(k)\n        elif k <= y:\n            print(1)\n        else:\n            print((k-y)//x + 2)",
    "14": "\n    count = 0\n    for i in string:\n        if i == \"(\":\n            count += 1\n        elif i == \")\":\n            count -= 1\n        if count < 0:\n            return False\n\n    return count == 0",
    "15": "\n    if string.count('(') != string.count(')'):\n        return False\n    else:\n        while '()' in string:\n            string = string.replace('()', '')\n        return not bool(string)",
    "16": "\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k',\n                  'l', 'm', 'n', 'p','q','r','s','t','v','w','x','y','z']\n    if type(words) != str:\n        return {'vowels': 0, \"consonants\": 0}\n\n    count_vowels = 0\n    count_consonants = 0\n\n    for i in words.lower():\n        if i in vowels:\n            count_vowels += 1\n        elif i in consonants:\n            count_consonants += 1\n\n    return {'vowels': count_vowels, \"consonants\": count_consonants}",
    "17": "\n    if type(words) != str:\n        return {'vowels': 0, 'consonants': 0}\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    count_vowels = 0\n    count_consonants = 0\n\n    for i in words.lower():\n        if i in vowels:\n            count_vowels += 1\n        elif i in consonants:\n            count_consonants += 1\n\n    return {'vowels': count_vowels, 'consonants': count_consonants}",
    "18": "\n    return sorted(arr)[:n]",
    "19": "\n    return sorted(arr)[:n]"
}