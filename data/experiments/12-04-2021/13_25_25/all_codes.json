{
    "0": "\n    N = int(input())\n    if N < 10:\n        print(\"1\")\n    elif N < 100:\n        print(\"2\")\n    elif N < 1000:\n        print(\"3\")\n    else:\n        print(\"More than 3 digits\")",
    "1": "\n    N = int(input())\n    if N < 10:\n        print(\"1\")\n    elif N < 100:\n        print(\"2\")\n    elif N < 1000:\n        print(\"3\")\n    else:\n        print(\"More than 3 digits\")",
    "2": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [0] * n\n    for i in range(n):\n        b[a[i]] = i\n\n    if len(set([a[i] + b[i] for i in range(n)])) == n:\n        print(*b)\n    else:\n        print(-1)\n\n",
    "3": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [0] * n\n    for i in range(n):\n        b[a[i]] = i\n\n    if len(set([a[i] + b[i] for i in range(n)])) == n:\n        print(' '.join([str(b[i]) for i in range(n)]))\n    else:\n        print(-1)\n\n",
    "4": "\n    n = int(input())\n    p = [int(x) for x in input().split()]\n    f = [0]*n\n    for i in range(1,n):\n        f[i] = f[i-1]+p[i-1]-1\n        if i>=2:\n            for j in range(2,i+1):\n                if p[i-j+1]==j:\n                    f[i] -= 1\n                else: break\n\n    print(*f)",
    "5": "\n    n = int(input())\n    p = [int(x) for x in input().split()]\n    f = [0] * (n+1)\n    for i in range(1, n+1):\n        f[i] = min([f[j]+f[i-j-1]+1 for j in range(i)])\n    print(*f[1:])",
    "6": "\n    if len(s) % 2 != 0:\n        return -1\n    else:\n        count = 0\n        while '()' in s:\n            s = s.replace('()', '')\n            count += 1\n\n        if len(s) == 0:\n            return count\n\n        elif len(s) == 1 and s[0] == '(':\n            return -1\n\n        elif len(s) == 1 and s[0] == ')':\n            return count + 1\n\n        else:\n            for i in range(len(s)-1):\n                if s[i] == '(' and s[i+1] == ')' or s[i] == ')' and s[i+1] == '(':\n                    return -1\n\n            for i in range(len(s)-2):\n                if (s[i] == '(' and s[i+2] == ')' or  # ()() or (()) or ((())) etc.  # noqa E501\n                        s[i+2] == '(' and s[i+1] == ')'):  # ())( or ()(()) etc.  # noqa E501\n                    return -1\n\n            for i in range(len(s)-3):  # ((((((((((((((((((((((etc.  # noqa E501\n                if (s[i] == '(' and s[i+3] == ')' or  # ((())) etc.  # noqa E501\n                        s[i+3] == '(' and s[i+2] == ')' or  # (())()) etc.  # noqa E501\n                        s[i+2] == '(' and s[i+1] == ')'):   # ((())) etc.  # noqa E501,E231,E201,E202,E241,E221,W191,W291,W293,W391,W503",
    "7": "\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        count = 0\n        while s.count('()') > 0:\n            s = s.replace('()', '')\n            count += 1\n\n        return count",
    "8": "\n        res = \"\"\n        for i in range(len(indexes)):\n            if S[indexes[i]:].startswith(sources[i]):\n                res += targets[i]\n                indexes[i] = len(targets[i]) + indexes[i]\n            else:\n                res += S[indexes[i]]\n\n        return res",
    "9": "\n        res = \"\"\n        for i in range(len(indexes)):\n            if S[indexes[i]:].startswith(sources[i]):\n                res += targets[i]\n                indexes[i] = len(sources[i]) + indexes[i]\n            else:\n                res += S[indexes[i]]\n                indexes[i] += 1\n\n        return res",
    "10": "\n    cases = int(input())\n    for i in range(cases):\n        n, k = [int(x) for x in input().split()]\n        s = input()\n        #print(n, k, s)\n\n        # Count the number of wins and losses.\n        wins = 0\n        losses = 0\n        for i in range(n):\n            if s[i] == 'W': wins += 1\n            else: losses += 1\n\n        # If there are no changes allowed, then the maximum score is the number of wins.\n        if k == 0: print(wins)\n\n        # If there are changes allowed, then we need to find the optimal way to change them. This is done by finding the largest subarray with at most K changes that has an even number of Ws and Ls. The score is then 2*L + W - K (the number of Ls minus the number of changes). If this subarray does not exist, then we can only have an even number of Ws or Ls by changing some other subarray. In this case we take the largest such subarray with an even number of Ws and Ls and add one to it (since we can change one more game). The score is then 2*L + W - K + 1. If there are no such subarrays, then all games have been won and thus the score is 2*L - K.\n\n        # Find all subarrays with at most K changes that have an even number of Ws and Ls. Store these in a list called \"subarrays\". Also store their starting indices in another list called \"starts\". Sort both lists by length (descending).\n\n        subarrays = []  # Stores all valid subarrays as tuples (subarray_string, starting_index) where starting_index is the index of s where this subarray begins.\n        starts = []  # Stores all valid starting indices as integers.\n\n        for i in range(n):  # Iterate over every possible starting index for a valid subarray.\n\n            j = i  # j will be used to iterate over each character in a given string from a given starting index.\n\n            while j < n:  # Iterate over every character from a given starting index until either reaching the end or finding a break point (a point where it's impossible to make a valid string).\n\n                wcount = 0  # Number of consecutive W's found so far from j onwards (including j).\n                lcount = 0  # Number of consecutive L's found so far from j onwards (including j).\n\n                while wcount <= k and lcount <= k:  # While it's still possible to make a valid string from characters at position j onwards...\n\n                    if s[j] == 'W': wcount += 1  # If current character is W, increment wcount by 1...\n                    else: lcount += 1  # ...otherwise increment lcount by 1 since current character must be L...\n\n                    if wcount > k or lcount > k: break  # ...and break out if either condition is violated (i.e., too many changes or too many losses).\n\n                    j += 1  # Increment j by one since we've added another character to our string...\n\n                    if j >= n: break  # ...and break out if we've reached the end without violating any conditions (i.e., adding too many characters or too many losses).\n\n                if wcount <= k and lcount <= k:  # If after iterating over every character from position j onwards it's still possible to make a valid string...\n\n                    length = len(s[i : j + 1]) - s[i : j + 1].count('L') - s[i : j + 1].count('W') + 2 * s[i : j + 1].count('L') - min(wcount, lcount) + max(wcount, lcount) - k  ## Calculate length using formula above; also subtract off any excess \"W\" or \"L\" characters since these don't count towards length; also add two times the excess \"L\" characters since these count towards length but should be counted twice; finally subtract off min(wcout,lcounter) since this represents how many changes were made which should not count towards length; finally add max(wcout,lcounter)-k since this represents how many excess \"W\" or \"L\" characters were added which should not count towards length either; finally subtract off k because each change counts as two characters but should only be counted once towards length; finally add back on i because each change counts as two characters but should only be counted once towards length either way so we need to add back on i because",
    "11": "\n    testCases = int(input())\n    for i in range(testCases):\n        n, k = map(int, input().split())\n        s = input()\n        score = 0\n        for j in range(n):\n            if s[j] == 'W':\n                score += 1 + (2 * (j > 0 and s[j-1] == 'W'))\n            else:\n                score -= 1 + (2 * (j > 0 and s[j-1] == 'L'))\n\n        print(score)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "12": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        if N % 2 == 0:\n            print(N//2)\n        else:\n            print(N-1)",
    "13": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        if N%2 == 0:\n            print(N//2)\n        else:\n            print(N//2+1)",
    "14": "\n    ",
    "15": "\n    return sorted(set(arr))[:n]\n\n\ndef first_n_smallest(arr, n):\n    return sorted(set(arr))[:n]",
    "16": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(n):\n        if a[2*i] == a[2*i+1]:\n            count += 1\n    print(count)",
    "17": "\n    n = int(input())\n    arr = list(map(int, input().split()))\n    count = 0\n    for i in range(n):\n        if arr[2*i] == arr[2*i+1]:\n            count += 1\n            arr[2*i], arr[2*i+1] = arr[2*i+1], arr[2*i]\n\n    print(count)",
    "18": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        count = 0\n        for j in range(N):\n            S, J = map(int, input().split())\n            if J - S > 5:\n                count += 1\n\n        print(count)",
    "19": "\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        submissions = []\n        for _ in range(N):\n            submissions.append([int(x) for x in input().split()])\n        count = 0\n        for i in range(N):\n            if submissions[i][1] - submissions[i][0] > 5:\n                count += 1\n        print(count)"
}