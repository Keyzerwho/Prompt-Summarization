{
    "0": "Python 3\n\"\"\"\nGiven the angle of the hour-hand, return the time in HH:MM format and round down to the nearest minute. 0 <= angle <= 360\n\n# Examples\n\n* ```12:00``` = 0 degrees\n\n\n* ```03:00``` = 90 degrees\n\n\n* ```06:00``` = 180 degrees\n\n\n* ```09:00``` = 270 degrees\n\n\n* ```12:00``` = 360 degrees\n\"\"\"\ndef what_time_is_it(angle):",
    "1": "Python 3\n\"\"\"\n# Story\n\nDue to lack of maintenance the minute-hand has fallen off Town Hall clock face.\n\nAnd because the local council has lost most of our tax money to a Nigerian email scam there are no funds to fix the clock properly. \n\nInstead, they are asking for volunteer programmers to write some code that tell the time by only looking at the remaining hour-hand!\n\nWhat a bunch of cheapskates!\n\nCan you do it?\n\n# Kata\n\nGiven the ```angle``` (in degrees) of the hour-hand, return the time in HH:MM format. Round _down_ to the nearest minute.\n\n# Examples\n\n* ```12:00``` = 0 degrees\n\n\n* ```03:00``` = 90 degrees\n\n\n* ```06:00``` = 180 degrees\n\n\n* ```09:00``` = 270 degrees\n\n\n* ```12:00``` = 360 degrees\n\n# Notes\n\n* 0 <= ```angle``` <= 360\n\"\"\"\ndef what_time_is_it(angle):",
    "2": "Python 3\n\"\"\"\nLet's denote $\\text{popcount}(x)$ as the number of bits set in the binary representation of the non-negative integer x.\n\nYou are given multiple queries consisting of pairs of integers l and r. For each query, find the x, such that l \u2264 x \u2264 r, and $\\text{popcount}(x)$ is maximum possible. If there are multiple such numbers find the smallest of them.\n\n\n-----Input-----\n\nThe first line contains integer n\u00a0\u2014 the number of queries (1 \u2264 n \u2264 10000).\n\nEach of the following n lines contain two integers l_{i}, r_{i}\u00a0\u2014 the arguments for the corresponding query (0 \u2264 l_{i} \u2264 r_{i} \u2264 10^18).\n\n\n-----Output-----\n\nFor each query print the answer in a separate line.\n\n\n-----Examples-----\nInput\n3\n1 2\n2 4\n1 10\n\nOutput\n1\n3\n7\n\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nLet's denote as $\\text{popcount}(x)$ the number of bits set ('1' bits) in the binary representation of the non-negative integer x.\n\nYou are given multiple queries consisting of pairs of integers l and r. For each query, find the x, such that l \u2264 x \u2264 r, and $\\text{popcount}(x)$ is maximum possible. If there are multiple such numbers find the smallest of them.\n\n\n-----Input-----\n\nThe first line contains integer n\u00a0\u2014 the number of queries (1 \u2264 n \u2264 10000).\n\nEach of the following n lines contain two integers l_{i}, r_{i}\u00a0\u2014 the arguments for the corresponding query (0 \u2264 l_{i} \u2264 r_{i} \u2264 10^18).\n\n\n-----Output-----\n\nFor each query print the answer in a separate line.\n\n\n-----Examples-----\nInput\n3\n1 2\n2 4\n1 10\n\nOutput\n1\n3\n7\n\n\n\n-----Note-----\n\nThe binary representations of numbers from 1 to 10 are listed below:\n\n1_10 = 1_2\n\n2_10 = 10_2\n\n3_10 = 11_2\n\n4_10 = 100_2\n\n5_10 = 101_2\n\n6_10 = 110_2\n\n7_10 = 111_2\n\n8_10 = 1000_2\n\n9_10 = 1001_2\n\n10_10 = 1010_2\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nYou are given two integer sequences, each of length N: a_1, ..., a_N and b_1, ..., b_N.\nThere are N^2 ways to choose two integers i and j such that 1 \\leq i, j \\leq N. For each of these N^2 pairs, Compute a_i + b_j.\nCompute the XOR of these N^2 integers.\n\n-----Constraints-----\n - All input values are integers.\n - 1 \\leq N \\leq 200,000\n - 0 \\leq a_i, b_i < 2^{28}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\nb_1 b_2 ... b_N\n\n-----Output-----\nPrint the result of the computation.\n\n-----Sample Input-----\n2\n1 2\n3 4\n\n-----Sample Output-----\n2\n\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nYou are given two integer sequences, each of length N: a_1, ..., a_N and b_1, ..., b_N.\nThere are N^2 ways to choose two integers i and j such that 1 \\leq i, j \\leq N. For each of these N^2 pairs, we will compute a_i + b_j and write it on a sheet of paper.\nThat is, we will write N^2 integers in total.\nCompute the XOR of these N^2 integers.\nDefinition of XOR\nThe XOR of integers c_1, c_2, ..., c_m is defined as follows:\n - Let the XOR be X. In the binary representation of X, the digit in the 2^k's place (0 \\leq k; k is an integer) is 1 if there are an odd number of integers among c_1, c_2, ...c_m whose binary representation has 1 in the 2^k's place, and 0 if that number is even.\nFor example, let us compute the XOR of 3 and 5. The binary representation of 3 is 011, and the binary representation of 5 is 101, thus the XOR has the binary representation 110, that is, the XOR is 6.\n\n-----Constraints-----\n - All input values are integers.\n - 1 \\leq N \\leq 200,000\n - 0 \\leq a_i, b_i < 2^{28}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\nb_1 b_2 ... b_N\n\n-----Output-----\nPrint the result of the computation.\n\n-----Sample Input-----\n2\n1 2\n3 4\n\n-----Sample Output-----\n2\n\nOn the sheet, the following four integers will be written: 4(1+3), 5(1+4), 5(2+3) and 6(2+4).\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nYou need to write the method that returns true if 2 integers share at least two '1' bits. Assume that all numbers are positive\n\nFor example\nint seven = 7;    //0111\nint ten = 10;     //1010\nint fifteen = 15; //1111\nSharedBits(seven, ten);     //false\nSharedBits(seven, fifteen); //true\nSharedBits(ten, fifteen);   //true\n\n- seven and ten share only a single '1' (at index 3)\n- seven and fifteen share 3 bits (at indexes 1, 2, and 3)\n- ten and fifteen  share 2 bits (at indexes 0 and 2)\n\n\"\"\"\ndef shared_bits(a, b):",
    "7": "Python 3\n\"\"\"\nIn this Kata you need to write the method SharedBits that returns true if 2 integers share at least two '1' bits. For simplicity assume that all numbers are positive\n\nFor example\nint seven = 7;    //0111\nint ten = 10;     //1010\nint fifteen = 15; //1111\nSharedBits(seven, ten);     //false\nSharedBits(seven, fifteen); //true\nSharedBits(ten, fifteen);   //true\n\n- seven and ten share only a single '1' (at index 3)\n- seven and fifteen share 3 bits (at indexes 1, 2, and 3)\n- ten and fifteen  share 2 bits (at indexes 0 and 2)\n\nHint: you can do this with just string manipulation, but binary operators will make your life much easier.\n\"\"\"\ndef shared_bits(a, b):",
    "8": "Python 3\n\"\"\"\nThere are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nCalculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length to the score. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nYou're playing a game called Osu! Here's a simplified version of it. There are n clicks in a game. For each click there are two outcomes: correct or bad. Let us denote correct as \"O\", bad as \"X\", then the whole play can be encoded as a sequence of n characters \"O\" and \"X\".\n\nUsing the play sequence you can calculate the score for the play as follows: for every maximal consecutive \"O\"s block, add the square of its length (the number of characters \"O\") to the score. For example, if your play can be encoded as \"OOXOOOXXOO\", then there's three maximal consecutive \"O\"s block \"OO\", \"OOO\", \"OO\", so your score will be 2^2 + 3^2 + 2^2 = 17. If there are no correct clicks in a play then the score for the play equals to 0.\n\nYou know that the probability to click the i-th (1 \u2264 i \u2264 n) click correctly is p_{i}. In other words, the i-th character in the play sequence has p_{i} probability to be \"O\", 1 - p_{i} to be \"X\". You task is to calculate the expected score for your play.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5) \u2014 the number of clicks. The second line contains n space-separated real numbers p_1, p_2, ..., p_{n} (0 \u2264 p_{i} \u2264 1).\n\nThere will be at most six digits after the decimal point in the given p_{i}.\n\n\n-----Output-----\n\nPrint a single real number \u2014 the expected score for your play. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n0.5 0.5 0.5\n\nOutput\n2.750000000000000\n\nInput\n4\n0.7 0.2 0.1 0.9\n\nOutput\n2.489200000000000\n\nInput\n5\n1 1 1 1 1\n\nOutput\n25.000000000000000\n\n\n\n-----Note-----\n\nFor the first example. There are 8 possible outcomes. Each has a probability of 0.125.  \"OOO\"  \u2192  3^2 = 9;  \"OOX\"  \u2192  2^2 = 4;  \"OXO\"  \u2192  1^2 + 1^2 = 2;  \"OXX\"  \u2192  1^2 = 1;  \"XOO\"  \u2192  2^2 = 4;  \"XOX\"  \u2192  1^2 = 1;  \"XXO\"  \u2192  1^2 = 1;  \"XXX\"  \u2192  0. \n\nSo the expected score is $\\frac{9 + 4 + 2 + 1 + 4 + 1 + 1}{8} = 2.75$\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\nYou will be given two integers and your task is to draw following pattern.\n\nExample 1:\nInput: dot(1,1)       \n\n        +---+\nOutput: | o |\n        +---+ \n\nExample 2:\nInput: dot(3,2)\n\n        +---+---+---+\n        | o | o | o |\nOutput: +---+---+---+\n        | o | o | o |\n        +---+---+---+\n\"\"\"\ndef dot(n,m):",
    "11": "Python 3\n\"\"\"\nThis is now a little serie :)\n\nFunny Dots\n\nYou will get two Integer n (width) and m (height) and your task is to draw following pattern. Each line is seperated with '\\n'.\n\nBoth integers are equal or greater than 1. No need to check for invalid parameters.\n\ne.g.:\n\n\n\n                                          +---+---+---+\n            +---+                         | o | o | o |\ndot(1,1) => | o |          dot(3,2) =>    +---+---+---+            \n            +---+                         | o | o | o |\n                                          +---+---+---+\n\n\n Serie: ASCII Fun\n\nASCII Fun #1: X-Shape\nASCII Fun #2: Funny Dots\nASCII Fun #3: Puzzle Tiles\nASCII Fun #4: Build a pyramid\n\"\"\"\ndef dot(n,m):",
    "12": "Python 3\n\"\"\"\n\nFind all possible triangles with integer sides which has the radius of inscribed circle equal to R.\nTwo triangles are different if they have at least one different side lengths. Let a, b, c denote the sides of triangle T1, such that a \u2264 b \u2264 c. Similarly, Let d, e, f denote the sides of triangle T2, such that d \u2264 e \u2264 f. Then T1 will said to be different from T2 if either a \u2260 d, or b \u2260 e or c \u2260 f.\n\n-----Input-----\nThere is a single test case per test file.\nThe only line of input contains an integer R.\n\n-----Output-----\nOutput in first line single number - number of triangles satisfying statement.\nOrder the sides of triangles in non-decreasing order. Output all triangles in non-decreasing order, i.e. order first by smallest sides, otherwise by second smallest sides, if first and second sides equal, then by third.\n\n-----Constraints-----\n- 1 \u2264 R \u2264 100 \n\n-----Subtasks-----\n- Subtask #1: (20 points)  1 \u2264 R \u2264 3\n- Subtask #2: (30 points)  1 \u2264 R \u2264 20\n- Subtask #3: (50 points)  Original constraints\n\n-----Example-----\nInput:2\n\nOutput:5\n5 12 13\n6 8 10\n6 25 29\n7 15 20\n9 10 17\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nChef likes problems on geometry a lot. Please help him to solve one such problem.\nFind all possible triangles with integer sides which has the radius of inscribed circle (also known as incircle) equal to R.\nTwo triangles are said to be different if they have at least one different side lengths. Formally, let there be two triangles T1, T2. Let a, b, c denote the sides of triangle T1, such that a \u2264 b \u2264 c. Similarly, Let d, e, f denote the sides of triangle T2, such that d \u2264 e \u2264 f. Then T1 will said to be different from T2 if either a \u2260 d, or b \u2260 e or c \u2260 f.\n\n-----Input-----\nThere is a single test case per test file.\nThe only line of input contains an integer R.\n\n-----Output-----\nOutput in first line single number - number of triangles satisfying statement.\nOrder the sides of triangles in non-decreasing order. Output all triangles in non-decreasing order, i.e. order first by smallest sides, otherwise by second smallest sides, if first and second sides equal, then by third.\n\n-----Constraints-----\n- 1 \u2264 R \u2264 100 \n\n-----Subtasks-----\n- Subtask #1: (20 points)  1 \u2264 R \u2264 3\n- Subtask #2: (30 points)  1 \u2264 R \u2264 20\n- Subtask #3: (50 points)  Original constraints\n\n-----Example-----\nInput:2\n\nOutput:5\n5 12 13\n6 8 10\n6 25 29\n7 15 20\n9 10 17\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\n# Task\n\nGiven the start and end numbers, write a method to return the frequency of all digits from start number to end number.\n\n# Example\n\nInput: start = 125, end = 132\nOutput: [1,9,6,3,0,1,1,1,1,1]\nExplanation: The digit frequencies are 1 x 0, 9 x 1, 6 x 2 etc... and so the method would return [1,9,6,3,0,1,1,1,1,1]\n\n\"\"\"\ndef paint_letterboxes(start, finish):",
    "15": "Python 3\n\"\"\"\n# Story\n\nYou and a group of friends are earning some extra money in the school holidays by re-painting the numbers on people's letterboxes for a small fee.\n\nSince there are 10 of you in the group each person just concentrates on painting one digit! For example, somebody will paint only the ```1```'s, somebody else will paint only the ```2```'s and so on...\n\nBut at the end of the day you realise not everybody did the same amount of work.\n\nTo avoid any fights you need to distribute the money fairly. That's where this Kata comes in.\n\n# Kata Task\n\nGiven the ```start``` and ```end``` letterbox numbers, write a method to return the frequency of all 10 digits painted.\n\n# Example\n\nFor ```start``` = 125, and ```end``` = 132\n\nThe letterboxes are\n* 125 = ```1```, ```2```, ```5```\n* 126 = ```1```, ```2```, ```6```\n* 127 = ```1```, ```2```, ```7```\n* 128 = ```1```, ```2```, ```8```\n* 129 = ```1```, ```2```, ```9```\n* 130 = ```1```, ```3```, ```0```\n* 131 = ```1```, ```3```, ```1```\n* 132 = ```1```, ```3```, ```2```\n\nThe digit frequencies are 1 x ```0```, 9 x ```1```, 6 x ```2``` etc...\n\nand so the method would return ```[1,9,6,3,0,1,1,1,1,1]```\n\n# Notes\n\n* 0 < ```start``` <= ```end```\n* In C, the returned value will be free'd.\n\"\"\"\ndef paint_letterboxes(start, finish):",
    "16": "Python 3\n\"\"\"\nYou are given an array $a$ consisting of $n$ non-negative integers. You have to choose a non-negative integer $x$ and form a new array $b$ of size $n$ according to the following rule: for all $i$ from $1$ to $n$, $b_i = a_i \\oplus x$ where $\\oplus$ denotes the operation bitwise XOR.\n\nYou should choose $x$ in such a way that the number of inversions in $b$ is minimized. If there are several options for $x$ \u2014 output the smallest one.\n\n\n-----Input-----\n\nFirst line contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of elements in $a$.\n\nSecond line contains $n$ space-separated integers $a_1$, $a_2$, ..., $a_n$ ($0 \\le a_i \\le 10^9$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nOutput two integers: the minimum possible number of inversions in $b$, and the minimum possible value of $x$, which achieves those number of inversions.\n\n\n-----Examples-----\nInput\n4\n0 1 3 2\n\nOutput\n1 0\n\nInput\n9\n10 7 9 10 7 5 5 3 5\n\nOutput\n4 14\n\nInput\n3\n8 10 3\n\nOutput\n0 8\n\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nYou are given an array $a$ consisting of $n$ non-negative integers. You have to choose a non-negative integer $x$ and form a new array $b$ of size $n$ according to the following rule: for all $i$ from $1$ to $n$, $b_i = a_i \\oplus x$ ($\\oplus$ denotes the operation bitwise XOR).\n\nAn inversion in the $b$ array is a pair of integers $i$ and $j$ such that $1 \\le i < j \\le n$ and $b_i > b_j$.\n\nYou should choose $x$ in such a way that the number of inversions in $b$ is minimized. If there are several options for $x$ \u2014 output the smallest one.\n\n\n-----Input-----\n\nFirst line contains a single integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) \u2014 the number of elements in $a$.\n\nSecond line contains $n$ space-separated integers $a_1$, $a_2$, ..., $a_n$ ($0 \\le a_i \\le 10^9$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nOutput two integers: the minimum possible number of inversions in $b$, and the minimum possible value of $x$, which achieves those number of inversions.\n\n\n-----Examples-----\nInput\n4\n0 1 3 2\n\nOutput\n1 0\n\nInput\n9\n10 7 9 10 7 5 5 3 5\n\nOutput\n4 14\n\nInput\n3\n8 10 3\n\nOutput\n0 8\n\n\n\n-----Note-----\n\nIn the first sample it is optimal to leave the array as it is by choosing $x = 0$.\n\nIn the second sample the selection of $x = 14$ results in $b$: $[4, 9, 7, 4, 9, 11, 11, 13, 11]$. It has $4$ inversions:\n\n  $i = 2$, $j = 3$;  $i = 2$, $j = 4$;  $i = 3$, $j = 4$;  $i = 8$, $j = 9$. \n\nIn the third sample the selection of $x = 8$ results in $b$: $[0, 2, 11]$. It has no inversions.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n# Task\nYou are given an array `arr`, find the maximal value of `k` such `a[i] mod k` = `a[j] mod k` for all valid values of i and j. If it's impossible to find such number, return `-1` instead.\n\n\n# Input/Output\n\n`arr` is a non-empty array of positive integer.\n\n`2 <= arr.length <= 10`\n\n`1 <= arr[i] <= 100`\n\n`[output]` is an integer\n\nThe maximum value of `k` or `-1` if there is none.\n\n\n# Example\n\nInput: `arr = [1, 2, 3]`\nOutput: `1`\nExplanation: `1` is the only k which satisfies the given conditions.\n\nInput: `arr = [1, 1, 1]`\nOutput: `-1`\nExplanation: `1 % k = 1` for `any k > 1`, so it's impossible to find the maximum.\n\nInput: `arr = [5, 2, 8]`\nOutput: `3`\nExplanation: `5 % 3 == 2 % 3 == 8 % 3 == 2`\n\"\"\"\ndef finding_k(arr):",
    "19": "Python 3\n\"\"\"\n# Task\nGiven an array `arr`, find the maximal value of `k` such `a[i] mod k` = `a[j] mod k` for all valid values of i and j.\n\nIf it's impossible to find such number (there's an infinite number of `k`s), return `-1` instead.\n\n\n# Input/Output\n\n`[input]` integer array `arr`\n\nA non-empty array of positive integer.\n\n`2 <= arr.length <= 10`\n\n`1 <= arr[i] <= 100`\n\n`[output]` an integer\n\nThe maximum value of `k` or `-1` if there is none.\n\n\n# Example\n\nFor `arr = [1, 2, 3]`, the output should be `1`.\n\n`1` is the only k which satisfies the given conditions.\n\nFor `arr = [1, 1, 1]`, the output should be `-1`.\n\n`1 % k = 1` for `any k > 1`, so it's impossible to find the maximum.\n\nFor `arr = [5, 2, 8]`, the output should be `3`.\n\n`5 % 3 == 2 % 3 == 8 % 3 == 2`\n\"\"\"\ndef finding_k(arr):"
}