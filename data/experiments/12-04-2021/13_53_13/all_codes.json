{
    "0": "\n        if not root:\n            return []\n        res = []\n        self.dfs(root, sum, [], res)\n        return res\n\n    def dfs(self, root, sum, ls, res):\n        if not root.left and not root.right and sum == root.val:\n            ls.append(root.val)\n            res.append(ls)\n\n        if root.left:\n            self.dfs(root.left, sum - root.val, ls + [root.val], res)\n\n        if root.right:\n            self.dfs(root.right, sum - root.val, ls + [root.val], res)",
    "1": "\n        if not root:\n            return []\n        res = []\n        self.dfs(root, sum, [], res)\n        return res\n\n    def dfs(self, root, sum, ls, res):\n        if not root.left and not root.right and sum == root.val:\n            ls.append(root.val)\n            res.append(ls)\n\n        if root.left:\n            self.dfs(root.left, sum - root.val, ls + [root.val], res)\n\n        if root.right:\n            self.dfs(root.right, sum - root.val, ls + [root.val], res)",
    "2": "\n    V = int(input())\n    for i in range(V):\n        k = [int(x) for x in input().split()]\n        if len(k) == 250:\n            if max(k) - min(k) <= 10:\n                print(\"poisson\")\n            else:\n                print(\"uniform\")",
    "3": "\n    ",
    "4": "\n        return True",
    "5": "\n        return True",
    "6": "\n    tape = list(tape)\n    data_selector = 0\n    output = []\n    while data_selector < len(tape):\n        if tape[data_selector] == '>':\n            data_selector += 1\n        elif tape[data_selector] == '<':\n            data_selector -= 1\n        elif tape[data_selector] == '+':\n            if tape[data_selector] == 255:\n                tape[data_selector] = 0\n            else:\n                tape[data_selector] += 1\n\n        elif tape[data_selector] == '*':\n\n            output.append(chr(tape[data_selector]))\n\n        else:  # ignore non-command characters.\n\n            pass\n\n        data_selector += 1\n\n    return \"\".join(output)",
    "7": "\n    tape = list(tape)\n    output = []\n    i = 0\n    while i < len(tape):\n        if tape[i] == '>':\n            i += 1\n\n        elif tape[i] == '<':\n            i -= 1\n\n        elif tape[i] == '+':\n            if tape[i-1] == 255:\n                tape[i-1] = 0\n\n            else:\n                tape[i-1] += 1\n\n        elif tape[i] == '*':\n            output.append(chr(tape[i-1]))\n\n        else:\n            pass\n\n    return \"\".join(output)",
    "8": "\n    n, m = map(int, input().split())\n    s = input()\n    dp = [[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if s[i] == s[j]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    print((dp[n-1][m-1])**2)\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        ",
    "9": "\n    n, m = map(int, input().split())\n    s = input()\n    dp = [[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            elif s[i-1] == chr(97+j):\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1 - dp[i-1][j-1]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-1]\n\n    print(dp)\n\n    ans = 0\n\n    for i in range(m):\n        ans += (dp[n - 1][i]) * (dp[n - 1][m - 1])\n\n    print(ans)",
    "10": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = []\n        for j in range(n):\n            a.append([int(x) for x in input().split()])\n        a.sort()\n        print(a[0][1])\n        for j in range(n-1):\n            print(\"{} {}\".format(a[j][0], a[j][1]))",
    "11": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = n\n        b = 1\n        for j in range(n-1):\n            print(a, b)\n            a -= b\n            if a < b:\n                a, b = b, a\n            if a == 1: break",
    "12": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        l = list(map(int, input().split()))\n        x = int(input())\n        max_count = 0\n        max_num = 0\n        for j in l:\n            count = 0\n            while j > 0:\n                if j % 10 == x:\n                    count += 1\n\n                j //= 10\n\n            if count > max_count:\n                max_count = count\n                max_num = j\n\n            elif count == max_count and j < max_num:\n                max_num = j\n\n        print(max_num)",
    "13": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        X = int(input())\n        max_count = 0\n        max_num = 0\n        for j in A:\n            count = 0\n            while j > 0:\n                if j % 10 == X:\n                    count += 1\n                j //= 10\n\n            if count > max_count:\n                max_count = count\n                max_num = j\n\n            elif count == max_count and j < max_num:  # If two or more numbers are having same maximum frequency then output the first occurred number among them in A1,A2,A3,....,AN.  # noqa E501\n\n                max_num = j\n\n        print(max_num)",
    "14": "\n        i = 0\n        while i < len(bits):\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n        return i == len(bits)",
    "15": "\n        i = 0\n        while i < len(bits):\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n\n        return i == len(bits)",
    "16": "\n    n = int(input())\n    for i in range(n):\n        p, q, b = map(int, input().split())\n        if b == 1:\n            print(\"Finite\")\n            continue\n\n        if p == 0:\n            print(\"Finite\")\n            continue\n\n        if p % (b - 1) == 0:\n            print(\"Infinite\")\n            continue\n\n        if q % (b - 1) == 0:\n            print(\"Infinite\")\n            continue\n\n        if p % q == 0:\n            print(\"Infinite\")\n            continue\n\n        if q % p == 0:\n            print(\"Infinite\")\n            continue\n\n        x = min(p, q) // max(p, q) + 1\n\n        while x > 1 and x < b and x != p and x != q:  # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430 \u0434\u0435\u043b\u0438\u043c\u043e\u0441\u0442\u044c \u043d\u0430 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 2 \u0434\u043e b-1. \u0415\u0441\u043b\u0438 \u0447\u0438\u0441\u043b\u043e \u0440\u0430\u0432\u043d\u043e p \u0438\u043b\u0438 q, \u0442\u043e \u044d\u0442\u043e \u0431\u0443\u0434\u0435\u0442 Infinite. \u0415\u0441\u043b\u0438 \u0447\u0438\u0441\u043b\u043e \u0440\u0430\u0432\u043d\u043e 1, \u0442\u043e \u044d\u0442\u043e Finite. \u0418\u043d\u0430\u0447\u0435 Infinite.\n\n            if (x * max(p,q)) % min(p,q) == 0: #\u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e\u0431\u044b \u043e\u043d\u043e \u0431\u044b\u043b\u043e divisible by min(p,q). If it is divisible by min(p,q), then it is divisible by max(p,q). So it is Infinite. Otherwise it is Finite.\n\n                print(\"Finite\") #\u0415\u0441\u043b\u0438 x * max(p,q) / min(p,q) = k*min(p,q), then k*max(p/k*min(p/k), q/k*min(q/k)) = max((max/min)*min((max/min),1), (max/min)*min((max/min),1)). It is the same as max((max/min)*min((max/min),1), (max/(2^b-1))*min((max/(2^b-1)),1)). It is the same as max((max/(2^b-1))*min((max/(2^b-1)),1)). So it is Infinite. Otherwise it is Finite.\n\n                break #\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c k=0..9. If we found that k=0..9 and the result of division was not equal to k*x or k*y then we know that the result of division was not a finite fraction and we can stop checking other values of k from 0 to 9. We can stop checking other values of k because they will be equal to this value of k anyway since they are multiples of 10 from 0 to 9 and this value of k is not a multiple of 10 from 0 to 9. So we can stop checking other values of k from 0 to 9 because they will be equal to this value of k anyway since they are multiples of 10 from 0 to 9 and this value of k is not a multiple of 10 from 0 to 9. And we can stop checking other values of b because they will be equal to this value of b anyway since they are multiples 2^b-1 from 2^0=1 up to 2^18=262143 which are not multiples 2^b-1 for any other b except for this one with which we have found our answer already in the first iteration over all values of b starting with 2 up until 2^18=262143 which are not multiples 2^b-1 for any other b except for this one with which we have found our answer already in the first iteration over all values of b starting with 2 up until 2^18=262143 which are not multiples 2^b-1 for any other b except for this one with which we have found our answer already in the first iteration over all values of b starting with 2 up until 2^18=262143 which are not multiples 2^b-1 for any other b except for this one with which we have found our answer already in the first iteration over all values of b starting with 2 up until 262143 which are not multiples 2^b-1 for any other b except for this one with which we have found our answer already in the first iteration over all values of b starting with 2 up until 262143 which are not multiples 2^b-",
    "17": "\n    n = int(input())\n    for i in range(n):\n        p, q, b = map(int, input().split())\n        if b == 10:\n            print(\"Finite\")\n        else:\n            if p % q == 0:\n                print(\"Finite\")\n            else:\n                print(\"Infinite\")",
    "18": "\n    n, x, y = map(int, input().split())\n    roads = []\n    for i in range(n-1):\n        roads.append(list(map(int, input().split())))\n\n    # print(\"roads:\", roads)\n\n    # find the root of the tree\n    root = 0\n    for i in range(n):\n        if len([x for x in roads if x[0] == i+1]) == 0:\n            root = i+1\n\n    # print(\"root:\", root)\n\n    # find all the leaves of the tree and sort them by their distance to the root (ascending)\n    leaves = [x for x in range(n) if len([y for y in roads if y[1] == x+1]) == 0]\n    leaves.sort(key=lambda x: abs((root - (x + 1))))\n\n    # print(\"leaves:\", leaves)\n\n    # calculate the cost of visiting all leaves and add it to the cost of visiting all nodes except the last one (which is a leave)\n    cost = sum([abs((root - (x + 1))) * y for x in leaves]) + sum([abs((root - (x + 1))) * x for x in range(len(leaves))])\n\n    return cost",
    "19": "\n    n, x, y = map(int, input().split())\n    roads = []\n    for i in range(n - 1):\n        roads.append(list(map(int, input().split())))\n\n    # print(roads)\n\n    def dfs(start):\n        visited[start] = True\n        for i in range(len(roads)):\n            if roads[i][0] == start:\n                if not visited[roads[i][1]]:\n                    dfs(roads[i][1])\n\n    def bfs():\n        q = [0] * (n + 1)  # 0\ubc88\uc9f8 \uc778\ub371\uc2a4\ub97c \ube44\uc6cc\ub450\uace0 \uc2dc\uc791\ud558\uae30 \uc704\ud574.\n        front, rear = -1, -1  # front\ub294 \ub9ac\uc2a4\ud2b8\uc758 \ub9e8 \uc55e\uc758 \uc778\ub371\uc2a4\uc774\uace0 rear\ub294 \ub9ac\uc2a4\ud2b8\uc758 \ub9e8 \ub4a4\uc758 \uc778\ub371\uc2a4.\n\n        rear += 1  # rear\uac00 0\uc774 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ud574\uc11c rear++\ud574\uc8fc\uace0 q[rear] = 0\uc744 \ud574\uc8fc\uba74 0\ubc88\uc9f8 \uc778\ub371\uc2a4\uac00 \uc0dd\uae40.\n        q[rear] = 0\n\n        while front != rear:  # front == rear\uc77c \ub54c while loop break. (front == rear == -1\uc77c \ub54c while loop break.)\n            front += 1  # front++\ud558\ub2c8\uae4c front=0\uc774 \ub428. q[front] = 0\uc774\ub2c8\uae4c start city=0. (q[front]=start city)\n            for i in range(len(roads)):  # len()\ud568\uc218\ub97c \uc4f0\ub2c8 len()-1=3. (4-1=3) -> 3\ud68c looping. -> 4-2=2\ud68c looping... -> 4-3=1\ud68c looping... -> 4-4=0\ud68c looping... -> 4-5=-1\ud68c looping... -> 4-6=-2\ud68c looping... -> 4-7=-3\ud68c looping... -> 4-8=-4\ud68c looping...-> 4-9=-5\ud68c looping....-> 4-10=-6\ud68c looping....-> 4-11=-7\ud68c looping....-> 4-12=-8\ud68c looping....-> 4-13=-9loopin....-> 4-14=-10loopin.....->4-(15)=11loopin.....->4-(16)=12loopin.....->4-(17)=13loopin.....->4-(18)=14loopin.....->4-(19)=15loopin.....->4-(20)=16loopin.....->4-(21)=17loopin.....->4-(22)=18loopin.....=>..>..>..>..>..>..>..>..>..>..>..>..>(len()==23).\n\n                if q[front] == roads[i][0]:  # q[]==0 & roads[]==[[2, 3], [3, 5]] => 2==q[] & 2==roads[].[0]. [2, 3]. [3, 5]. [5, 3]. [3, 1]. [1, 2]. [2, 3]. [3, 5]. [5, 3]. [3, 1]. [1, 2] => True or False? True! So we go to next step!\n\n                    if not visited[roads[i][1]] and not q_visited[roads[i][1]]:  # visited[]==False & q_visited[]==False => False & False => True! We append the city to queue and set the value of visited to True! And we go to next step!\n\n                        rear += 1  # Rear++ so that we can add new city into queue later on! Rear is now equal to 1 because it was 0 before!! And we go to next step!\n\n                        q_visited[roads[i][1]] = True  # We set the value of the city that we just appended into queue as True so that we won't append it"
}