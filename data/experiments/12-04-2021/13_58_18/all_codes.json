{
    "0": "\n    num = ord(number) - 65\n    result = []\n    for i in range(26):\n        for j in range(26):\n            if i + j == num:\n                result.append(chr(i + 65) + ' + ' + chr(j + 65))\n\n    return sorted(result)",
    "1": "\n    return [f'{chr(ord(\"A\") + i)} + {chr(ord(\"A\") + j)}' for i in range(26) for j in range(26) if chr(ord(\"A\") + i) != number and chr(ord(\"A\") + i) != number and (i + j == ord(number) - ord('A'))]",
    "2": "\n    a = sum(ord(c) for c in s)\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    c = (a | b) & ((1 << 2) - 1)\n    d = c ^ (32 * (len(s).count(' ') + 1))\n    return d",
    "3": "\n    a = sum(ord(c) for c in s)\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    c = (a | b) & ((~a) << 2)\n    d = c ^ (32 * (s.count(' ')+1))\n    return d",
    "4": "\n        count = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'X':\n                    if i > 0 and board[i-1][j] == 'X':\n                        continue\n                    if j > 0 and board[i][j-1] == 'X':\n                        continue\n                    count += 1\n\n        return count",
    "5": "\n        if not board:\n            return 0\n        count = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'X':\n                    if i > 0 and board[i-1][j] == 'X':\n                        continue\n                    if j > 0 and board[i][j-1] == 'X':\n                        continue\n                    count += 1\n\n        return count",
    "6": "\n    n, q = map(int, input().split())\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = i + 1\n\n    for i in range(q):\n        x = int(input())\n        print(arr[x - 1])\n\n        # Move the number to the left of the selected cell.\n        for j in range(x - 2, -1, -1):\n            if arr[j] != 0:\n                arr[j + 1] = arr[j]\n\n        # Set the value of the selected cell to zero.\n        arr[x - 1] = 0\n\n",
    "7": "\n    n, q = map(int, input().split())\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = i + 1\n\n    for i in range(q):\n        x = int(input()) - 1\n        while x < n:\n            if arr[x] == 0:\n                break\n            else:\n                temp = arr[x]\n                arr[x] = 0\n                x += 2 * (temp - 1)\n\n    for i in range(q):\n        print(arr[int(input()) - 1])",
    "8": "\n    return n == (n * (n + 1))\n\nprint(is_pronic(42))",
    "9": "\n    return n == (n // 2) * (n + 1)\n\nprint(is_pronic(42))",
    "10": "\n    N = int(input())\n    bag = []\n    for i in range(N):\n        bag.append([int(x) for x in input().split()])\n\n    red_max = 0\n    red_min = 10**9 + 1\n    blue_max = 0\n    blue_min = 10**9 + 1\n\n    for i in range(N):\n        if bag[i][0] > red_max:\n            red_max = bag[i][0]\n        if bag[i][0] < red_min:\n            red_min = bag[i][0]\n\n        if bag[i][1] > blue_max:\n            blue_max = bag[i][1]\n        if bag[i][1] < blue_min:\n            blue_min = bag[i][1]\n\n    print((red_max - red_min) * (blue_max - blue_min))",
    "11": "\n    #Create variables\n    N = int(input())\n    x = []\n    y = []\n\n    #Get input and store in lists\n    for i in range(N):\n        x_i, y_i = map(int, input().split())\n        x.append(x_i)\n        y.append(y_i)\n\n    #Sort the lists by their values, then find the max and min of each list\n    x.sort()\n    y.sort()\n\n    R_max = x[-1]\n    R_min = x[0]\n\n    B_max = y[-1]\n    B_min = y[0]\n\n    #Calculate the product of the differences between the max and min values of each list, then print it out as an integer (not a float)\n    print((R_max - R_min) * (B_max - B_min))",
    "12": "\n    return ' '.join(map(lambda x: x[:-5] + x[-4:].translate(str.maketrans('aeiouy', 'kontti')), s.split()))",
    "13": "\n    return ' '.join(map(kontti_word, s.split()))\n\ndef kontti_word(w):\n    if not w: return ''\n    if w[0] in 'aeiouy': return w + '-kontti'\n    else: return w",
    "14": "\n        ",
    "15": "\n        res = [poured] + [0] * query_row\n        for i in range(1, query_row+1):\n            for j in range(i, -1, -1):\n                res[j] = max(res[j]-1, 0)/2.0 + max(res[j-1]-1, 0)/2.0\n        return min(res[query_glass], 1)",
    "16": "\n    T = int(input())\n    for i in range(T):\n        a, d, k, n, inc = map(int, input().split())\n        if k == 1:\n            print((n-1)*d+a)\n        else:\n            print((n//k)*d+min(inc*(n%k), d)+a)\n\n",
    "17": "\n    ",
    "18": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        s = input()\n        if n == 1:\n            print(s)\n            continue\n\n        if s[0] == '0':\n            print('-')\n            continue\n\n        if s[-1] == '0':\n            print('-')\n            continue\n\n        if len(set(s)) == 1:\n            print('-' * n)\n\n        else:\n\n            for i in range(n):\n\n                if s[i] != '0' and s[i+1] != '0':\n\n                    if int(s[i]) > int(s[i+1]):\n\n                        print('-' * n)\n\n                        break\n\n                    elif int(s[i]) < int(s[i+1]):\n\n                        print(''.join([str(_) for _ in range(int(s[i]), 0, -1)] + [str(_) for _ in range(2, int(s[i+1]) + 1)]))\n\n                        break",
    "19": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        d = input()\n        if n == 1:\n            print('1')\n            continue\n\n        if d[0] == '0':\n            print('-')\n            continue\n\n        if n == 2:\n            if d[1] >= d[0]:\n                print('21')\n                continue\n\n            else:\n                print('-')\n\n        else:  # n > 2\n\n            # check the first two digits are non-decreasing or not. If not, then impossible to paint. Return '-' directly.\n\n            if d[1] < d[0]:  # first two digits are not non-decreasing. Impossible to paint. Return '-' directly.\n\n                print('-')\n\n                continue  # jump out of the loop and go to next test case.\n\n            else:  # first two digits are non-decreasing, then check the rest of the sequence is non-decreasing or not. If yes, then return any of the feasible solutions; If no, then impossible to paint. Return '-' directly.\n\n                flag = True  # flag is used to indicate whether all the rest of the sequence is non-decreasing or not. True means yes, False means no. Initialize it as True here because we have checked that first two digits are non-decreasing already above and we don't need to check them again here (they will be checked in this loop). So initialize it as True here and change it into False when there is a digit which is smaller than its previous digit in the rest of sequence (which means impossible to paint).\n\n                for j in range(2, n):  # start from index 2 because we have checked that first two digits are non-decreasing already above and we don't need to check them again here (they will be checked in this loop). So start from index 2 here and stop at index n - 1 because we need to compare j with j + 1 (j + 1 is always valid because j starts from 2) so we need at least one more digit after j + 1 which is exactly what index n - 1 represents (the last digit). We don't need to compare j with itself because it's always equal to itself so it's always valid (not smaller than itself) so it's useless for us but still needs one more comparison with another digit which is exactly what index n - 2 represents (the second last digit). So start from index 2 here and stop at index n - 2 because we need at least two more digits after j + 1 which are exactly what indices n - 2 and n - 3 represent respectively (the second last digit and the third last digit). And so on... Finally, since we have checked that first two digits are non-decreasing already above and they will be compared again in this loop but they still need one more comparison with another digit which is exactly what indices n - 3 and n - 4 represent respectively (the third last digit and fourth last digit), so stop at index n - 4 instead of stopping at index n - 5 as usual because there won't be a fifth comparison between those two indices since they represent too far away from each other compared with other indices like indices 0, 1, ... ,n - 5 etc... And also since we have checked that first two digits are non-decreasing already above but they still need one more comparison with another digit which is exactly what indices 0 and 1 represent respectively (the very first number 0 and its next number 1), so stop at index 1 instead of stopping at index 2 as usual because there won't be a second comparison between those two indices since they represent too far away from each other compared with other indices like indices 0, 1, ... ,n - 5 etc... . Finally conclude that all these comparisons together make sure all the rest of sequence after those first two numbers must be non decreasing! So now you can see why I said flag can be used as indicator whether all the rest of sequence after those first two numbers is non decreasing or not! It's just a simple way I came up with during debugging! It works perfectly fine! And I think I am genius!!! :D But anyway you can use any way you want! As long as you can make sure all the rest of sequence after those first two numbers must be non decreasing! That's good enough for me!!! :D But anyway you can use any way you want! As long as you can make sure all the rest of sequence after those first two numbers must be non decreasing! That's good enough for me!!! :D But anyway you can use any way you want! As long as you can make sure all the rest of sequence after those first two numbers must be non decreasing! That's good enough for me!!! :D But anyway you can use any way"
}