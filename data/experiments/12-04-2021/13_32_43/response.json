{
    "id": "cmpl-4BVzherRmaR0ikY5clmOufeLuAksp",
    "object": "text_completion",
    "created": 1638649941,
    "model": "davinci-codex:2021-08-03",
    "choices": [
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        p.sort()\n        k = 2\n        while k < n:\n            if abs(p[k-1] - p[k]) <= abs(p[k-2] - p[k]):\n                k += 1\n            else: break\n\n        print(k)\n        print(*p[:k])",
            "index": 0,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        p.sort()\n        dp = [0] * n\n        for i in range(1, n):\n            dp[i] = max([dp[j] + abs(p[i]-p[j]) for j in range(i)])\n\n        print(max(dp))\n\n        ans = []\n        for i in range(n-1, 0, -1):\n            if dp[i] == max([dp[j] + abs(p[i]-p[j]) for j in range(i)]):\n                ans.append(str(p[i]))\n                dp[i-1] -= abs(p[i]-p[i-1])\n\n        print(' '.join([str(_) for _ in reversed([int(_) for _ in ans])]))",
            "index": 1,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    d = {}\n    for i in range(m):\n        if a[i] not in d:\n            d[a[i]] = 0\n\n        if (a[i] & 1) == 0:\n            if (a[i] + 1) in d:\n                d[a[i]] += 1\n\n        if (a[i] & 1) == 1:\n            if (a[i] - 1) in d:\n                d[a[i]] += 1\n\n    print(len([x for x in d.values() if x > 0]))",
            "index": 2,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    d = {}\n    for i in range(m):\n        if a[i] not in d:\n            d[a[i]] = 0\n\n        if (a[i] & 1) == 0:\n            if (a[i] + 1) in d:\n                d[a[i]] += 1\n\n        else:\n            if (a[i] - 1) in d:\n                d[a[i]] += 1\n\n    print(d)\n\n    ans = 0\n\n    for i in range(m):\n        if d[a[i]] == 0:\n            ans += 1\n\n            j = i + 1\n\n            while j < m and a[j] == a[j - 1]: j += 1\n\n            for k in range(j, m):\n                if (a[k] & a[k - 1]) == 0 and ((a[k] | a[k - 1]) not in d or (d.pop((a[k] | a[k - 1]), None)) == 0): ans -= 1\n\n                elif (a[k] & a[k - 1]) != 0 and ((d.pop((a[k] | a [k -1]), None)) == 0): ans -=1\n\n                else: continue\n\n    print(ans)",
            "index": 3,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return int(bin(n)[2:].zfill(32)[::-1], 2)",
            "index": 4,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return int(bin(n)[2:].zfill(8)[::-1], 2)",
            "index": 5,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return sum([x for x in seq if x % 2 == 0])",
            "index": 6,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return sum([x for x in seq if x % 2 == 0])",
            "index": 7,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        max_num = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[i] == arr[j]:\n                    new_arr = arr[:]\n                    new_arr.pop(j)\n                    new_arr.pop(i)\n                    new_num = obtain_max_number(new_arr) * 2  # merge two equal numbers into one bigger number\n\n                elif (arr[i] + arr[j]) % 2 == 0:  # check if the sum of two numbers is even and can be split into two equal numbers each.  If so, split them and add to the max number.  If not, skip this pair of numbers.\n\n                    new_num = (int((arr[i] + arr[j]) / 2)) + obtain_max_number([x for x in arr if x != arr[i] and x != arr[j]])\n\n                else:  # skip this pair of numbers because they cannot be merged or split into a larger number.\n\n                    continue\n\n                if new_num > max_num:  # update the max number with the largest value found so far.\n\n                    max_num = new_num\n\n        return max_num",
            "index": 8,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        max_num = 0\n        for i in range(len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n\n        return max_num\n\n\ndef split_candy(arr, num):\n    new_arr = []\n\n    for i in range(len(arr)):\n        if arr[i] == num:\n            new_arr.append(int(num/2))\n            new_arr.append(int(num/2))\n\n    return new_arr\n\n    \n\n    \n\n    \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \nif __name__ == \"__main__\":  # pragma: no cover  # pragma: no cover  # pragma: no cover  # pragma: no cover  # pragma: no cover  # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   # pragma: no cover   #pragma :no covrre  #pragma :no covrre  #pragma :no covrre  #pragma :no covrre  #pragma :no covrre  ##pragam :no covrre ##pragam :no covrre ##pragam :no covrre ##pragam :no covrre ##pragam :no covrre ##pragam :no covrre ##pragam :nocover# prgama nocover# prgama nocover# prgama nocover# prgama nocover# prgama nocover# prgama nocover# prgama nocover# prgama nocover# prgama nocover##pragam##pragam##pragam##pragam##pragam##pragam##pragam##pragam##pragam##pragam##pragam##pragam## pragan pragan pragan pragan pragan pragan pragan pragan pragan pragan pragan pragan pragan pnagan pnagan pnagan pnagan pnagan pnagan pnagan pnagan pnagan pnagan pnagan pnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnagnanpnangnanngnanngnanngnanngnanngnanngnanngnanngnanngnanngnan ngna ngna ngna ngna ngna ngna ngna ngna ngna ngnamgnangnamgnangnamgnangnamgnangnamgnangnamgnangnamgnangnamgnangm gnangm gnangm gnangm gnangm gnangm gnangm gnangm gnangm gnangan gangan gangan gangan gangan gangan gangan gangan gangan gangan ganga ganga ganga ganga ganga ganga ganga ganga ganga gangana gaana gaana gaana gaana gaana gaana gaana gaana gaana gaanan aanan aanan aanan aanan aanan aanan aanan aanan ananga ananga ananga ananga ananga ananga ananga ananga angaa angaa angaa angaa angaa angaa angaa angaa angaaa naaaa naaaa naaaa naaaa naaaa naaaa naaaa naaaa naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`;",
            "index": 9,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        n, g, b = map(int, input().split())\n        if n == 1:\n            print(1)\n        else:\n            print((g + b - 1) * (n // 2))\n\n\ncode()",
            "index": 10,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        n, g, b = map(int, input().split())\n        if n == 1:\n            print(1)\n        elif n == 2:\n            print(2)\n        else:\n            if (n - g) % (g + b):\n                print((n - g) // (g + b) + 1)\n            else:\n                print((n - g) // (g + b))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncode()",
            "index": 11,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    dp = [[0 for i in range(m+1)] for j in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(1, n+1):\n        for j in range(m+1):\n            if j >= a[i-1]:\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-a[i-1]]) % 1000000007\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    print(dp[n][m])",
            "index": 12,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    # Create a list of lists of all possible sequences of length n with sum less than m\n    sequences = []\n    for i in range(m):\n        sequences.append([i])\n\n    for i in range(1, n):\n        new_sequences = []\n        for seq in sequences:\n            if sum(seq) <= m:\n                for j in range(seq[-1], m):\n                    new_sequences.append(seq + [j])\n\n        sequences = new_sequences\n\n    # Calculate the binomial coefficient for each sequence and add it to the total sum modulo mod.\n    total_sum = 0\n\n    for seq in sequences:\n        prod = 1\n\n        for i in range(len(seq)):\n            prod *= binom_coeff(seq[i], a[i]) % mod\n\n        total_sum += prod % mod\n\n    print((total_sum % mod))",
            "index": 13,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if len(ransomNote) > len(magazine):\n            return False\n        else:\n            for i in set(ransomNote):\n                if ransomNote.count(i) > magazine.count(i):\n                    return False\n            return True",
            "index": 14,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        for i in set(ransomNote):\n            if ransomNote.count(i) > magazine.count(i):\n                return False\n        return True",
            "index": 15,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    return sum(int(i) for i in re.findall('\\d+', string))",
            "index": 16,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    #your code here\n    return sum([int(i) for i in re.findall('\\d+', string)])",
            "index": 17,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        A,B,C = map(int, input().split())\n        if A**2 + B**2 == C**2:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
            "index": 18,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        a,b,c = map(int, input().split())\n        if a**2 + b**2 == c**2:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
            "index": 19,
            "logprobs": null,
            "finish_reason": "stop"
        }
    ]
}