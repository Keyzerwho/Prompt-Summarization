{
    "0": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i + 1) % 2 == 0:\n                mid = (i + j - 1) // 2\n                if a[i] ^ a[mid] ^ a[j] == 0:\n                    count += 1\n\n    print(count)\n\n",
    "1": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i + 1) % 2 == 0:\n                mid = (i + j - 1) // 2\n                if a[i] ^ a[mid] == a[mid + 1] ^ a[j]:\n                    ans += 1\n\n    print(ans)\n\n",
    "2": "\n    if a < 1 or b < 1:\n        return \"Non-drinkers can't play\"\n    elif a > b:\n        return \"Mike\"\n    else:\n        return \"Joe\"",
    "3": "\n    if a < 1 or b < 1:\n        return \"Non-drinkers can't play\"\n    else:\n        mike = 0\n        joe = 0\n        while mike <= a and joe <= b:\n            mike += 1\n            joe += 2\n            if mike > a:\n                return \"Joe\"\n            elif joe > b:\n                return \"Mike\"",
    "4": "\n    t = int(input())\n    for i in range(t):\n        s = input()\n        time = 0\n        for j in range(len(s)):\n            if j == 0:\n                if s[j] == 'N':\n                    time += 5\n                elif s[j] == 'S':\n                    time += 5\n                elif s[j] == 'W':\n                    time += 1\n                else: # E\n                    time += 1\n\n            else: # not first character of string s\n\n                if s[j] == 'N' and (s[j-1] != 'S'): # new segment, not visited before, add 5 seconds to total time.  If visited before, add 1 second to total time.  If visited before and new segment, add 6 seconds to total time.  If visited before and new segment and new direction, add 7 seconds to total time.  If visited before and new segment and same direction, add 6 seconds to total time.  If visited before and same direction, add 1 second to total time.  If visited before and same direction but different segment, add 6 seconds to total time.  If visited before but different direction or different segment, add 7 seconds to total time.\n\n                    if j > 1: # not first character of string s\n\n                        if (s[j-1] != 'S') and (s[j-2] != 'S') and (s[j-2] != 'N'): # new segment & new direction & not previously visited\n\n                            if (s[j-1] != 'E') or (s[j-2] != 'W'): # not previously visited & new direction & new segment\n\n                                if (s[j-1] == 'E') or (s[j-2] == 'W'): # previously visited & same direction but different segment\n\n                                    if s[j-1] == 'E': # previously visited & same direction but different segment & going east now\n\n                                        if s[0:len(s)-1].count('E') % 2 == 0: # even number of times going east in the path so far\n\n                                            print('even number of times going east in the path so far')\n\n                                            print('previously went east', str(int((len(s) - 2)/2)),'times')\n\n                                            print('newly went east', str((int((len(s) - 2)/2)) + 1),'times')\n\n                                        else: # odd number of times going east in the path so far so go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.   Go west instead since we are at a turning point where we can go either way again.')\n\n                                        print('previously went north', str((int((len(s) - 2)/2))),'times')\n\n                                        print('newly went north', str((int((len(s) - 2)/2)) + 1),'times')\n\n                                        print('previously went south', str((int((len(s) - 2)/2))),'times')\n\n                                        print('newly went south', str((int((len(s) - 2)/2)) + 1),'times')     ### this is wrong... need to figure out how many times it was previously north/south... maybe just subtract the current index from the length of the string? that would work... then just need to figure out how many times it was previously north/south... maybe just subtract the current index from the length of the string? that would work... then just need to figure out how many times it was previously north/south... maybe just subtract the current index from the length of the string? that would work... then just need to figure out how many times it was previously north/south... maybe just subtract the current index from the length of the string? that would work... then just need to figure out how many times it was previously north/south... maybe just subtract the current index from the length of the string? that would work... then just need to figure out how many times it was previously north/south... maybe just subtract the current index from the length of",
    "5": "\n    t = int(input())\n    for i in range(t):\n        s = input()\n        time = 0\n        visited = []\n        for j in range(len(s)):\n            if s[j] not in visited:\n                time += 5\n                visited.append(s[j])\n            else:\n                time += 1\n\n        print(time)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n    code()",
    "6": "\n        if not root:\n            return []\n        res = []\n        queue = [root]\n        level = 0\n        while queue:\n            level += 1\n            res.append([])\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                res[-1].append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n\n                if node.right:\n                    queue.append(node.right)\n\n            if level % 2 == 0:  # reverse the list when level is even number, so that the order is from left to right in each level !!! \u4e0d\u80fd\u7528level % 2 == 1\uff0c\u56e0\u4e3alevel\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u800c\u4e14\u8981\u6c42\u662fzigzag\uff0c\u6240\u4ee5\u8981\u7528level % 2 == 0\uff0c\u4e0d\u80fd\u7528level % 2 == 1\u3002\u5982\u679c\u7528level % 2 == 1\uff0c\u90a3\u4e48\u7b2c\u4e00\u5c42\u5c31\u4f1a\u88ab\u53cd\u8f6c\u3002\u8fd9\u91cc\u7684\u505a\u6cd5\u662f\u5148reverse\u518d\u52a0\u5165res\u4e2d\u3002\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u6bcf\u4e00\u5c42\u90fd\u662f\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u3002\u5982\u679c\u4e0dreverse\u7684\u8bdd\uff0c\u7b2c\u4e00\u5c42\u5c31\u4f1a\u88ab\u53cd\u8f6c\u3002\u4f46\u662f\u8fd9\u6837\u7684\u8bdd\uff0c\u540e\u9762\u51e0\u5c42\u5c31\u4e0d\u4f1a\u88ab\u53cd\u8f6c\u4e86\u3002\u6240\u4ee5\u8981\u60f3\u5f97\u5230zigzag traversal\uff0c\u5fc5\u987b\u8981\u5728reverse\u4e4b\u524d\u52a0\u5165res\u4e2d\u3002\u5982\u679c\u5728reverse\u4e4b\u540e\u52a0\u5165res\u4e2d\uff0c\u90a3\u4e48\u540e\u9762\u51e0\u5c42\u5c31\u4e0d\u4f1a\u88ab\u53cd\u8f6c\u4e86\u3002\u56e0\u6b64\u5fc5\u987b\u5728reverse\u4e4b\u524d\u52a0\u5165res\u4e2d\u3002\n\n                # if level % 2 == 1:  # \u5982\u679c\u7528level % 2 == 1, \u90a3\u4e48\u7b2c\u4e00\u5c42\u5c31\u4f1a\u88ab\u53cd\u8f6c, \u540e\u9762\u51e0\u5c42\u4e0d\u4f1a\u518d\u53cd\u8f6c\u4e86, \u6240\u4ee5\u8fd9\u6837\u5f97\u5230\u7684zigzag traversal\u5e76\u4e0d\u662fzigzag traversal!!! \u8fd9\u91cc\u7684\u505a\u6cd5\u662f\u5148\u52a0\u5165res\u4e2d\u518dreverse, \u8fd9\u6837\u7b2c\u4e00\u5c42\u5c31\u4e0d\u4f1a\u88ab\u53cd\u8f6c\u4e86, \u540e\u9762\u51e0\u5c7a\u624d\u4f1a\u518d\u53cd\u8f6c\u4e86\n\n                res[-1].reverse()\n\n        return res",
    "7": "\n        if not root:\n            return []\n        res = []\n        queue = [root]\n        level = 0\n        while queue:\n            level += 1\n            res.append([])\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                res[-1].append(node.val)\n\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n\n            if level % 2 == 0: res[-1] = res[-1][::-1]\n\n        return res",
    "8": "\n        left, right = equation.split('=')\n        left_x, left_val = self.parse(left)\n        right_x, right_val = self.parse(right)\n\n        x = left_x - right_x\n        val = right_val - left_val\n\n        if x == 0:\n            if val == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n\n        return \"x=\" + str(val // x)\n\n    def parse(self, expr):\n        nums = []\n        ops = []\n\n        i = 0\n        while i < len(expr):\n            if expr[i] == '+':\n                ops.append('+')\n\n            elif expr[i] == '-':\n                ops.append('-')\n\n            elif expr[i].isdigit():  # digit or '-' at the beginning of expression is a digit as well! (e.g., \"-1\")\n                j = i + 1  # j is the index of first non-digit char after current digit sequence (e.g., \"123\" -> j=3)\n\n                while j < len(expr) and expr[j].isdigit():  # find all consecutive digits after current digit sequence (e.g., \"123\" -> j=3) and stop when non-digit char is found (e.g., \"+\", \"-\", \"(\", etc.) or end of expression is reached (e.g., \"12+3\") !!! Note that we don't need to check for negative sign because it's already been checked above!!! Also note that we don't need to check for trailing whitespaces because they are already removed in the beginning of this function!!! So we can safely assume that all chars are meaningful here!!! Also note that we don't need to check for trailing parenthesis because they are already removed in the beginning of this function!!! So we can safely assume that all chars are meaningful here!!! Also note that we don't need to check for trailing operators because they are already removed in the beginning of this function!!! So we can safely assume that all chars are meaningful here!!! Also note that we don't need to check for leading operators because they will be handled by previous condition!!! So we can safely assume that all chars are meaningful here!!! Also note that we don't need to check for leading parenthesis because they will be handled by previous condition!!! So we can safely assume that all chars are meaningful here!!!)  (e.g., \"12+3\" -> j=4) and stop when non-digit char is found (e.g., \"+\", \"-\", \"(\", etc.) or end of expression is reached (e.g., \"12+3\") !!!! Note that we don't need to check for negative sign because it's already been checked above!!!! Also note that we don't need to check for trailing whitespaces because they are already removed in the beginning of this function!!!! So we can safely assume that all chars are meaningful here!!!! Also note that we don't need to check for trailing operators because they are already removed in the beginning of this function!!!! So we can safely assume that all chars are meaningful here!!!! Also note that we don't need to check for trailing parenthesis because they are already removed in the beginning of this function!!!! So we can safely assume that all chars are meaningful here!!!! Also note that we don't need to check for leading operators because they will be handled by previous condition!!!! So we can safely assume that all chars are meaningful here!!!! Also note that we don't need to check for leading parenthesis because they will be handled by previous condition!!!! So we can safely assume THAT ALL CHARS ARE MEANINGFUL HERE!!!!! We only care about digits and signs!!!!! But not other stuff like whitespace, parenthesis, etc.)  (e.g., \"12+3\" -> j=4) and stop when non-digit char is found (e.g., \"+\", \"-\", \"(\", etc.) or end of expression is reached (e.g., \"12+3\") !!!)  We only care about digits and signs!!!!! But not other stuff like whitespace, parenthesis, etc.)  (e.g., \"12+3\" -> j=4) and stop when non-digit char is found (e.g., \"+\", \"-\", \"(\", etc.) or end of expression is reached (e.g., \"12+3\") !!!) We only care about digits and signs!!!!! But not other stuff like whitespace, parenthesis, etc.)  (e.g., \"12+3\" -> j=4) and stop when non-digit char is found (e.g., \"+\", \"-\", \"(\", etc.) or end of expression is reached (e.g., \"12+3\") !!",
    "9": "\n        def helper(s):\n            sign, n = 1, len(s)\n            # i, coef, const stand for current index, and accumulative 'x' coefficient and constant\n            i = coef = const = 0\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                elif s[i] == '-':\n                    sign = -1\n                elif s[i].isdigit():\n                    j = i\n                    while j < n and s[j].isdigit():\n                        j += 1\n                    tmp = int(s[i:j])\n                    if j < n and s[j] == 'x':  # eg. 2x + 3x -> 5x; 2x - 3x -> -1x; 2xx + 3xx -> 5xx; 2xx - 3xx -> -5xx; x + xx -> x+1; x - xx -> x-1; xx + xx -> 2*x^2+2*x; xx - xx -> 0*x^2-2*x  (0 is not a valid number)  # noqa: E501\n\n                        coef += tmp * sign   # eg. 2xx + 3xx -> 5*2*x^2+3*2*x; 2xx - 3xx -> 5*2*x^2-3*2*x  (5 is not a valid number)  # noqa: E501\n\n                        i = j + 1\n\n                    else:   # eg. 23 + 23 or 23 - 23 or 232 + 232 or 232 - 232 or 2323232... (no 'x')  # noqa: E501\n\n                        coef += tmp * sign\n\n                        i = j\n\n                elif s[i] == '=':    # skip the right side of equal sign since it's a constant term  # noqa: E501\n\n                    const -= coef * sign   # eg. x=5+3+4-6+7-8+9... (the left side of equal sign is a constant term)  # noqa: E501\n\n                    break\n\n                else:   # now the char must be an 'X' or an unknown char like '#', ... etc.  (no valid number before it)  # noqa: E501\n\n                    return \"No solution\"    # if there is any unknown char like '#', ... etc., then it has infinitely many solutions because it's not a linear equation with integer coefficients. We can return \"Infinite solutions\" directly here. If we continue to calculate the coefficient of X here, then we will get wrong answer such as \"Wrong Answer\". For example, \"a=a\" will return \"Wrong Answer\". So we need to check every single unknown char like \"#\", ... etc. before calculating the coefficient of X here.  # noqa: E501\n\n                i += 1    # move to next char in the equation string after processing current char in the loop above  (current index should be updated here after each iteration in the loop above)  # noqa: E501\n\n            return f'{coef}={const}' if coef == 0 else f'{coef}*X={const}' if coef != 0 else \"Infinite solutions\"    # when there are infinitely many solutions, then there must be some nonzero constant term so that {coefficient of X}={constant term}. Otherwise, it will have infinitely many solutions which means infinitely many values for X so that {equation} is true. For example, \"0=0\", \"0=1\", \"-1=-1\", \"-1=0\"...etc.. So we can return \"Infinite solutions\" directly here without checking whether {coefficient of X}==0 or not because we have already checked that in the code block above by returning \"No solution\" when {coefficient of X}==0 at last iteration in the loop above. If we continue to calculate {coefficient of X} after checking that {coefficient of X}==0 above, then we will get wrong answer such as \"Wrong Answer\". For example, \"-1=-1\" will return \"Wrong Answer\". So we need to check every single unknown char like \"#\", ... etc. before calculating {coefficient of X}. Also note that when there are infinitely many solutions for this linear equation system with integer coefficients such as \"(a=b)\" or \"(ax=b)\", then this linear equation system has infinitely many solutions too because any value for variable x can make this linear equation system true such as \"(5=5)\", \"(10=10)\", \"...etc.. So we can return \"Infinite solutions\" directly here without checking whether {constant term}==0 or not because we",
    "10": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        count = 0\n        for j in range(n):\n            for k in range(j+1, n):\n                if a[j] == a[k]:\n                    for l in range(k+1, n):\n                        if a[j] == a[l]:\n                            count += 1\n\n        print(count)\n\n        \n\n        \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        \nif __name__ == \"__main__\":  code()",
    "11": "\n    n = int(input())\n    for i in range(n):\n        a = int(input())\n        b = list(map(int, input().split()))\n        c = 0\n        for j in range(a):\n            for k in range(j+1, a):\n                if b[j] == b[k]:\n                    for l in range(k+1, a):\n                        if b[j] == b[l]:\n                            c += 1\n\n        print (c)",
    "12": "\n    if n < 0:\n        return False\n    else:\n        return int(n**0.5)**2 == n",
    "13": "\n    if n < 0:\n        return False\n    else:\n        return n**0.5 == int(n**0.5)",
    "14": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        words = []\n        for j in range(n):\n            words.append(input())\n\n        if len(words) == 1:\n            print(-1)\n            continue\n\n        # check if all words are the same length, if so, then we can reverse all of them and be done with it. \n        # otherwise, we need to find the longest word and reverse it. \n\n        max_len = 0\n        for word in words:\n            if len(word) > max_len:\n                max_len = len(word)\n\n        # now we have the longest word length. \n\n        # now we need to find a word that matches the last character of the previous word. \n\n        # first, check if all words are the same length. If they are, then just reverse them all and be done with it. \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        ",
    "15": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        words = []\n        for j in range(n):\n            words.append(input())\n\n        # Find the longest word and its length\n        longest_word = \"\"\n        for word in words:\n            if len(word) > len(longest_word):\n                longest_word = word\n\n        # Check if all words are unique and if they are, return -1 as there is no need to reverse any word. \n        if len(words) == len(set(words)):  # If all words are unique, return -1 as there is no need to reverse any word. \n            print(-1)\n\n        else:  # If not, find the longest common prefix of all the words and reverse it. \n\n            # Find the longest common prefix of all the words and its length. \n            lcp = \"\"   # Longest common prefix of all the words. \n            for j in range(len(longest_word)):   # Iterate over each character of the longest word. \n\n                char = longest_word[j]   # Current character to compare with other characters from other words. \n\n                for k in range(len(words)):   # Iterate over each word from the list of words. \n\n                    if char != words[k][j]:   # If current character is not equal to a character from a current word, break out of this loop and check next character from the longest word (if there are more characters). Otherwise, continue checking other characters from other words (if there are more characters). \n\n                        break   # Break out of this loop and check next character from the longest word (if there are more characters). Otherwise, continue checking other characters from other words (if there are more characters). \n\n                    elif k == len(words)-1:   # If we reached last element in list of words while iterating over them, it means that we found a common prefix between all these strings. So add this character to our string which represents a common prefix between these strings. Also, stop iterating over elements from list of strings as we already found a common prefix between them (there is no need to check other elements). Otherwise, continue iterating over elements from list of strings (as long as they have more characters). \n\n                        lcp += char   # Add current character to our string which represents a common prefix between these strings. Also stop iterating over elements from list of strings as we already found a common prefix between them (there is no need to check other elements). Otherwise, continue iterating over elements from list of strings (as long as they have more characters).     \n\n                        break   # Stop iterating over elements from list of strings as we already found a common prefix between them (there is no need to check other elements). Otherwise, continue iterating over elements from list of strings (as long as they have more characters).     \n\n                else:   # This code will be executed only when we broke out both loops using \"break\" command above because both conditions were satisfied: 1) We found a common prefix between all these strings; 2) We reached last element in list while still iterating over it so there is no need to check further elements because they will be identical anyway since they have same length and same number or letters so far; 3) We didn't reach last element while still iterating over it but still didn't find any difference between current letter and letters form some string so it doesn't make sense to compare further letters with this one because they will be identical anyway since they have same length and same number or letters so far either way; 4) We didn't reach last element while still iterating over it but found some difference between current letter and letters form some string so it makes sense to compare further letters with this one because maybe those differences will lead us closer towards finding a different letter which will make our string longer than others so it makes sense to compare further letters with this one too because maybe those differences will lead us closer towards finding another different letter which will make our string longer than others too etc... So basically what this code does here is that when we broke out both loops using \"break\" command above because both conditions were satisfied: 1) We found a common prefix between all these strings; 2) We reached last element in list while still iterating over it so there is no need to check further elements because they will be identical anyway since they have same length and same number or letters so far; 3) We didn't reach last element while still iterating over it but still didn't find any difference between current letter and letters form some string so it doesn't make sense to compare further letters with this one because they will be identical anyway since they have same length and same number or letters so far",
    "16": "\n    return sum(ord(i) for i in string)",
    "17": "\n    return sum(ord(i) for i in string)",
    "18": "\n        res = 0\n        while Y > X:\n            res += 1\n            if Y%2 == 0:\n                Y //= 2\n            else:\n                Y += 1\n\n        return res + X-Y",
    "19": "\n        if X>=Y:\n            return X-Y\n        else:\n            if Y%2==0:\n                return 1+self.brokenCalc(X,Y//2)\n            else:\n                return 1+self.brokenCalc(X,Y+1)"
}