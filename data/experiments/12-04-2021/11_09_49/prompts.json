{
    "0": "Python 3\n\"\"\"\n Polycarp takes part in a quadcopter competition. According to the rules a flying robot should:   start the race from some point of a field,  go around the flag,  close cycle returning back to the starting point. Polycarp knows the coordinates of the starting point (x_1, y_1) and the coordinates of the point where the flag is situated (x_2, y_2). Polycarp s quadcopter can fly only parallel to the sides of the field each tick changing exactly one coordinate by 1. It means that in one tick the quadcopter can fly from the point (x, y) to any of four points: (x - 1, y), (x + 1, y), (x, y - 1) or (x, y + 1). Thus the quadcopter path is a closed cycle starting and finishing in (x_1, y_1) and containing the point (x_2, y_2) strictly inside.  [Image] The picture corresponds to the first example: the starting (and finishing) point is in (1, 5) and the flag is in (5, 2).  What is the minimal length of the quadcopter path \n-----Input----- The first line contains two integer numbers x_1 and y_1 ( - 100 \u2264 x_1, y_1 \u2264 100) \u2014 coordinates of the quadcopter starting (and finishing) point. The second line contains two integer numbers x_2 and y_2 ( - 100 \u2264 x_2, y_2 \u2264 100) \u2014 coordinates of the flag. It is guaranteed that the quadcopter starting point and the flag do not coincide. -----Output----- Print the length of minimal path of the quadcopter to surround the flag and return back. -----Examples----- Input 1 5 5 2 Output 18 Input 0 1 0 0 Output 8\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nPolycarp takes part in a quadcopter competition. According to the rules a flying robot should:\n\n  start the race from some point of a field,  go around the flag,  close cycle returning back to the starting point. \n\nPolycarp knows the coordinates of the starting point (x_1, y_1) and the coordinates of the point where the flag is situated (x_2, y_2). Polycarp\u2019s quadcopter can fly only parallel to the sides of the field each tick changing exactly one coordinate by 1. It means that in one tick the quadcopter can fly from the point (x, y) to any of four points: (x - 1, y), (x + 1, y), (x, y - 1) or (x, y + 1).\n\nThus the quadcopter path is a closed cycle starting and finishing in (x_1, y_1) and containing the point (x_2, y_2) strictly inside.\n\n [Image] The picture corresponds to the first example: the starting (and finishing) point is in (1, 5) and the flag is in (5, 2). \n\nWhat is the minimal length of the quadcopter path?\n\n\n-----Input-----\n\nThe first line contains two integer numbers x_1 and y_1 ( - 100 \u2264 x_1, y_1 \u2264 100) \u2014 coordinates of the quadcopter starting (and finishing) point.\n\nThe second line contains two integer numbers x_2 and y_2 ( - 100 \u2264 x_2, y_2 \u2264 100) \u2014 coordinates of the flag.\n\nIt is guaranteed that the quadcopter starting point and the flag do not coincide.\n\n\n-----Output-----\n\nPrint the length of minimal path of the quadcopter to surround the flag and return back.\n\n\n-----Examples-----\nInput\n1 5\n5 2\n\nOutput\n18\n\nInput\n0 1\n0 0\n\nOutput\n8\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n You have a constant strength $s$, and a decreasing energy reserve $e$. For each lift, you may choose any positive (not necessarily integer) weight $w$ to attempt. If $s \\ge w$, the lift succeeds and your energy goes down by $e_{\\text {success}}$; if $s < w$, the lift fails and your energy goes down by $e_{\\text {failure}}$. You may continue attempting lifts as long as $e > 0$. If at any point $e \\le 0$, you can make no further attempts. Your score is the maximum weight you successfully lift or $0$ if every attempt failed. Ideally, you should lift exactly at your strength limit. However, you do not know your strength $s$. You only know that you can definitely lift the empty bar ($25\\text { kg}$), and that the maximum conceivable lift is $225\\text { kg}$. How close to an optimal score can you guarantee  That is, what s the smallest $d$ for which you can ensure a score of at least $s-d$  For example, suppose $e = 4$, $e_{\\text {success}} = 1$ and $e_{\\text {failure}} = 2$. You try to lift $200\\text { kg}$ and fail. Now, $e = 2$. You try $100\\text { kg}$ and succeed. Now, $e = 1$. You try $150\\text { kg}$ and succeed. Now, $e = 0$ and you must stop. You know that you can lift $150\\text { kg}$, but you cannot lift $\n-----Input----- Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input consists of a single line with $3$ space-separated integers $e$, $e_{\\text {success}}$, $e_{\\text {failure}}$ ($1 \\le e, e_{\\text {success}}, e_{\\text {failure}} \\le 10^7$) where $e$ is your beginning energy reserve, $e_{\\text {success}}$ is the amount of energy expended in a successful lift, and $e_{\\text {failure}}$ is the amount of energy expended in a failed lift. -----Output----- Output a single line with a real number $d$, which is the minimum weight in $\\text {kg}$ such that you can ensure a score of at least $s-d$. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$. -----Examples----- Sample Input 1: 1 3 3 Sample Output 1: 112.5 Sample Input 2: 12 3 3 Sample Output 2: 13.333333333333334\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nIn competitive weightlifting, you must perform a sequence of lifts. You have a constant strength $s$, and a decreasing energy reserve $e$. For each lift, you may choose any positive (not necessarily integer) weight $w$ to attempt. If $s \\ge w$, the lift succeeds and your energy goes down by $e_{\\text {success}}$; if $s < w$, the lift fails and your energy goes down by $e_{\\text {failure}}$. You may continue attempting lifts as long as $e > 0$. If at any point $e \\le 0$, you can make no further attempts. Your score is the maximum weight you successfully lift or $0$ if every attempt failed.\n\nIdeally, you should lift exactly at your strength limit. However, you do not know your strength $s$. You only know that you can definitely lift the empty bar ($25\\text { kg}$), and that the maximum conceivable lift is $225\\text { kg}$. How close to an optimal score can you guarantee? That is, what\u2019s the smallest $d$ for which you can ensure a score of at least $s-d$?\n\nFor example, suppose $e = 4$, $e_{\\text {success}} = 1$ and $e_{\\text {failure}} = 2$. You try to lift $200\\text { kg}$ and fail. Now, $e = 2$. You try $100\\text { kg}$ and succeed. Now, $e = 1$. You try $150\\text { kg}$ and succeed. Now, $e = 0$ and you must stop. You know that you can lift $150\\text { kg}$, but you cannot lift $200\\text { kg}$. Your strength $s$ must be somewhere between $150\\text { kg}$ and $200\\text { kg}$. You scored $150$, your optimal score might be as high as (just under) $200$. You still don\u2019t know $s$, but you know you\u2019re within $50$. In this case, $d = 50$.\n\nThat\u2019s a specific example, and the strategy used is certainly not optimal. You can do better. What\u2019s the smallest value of $d$ you can get so that you can guarantee a score of at least $s-d$ for any and all possible values of $s$?\n\n-----Input-----\nEach input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input consists of a single line with $3$ space-separated integers $e$, $e_{\\text {success}}$, $e_{\\text {failure}}$ ($1 \\le e, e_{\\text {success}}, e_{\\text {failure}} \\le 10^7$) where $e$ is your beginning energy reserve, $e_{\\text {success}}$ is the amount of energy expended in a successful lift, and $e_{\\text {failure}}$ is the amount of energy expended in a failed lift.\n\n-----Output-----\nOutput a single line with a real number $d$, which is the minimum weight in $\\text {kg}$ such that you can ensure a score of at least $s-d$. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.\n\n-----Examples-----\nSample Input 1:\n1 3 3\nSample Output 1:\n112.5\n\nSample Input 2:\n12 3 3\nSample Output 2:\n13.333333333333334\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\n Your task is to write a function `toLeetSpeak` that converts a regular english sentence to Leetspeak. Consider only uppercase letters and spaces. \n-----Input----- The first line contains integer n (1 \u2264 n \u2264 2\u00b710^5) \u2014 number of parts of the street. Each of the following n lines contains two integers s_{i}, g_{i} (1 \u2264 s_{i} \u2264 10^6, 0 \u2264 g_{i} \u2264 10^6) \u2014 current width of road and width of the lawn on the i-th part of the street. -----Output----- In the first line print the total width of lawns which will be removed. In the second line print n integers s'_1, s'_2, ..., s'_{n} (s_{i} \u2264 s'_{i} \u2264 s_{i} + g_{i}) \u2014 new widths of the road starting from the first part and to the last. If there is no solution, print the only integer -1 in the first line. -----Examples----- Input 3 4 5 4 5 4 10 Output 16 9 9 10  Input 4 1 100 100 1 1 100 100 1 Output 202 101 101 101 101  Input 3 1 1 100 100 1 1 Output -1\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nMayor of city S just hates trees and lawns. They take so much space and there could be a road on the place they occupy!\n\nThe Mayor thinks that one of the main city streets could be considerably widened on account of lawn nobody needs anyway. Moreover, that might help reduce the car jams which happen from time to time on the street.\n\nThe street is split into n equal length parts from left to right, the i-th part is characterized by two integers: width of road s_{i} and width of lawn g_{i}. [Image] \n\nFor each of n parts the Mayor should decide the size of lawn to demolish. For the i-th part he can reduce lawn width by integer x_{i} (0 \u2264 x_{i} \u2264 g_{i}). After it new road width of the i-th part will be equal to s'_{i} = s_{i} + x_{i} and new lawn width will be equal to g'_{i} = g_{i} - x_{i}.\n\nOn the one hand, the Mayor wants to demolish as much lawn as possible (and replace it with road). On the other hand, he does not want to create a rapid widening or narrowing of the road, which would lead to car accidents. To avoid that, the Mayor decided that width of the road for consecutive parts should differ by at most 1, i.e. for each i (1 \u2264 i < n) the inequation |s'_{i} + 1 - s'_{i}| \u2264 1 should hold. Initially this condition might not be true.\n\nYou need to find the the total width of lawns the Mayor will destroy according to his plan.\n\n\n-----Input-----\n\nThe first line contains integer n (1 \u2264 n \u2264 2\u00b710^5) \u2014 number of parts of the street.\n\nEach of the following n lines contains two integers s_{i}, g_{i} (1 \u2264 s_{i} \u2264 10^6, 0 \u2264 g_{i} \u2264 10^6) \u2014 current width of road and width of the lawn on the i-th part of the street.\n\n\n-----Output-----\n\nIn the first line print the total width of lawns which will be removed.\n\nIn the second line print n integers s'_1, s'_2, ..., s'_{n} (s_{i} \u2264 s'_{i} \u2264 s_{i} + g_{i}) \u2014 new widths of the road starting from the first part and to the last.\n\nIf there is no solution, print the only integer -1 in the first line.\n\n\n-----Examples-----\nInput\n3\n4 5\n4 5\n4 10\n\nOutput\n16\n9 9 10 \n\nInput\n4\n1 100\n100 1\n1 100\n100 1\n\nOutput\n202\n101 101 101 101 \n\nInput\n3\n1 1\n100 100\n1 1\n\nOutput\n-1\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\n In geometry, ellipses are defined by two focal points $f_1, f_2$ and a length $D$. The ellipse consists of all points $p$ such that $\\mathop {\\mathrm{distance}}(f_1, p) + \\mathop {\\mathrm{distance}}(f_2, p) = D$. When one normally thinks of ellipses, it is in the context of the Euclidean 2D plane, with the Euclidean distance as a distance measure. This problem explores a different kind of ellipse. The space we will work in is the space of words of length $n$ using an alphabet of $q$ different symbols, often denoted as $F_ q^n$. As you can probably see, for given values of $q$ and $n$, there are $q^n$ different words (points) in the space $F_ q^n$. For a distance measure, we use the Hamming distance. The Hamming distance between two words $x, y \\in F_ q^n$ is simply the number of positions where the symbols that make up the words $x$ and $y$ differ. For example, the Hamming distance between words 01201 and 21210 is 3 because there are 3 positions where the words have different symbols. The Hamming distance between any two words in $F_ q^n$ will always be an integer between $0$ and $n$, inclusive. Within the space $F_ q^n$, we now define the Hamming ellipse as the set of all points $p$ such that $\\mathop {\\mathrm{ham\n-----Input----- The first line contains three integers $q$ ($2 \\le q \\le 10$), $n$ ($1 \\le n \\le 100$) and $D$ ($1 \\le D \\le 2 n$). The second and third lines specify the two focal points $f_1$ and $f_2$, each formatted as a string of length $n$ using digits $\\{ 0, 1 \\ldots q - 1\\} $. -----Output----- Output one line containing a single integer, denoting the number of points on the ellipse. The input is chosen such that the answer is less than $2^{63}$. -----Examples----- Sample Input 1: 3 5 9 01201 21210 Sample Output 1: 24 Sample Input 2: 4 6 5 123031 231222 Sample Output 2: 0\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nIn geometry, ellipses are defined by two focal points $f_1, f_2$ and a length $D$. The ellipse consists of all points $p$ such that $\\mathop {\\mathrm{distance}}(f_1, p) + \\mathop {\\mathrm{distance}}(f_2, p) = D$.\n\nWhen one normally thinks of ellipses, it is in the context of the Euclidean 2D plane, with the Euclidean distance as a distance measure.\n\nThis problem explores a different kind of ellipse. The space we will work in is the space of words of length $n$ using an alphabet of $q$ different symbols, often denoted as $F_ q^n$. As you can probably see, for given values of $q$ and $n$, there are $q^n$ different words (points) in the space $F_ q^n$.\n\nFor a distance measure, we use the Hamming distance. The Hamming distance between two words $x, y \\in F_ q^n$ is simply the number of positions where the symbols that make up the words $x$ and $y$ differ. For example, the Hamming distance between words 01201 and 21210 is 3 because there are 3 positions where the words have different symbols. The Hamming distance between any two words in $F_ q^n$ will always be an integer between $0$ and $n$, inclusive.\n\nWithin the space $F_ q^n$, we now define the Hamming ellipse as the set of all points $p$ such that $\\mathop {\\mathrm{hammingdistance}}(f_1, p) + \\mathop {\\mathrm{hammingdistance}}(f_2, p) = D$. Given values $q$ and $n$, focal points $f_1$ and $f_2$ and distance $D$, we ask you to determine the number of points $p \\in F_ q^n$ that lie on this Hamming ellipse.\n\n-----Input-----\nThe first line contains three integers $q$ ($2 \\le q \\le 10$), $n$ ($1 \\le n \\le 100$) and $D$ ($1 \\le D \\le 2 n$).\n\nThe second and third lines specify the two focal points $f_1$ and $f_2$, each formatted as a string of length $n$ using digits $\\{ 0, 1 \\ldots q - 1\\} $.\n\n-----Output-----\nOutput one line containing a single integer, denoting the number of points on the ellipse.\n\nThe input is chosen such that the answer is less than $2^{63}$.\n\n-----Examples-----\nSample Input 1:\n3 5 9\n01201\n21210\nSample Output 1:\n24\n\nSample Input 2:\n4 6 5\n123031\n231222\nSample Output 2:\n0\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\n You are given a set $B$ of positive integers. Find a subset of minimum size from $B$ so that graph built on the new set is bipartite. \n-----Input----- First line contains an integer $n ~ (1 \\leqslant n \\leqslant 200\\,000)$\u00a0\u2014 size of $B$ Second line contains $n$ integers $b_1, b_2, \\ldots, b_n ~ (1 \\leqslant b_i \\leqslant 10^{18})$\u00a0\u2014 numbers of $B$, all $b_i$ are unique -----Output----- In the first line print single integer $k$ \u2013 the number of erased elements. In the second line print $k$ integers\u00a0\u2014 values of erased elements. If there are multiple answers, print any of them. -----Examples----- Input 3 1 2 3 Output 1 2  Input 2 2 6 Output 0\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nBoy Dima gave Julian a birthday present\u00a0\u2014 set $B$ consisting of positive integers. However, he didn't know, that Julian hates sets, but enjoys bipartite graphs more than anything else!\n\nJulian was almost upset, but her friend Alex said, that he can build an undirected graph using this set in such a way: let all integer numbers be vertices, then connect any two $i$ and $j$ with an edge if $|i - j|$ belongs to $B$.\n\nUnfortunately, Julian doesn't like the graph, that was built using $B$. Alex decided to rectify the situation, so he wants to erase some numbers from $B$, so that graph built using the new set is bipartite. The difficulty of this task is that the graph, Alex has to work with, has an infinite number of vertices and edges! It is impossible to solve this task alone, so Alex asks you for help. Write a program that erases a subset of minimum size from $B$ so that graph constructed on the new set is bipartite.\n\nRecall, that graph is bipartite if all its vertices can be divided into two disjoint sets such that every edge connects a vertex from different sets.\n\n\n-----Input-----\n\nFirst line contains an integer $n ~ (1 \\leqslant n \\leqslant 200\\,000)$\u00a0\u2014 size of $B$\n\nSecond line contains $n$ integers $b_1, b_2, \\ldots, b_n ~ (1 \\leqslant b_i \\leqslant 10^{18})$\u00a0\u2014 numbers of $B$, all $b_i$ are unique\n\n\n-----Output-----\n\nIn the first line print single integer $k$ \u2013 the number of erased elements. In the second line print $k$ integers\u00a0\u2014 values of erased elements.\n\nIf there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n1\n2 \nInput\n2\n2 6\n\nOutput\n0\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\n Given a set of cards dealt to you and a history of suggestions and evidence, you need to decide how close you are to being able to make an accusation. \n-----Input----- The input starts with an integer $n$ ($1 \\le n \\le 50$), the number of suggestions made during the game. Following this is a line containing the five cards you are dealt, all uppercase letters in the range \u2018A\u2019\u2026\u2018U\u2019. The remaining $n$ lines contain one suggestion per line. Each of these lines starts with three characters representing the suggestion (in the order person, weapon, room), followed by the responses of up to three players, beginning with the player to the right of the player making the suggestion. If a player presents no evidence, a \u2018-\u2019 (dash) is listed; otherwise an \u201cevidence character\u201d is listed. If the specific evidence card is seen by you (either because you provided it or you were the person receiving the evidence) then the evidence character identifies that card; otherwise the evidence character is \u2018*\u2019. Note that only the last response can be an evidence character. All characters are separated by single spaces. Only valid suggestion/response sequences appear in the input. -----Output----- Display a three character string identifying the murderer, the murder weapon, and the room. If the murderer can be identified, use the appropriate letter for that person; otherwise use \u2018?\u2019. Do the same for the murder weapon and the room. -----Examples----- Sample Input 1: 1 B I P C F A G M - - - Sample Output 1: AGM Sample Input 2: 2 A B C D H F G M M F H M - * Sample Output 2: E??\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nDeveloped in the 1940s in the United Kingdom, the game of Cluedo is one of the most popular board games in the world. The object of the game is to determine who murdered Mr.\u00a0Body, which weapon was used to murder him, and where the murder took place. The game uses a set of cards representing six persons (labeled A, B, \u2026, F), six weapons (labeled G, H, \u2026, L) and nine rooms (labeled M, N, \u2026, U). At the start of the game, one person card, one weapon card, and one room card are selected at random and removed from the deck so no one can see them \u2013 they represent the murderer, the murder weapon, and the murder location. The remaining $18$ cards are shuffled and dealt to the players, starting with player $1$, then to her right player $2$, and so on. Some players may end up with one more card than others. For the purposes of this problem there are four players, so the person to the right of player $4$ is player $1$.\n\nThe rest of the game is spent searching for clues. Players take turns, starting with player 1 and moving to the right. A turn consists of making a suggestion (consisting of a murder suspect, a weapon, and a room) and asking other players if they have any evidence that refutes the suggestion. For example, you might say to another player \u201cI believe the murderer was person A, using weapon L, in room T.\u201d If the other player is holding exactly one of these cards, that player must show you (and only you) that card. If they have more than one such card, they can show you any one of them.\n\nWhen making a suggestion, you must first ask the person to your right for any evidence. If they have none, you continue with the person on their right, and so on, until someone has evidence, or no one has any of the cards in your suggestion.\n\nMany times you can gain information even if you are not the person making the suggestion. Suppose, in the above example, you are the third player and have cards A and T. If someone else shows evidence to the suggester, you know that it must be weapon card L. Keeping track of suggestions and who gave evidence at each turn is an important strategy when playing the game.\n\nTo win the game, you must make an accusation, where you state your final guess of the murderer, weapon, and room. After stating your accusation, you check the three cards that were set aside at the start of the game \u2013 if they match your accusation, you win! Needless to say, you want to be absolutely sure of your accusation before you make it.\n\nHere is your problem. You are player $1$. Given a set of cards dealt to you and a history of suggestions and evidence, you need to decide how close you are to being able to make an accusation.\n\n-----Input-----\nThe input starts with an integer $n$ ($1 \\le n \\le 50$), the number of suggestions made during the game. Following this is a line containing the five cards you are dealt, all uppercase letters in the range \u2018A\u2019\u2026\u2018U\u2019. The remaining $n$ lines contain one suggestion per line. Each of these lines starts with three characters representing the suggestion (in the order person, weapon, room), followed by the responses of up to three players, beginning with the player to the right of the player making the suggestion. If a player presents no evidence, a \u2018-\u2019 (dash) is listed; otherwise an \u201cevidence character\u201d is listed. If the specific evidence card is seen by you (either because you provided it or you were the person receiving the evidence) then the evidence character identifies that card; otherwise the evidence character is \u2018*\u2019. Note that only the last response can be an evidence character. All characters are separated by single spaces. Only valid suggestion/response sequences appear in the input.\n\n-----Output-----\nDisplay a three character string identifying the murderer, the murder weapon, and the room. If the murderer can be identified, use the appropriate letter for that person; otherwise use \u2018?\u2019. Do the same for the murder weapon and the room.\n\n-----Examples-----\nSample Input 1:\n1\nB I P C F\nA G M - - -\nSample Output 1:\nAGM\n\nSample Input 2:\n2\nA B C D H\nF G M M\nF H M - *\nSample Output 2:\nE??\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\n Dima the hamster enjoys nibbling different things: cages, sticks, bad problemsetters and even trees! Recently he found a binary search tree and instinctively nibbled all of its edges, hence messing up the vertices. Dima knows that if Andrew, who has been thoroughly assembling the tree for a long time, comes home and sees his creation demolished, he'll get extremely upset. To not let that happen, Dima has to recover the binary search tree. Luckily, he noticed that any two vertices connected by a direct edge had their greatest common divisor value exceed $1$. Help Dima construct such a binary search tree or determine that it's impossible. The definition and properties of a binary search tree can be found here.\n-----Input----- The first line contains the number of vertices $n$ ($2 \\le n \\le 700$). The second line features $n$ distinct integers $a_i$ ($2 \\le a_i \\le 10^9$)\u00a0\u2014 the values of vertices in ascending order. -----Output----- If it is possible to reassemble the binary search tree, such that the greatest common divisor of any two vertices connected by the edge is greater than $1$, print \"Yes\" (quotes for clarity). Otherwise, print \"No\" (quotes for clarity). -----Examples----- Input 6 3 6 9 18 36 108 Output Yes Input 2 7 17 Output No Input 9 4 8 10 12 15 18 33 44 81 Output Yes -----Note----- The picture below illustrates one of the possible trees for the first example. [Image]  The picture below illustrates one of the possible trees for the third example. [Image]\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nDima the hamster enjoys nibbling different things: cages, sticks, bad problemsetters and even trees!\n\nRecently he found a binary search tree and instinctively nibbled all of its edges, hence messing up the vertices. Dima knows that if Andrew, who has been thoroughly assembling the tree for a long time, comes home and sees his creation demolished, he'll get extremely upset. \n\nTo not let that happen, Dima has to recover the binary search tree. Luckily, he noticed that any two vertices connected by a direct edge had their greatest common divisor value exceed $1$.\n\nHelp Dima construct such a binary search tree or determine that it's impossible. The definition and properties of a binary search tree can be found here.\n\n\n-----Input-----\n\nThe first line contains the number of vertices $n$ ($2 \\le n \\le 700$).\n\nThe second line features $n$ distinct integers $a_i$ ($2 \\le a_i \\le 10^9$)\u00a0\u2014 the values of vertices in ascending order.\n\n\n-----Output-----\n\nIf it is possible to reassemble the binary search tree, such that the greatest common divisor of any two vertices connected by the edge is greater than $1$, print \"Yes\" (quotes for clarity).\n\nOtherwise, print \"No\" (quotes for clarity).\n\n\n-----Examples-----\nInput\n6\n3 6 9 18 36 108\n\nOutput\nYes\n\nInput\n2\n7 17\n\nOutput\nNo\n\nInput\n9\n4 8 10 12 15 18 33 44 81\n\nOutput\nYes\n\n\n\n-----Note-----\n\nThe picture below illustrates one of the possible trees for the first example. [Image] \n\nThe picture below illustrates one of the possible trees for the third example. [Image]\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\n Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly k empty cells into walls so that all the remaining cells still formed a connected area. Help him. \n-----Input----- The first line contains three integers n, m, k (1 \u2264 n, m \u2264 500, 0 \u2264 k < s), where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze. Each of the next n lines contains m characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall. -----Output----- Print n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\"). It is guaranteed that a solution exists. If there are multiple solutions you can output any of them. -----Examples----- Input 3 4 2 #..# ..#. #... Output #.X# X.#. #... Input 5 4 5 #... #.#. .#.. ...# .#.# Output #XXX #X#. X#.. ...# .#.#\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nPavel loves grid mazes. A grid maze is an n \u00d7 m rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.\n\nPavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly k empty cells into walls so that all the remaining cells still formed a connected area. Help him.\n\n\n-----Input-----\n\nThe first line contains three integers n, m, k (1 \u2264 n, m \u2264 500, 0 \u2264 k < s), where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze.\n\nEach of the next n lines contains m characters. They describe the original maze. If a character on a line equals \".\", then the corresponding cell is empty and if the character equals \"#\", then the cell is a wall.\n\n\n-----Output-----\n\nPrint n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as \"X\", the other cells must be left without changes (that is, \".\" and \"#\").\n\nIt is guaranteed that a solution exists. If there are multiple solutions you can output any of them.\n\n\n-----Examples-----\nInput\n3 4 2\n#..#\n..#.\n#...\n\nOutput\n#.X#\nX.#.\n#...\n\nInput\n5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n\nOutput\n#XXX\n#X#.\nX#..\n...#\n.#.#\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\n Count the number of binary relations over a set of size n such that they are symmetric, transitive, but not an equivalence relations (i.e. they are not reflexive). Since their number may be very large (not 0, according to Little Johnny), print the remainder of integer division of this number by 10^9 + 7. \n-----Input----- A single line contains a single integer n (1 \u2264 n \u2264 4000). -----Output----- In a single line print the answer to the problem modulo 10^9 + 7. -----Examples----- Input 1 Output 1 Input 2 Output 3 Input 3 Output 10 -----Note----- If n = 1 there is only one such relation\u00a0\u2014 an empty one, i.e. $\\rho = \\varnothing$. In other words, for a single element x of set A the following is hold: [Image]. If n = 2 there are three such relations. Let's assume that set A consists of two elements, x and y. Then the valid relations are $\\rho = \\varnothing$, \u03c1 = {(x, x)}, \u03c1 = {(y, y)}. It is easy to see that the three listed binary relations are symmetric and transitive relations, but they are not equivalence relations.\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nLittle Johnny has recently learned about set theory. Now he is studying binary relations. You've probably heard the term \"equivalence relation\". These relations are very important in many areas of mathematics. For example, the equality of the two numbers is an equivalence relation.\n\nA set \u03c1 of pairs (a, b) of elements of some set A is called a binary relation on set A. For two elements a and b of the set A we say that they are in relation \u03c1, if pair $(a, b) \\in \\rho$, in this case we use a notation $a \\stackrel{\\rho}{\\sim} b$.\n\nBinary relation is equivalence relation, if: It is reflexive (for any a it is true that $a \\stackrel{\\rho}{\\sim} a$); It is symmetric (for any a, b it is true that if $a \\stackrel{\\rho}{\\sim} b$, then $b \\stackrel{\\rho}{\\sim} a$); It is transitive (if $a \\stackrel{\\rho}{\\sim} b$ and $b \\stackrel{\\rho}{\\sim} c$, than $a \\stackrel{\\rho}{\\sim} c$).\n\nLittle Johnny is not completely a fool and he noticed that the first condition is not necessary! Here is his \"proof\":\n\nTake any two elements, a and b. If $a \\stackrel{\\rho}{\\sim} b$, then $b \\stackrel{\\rho}{\\sim} a$ (according to property (2)), which means $a \\stackrel{\\rho}{\\sim} a$ (according to property (3)).\n\nIt's very simple, isn't it? However, you noticed that Johnny's \"proof\" is wrong, and decided to show him a lot of examples that prove him wrong.\n\nHere's your task: count the number of binary relations over a set of size n such that they are symmetric, transitive, but not an equivalence relations (i.e. they are not reflexive).\n\nSince their number may be very large (not 0, according to Little Johnny), print the remainder of integer division of this number by 10^9 + 7.\n\n\n-----Input-----\n\nA single line contains a single integer n (1 \u2264 n \u2264 4000).\n\n\n-----Output-----\n\nIn a single line print the answer to the problem modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1\n\nInput\n2\n\nOutput\n3\n\nInput\n3\n\nOutput\n10\n\n\n\n-----Note-----\n\nIf n = 1 there is only one such relation\u00a0\u2014 an empty one, i.e. $\\rho = \\varnothing$. In other words, for a single element x of set A the following is hold: [Image].\n\nIf n = 2 there are three such relations. Let's assume that set A consists of two elements, x and y. Then the valid relations are $\\rho = \\varnothing$, \u03c1 = {(x, x)}, \u03c1 = {(y, y)}. It is easy to see that the three listed binary relations are symmetric and transitive relations, but they are not equivalence relations.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n You just finished participating in a programming contest with your friend. Unfortunately, you were unable to All Kill the contest (i.e., solve all of the problems), but you are now wondering if there might be some strategy that would have solved all of the problems. Solving a problem has two phases, a thinking phase and a coding phase. Your friend is responsible for all the thinking while you are responsible for all the coding. For each problem, you ve computed exactly how long it would take for you to code. However, before you can code a problem in contest, your friend needs to get the idea to solve it first. You aren t sure how to estimate the time when your friend gets a solution idea, so you model it like this: For every problem, your friend gets the idea of how to solve this problem at a uniformly random minute during the contest. Each of these is an independent random variable. You can only code one problem at a time, so there may be several problems queued up at any moment of time. You always prioritize coding the lowest numbered problems first. You do this minute-by-minute, so you will switch to coding a lower-numbered problem if your friend gets the idea for it before you re finished coding a higher-numbered problem, but you would prefer not to do this. Context switching is an expensive operation, even in the human brain! The contest strategy can be modeled as follows for each minute: - For each problem that doesn t yet have an idea, your friend will get the idea to solve it with probability $1/(\\textrm{number of minutes remaining in contest})$. Your friend can get the idea to solve multiple problems in the same minute. - Among the\n-----Input----- The first line of input contains two space-separated integers $n$ ($1 \\leq n \\leq 10^5$) and $t$ ($1 \\leq t \\leq 10^8$), where there were $n$ problems in the contest, and the contest lasted $t$ minutes. Each of the next $n$ lines contains a single integer $x$ ($1 \\leq x \\leq 10^3$). These are the times to code each problem in minutes, in order. It is guaranteed that the sum of these times is less than or equal to $t$. -----Output----- Output a single integer, which is $(p \\cdot t^n) \\pmod{998244353}$, where $p$ is the probability of the two events mentioned above happening together. -----Examples----- Sample Input: 3 5 1 2 1 Sample Output: 60\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nYou just finished participating in a programming contest with your friend. Unfortunately, you were unable to All Kill the contest (i.e., solve all of the problems), but you are now wondering if there might be some strategy that would have solved all of the problems.\n\nSolving a problem has two phases, a thinking phase and a coding phase. Your friend is responsible for all the thinking while you are responsible for all the coding.\n\nFor each problem, you\u2019ve computed exactly how long it would take for you to code. However, before you can code a problem in contest, your friend needs to get the idea to solve it first. You aren\u2019t sure how to estimate the time when your friend gets a solution idea, so you model it like this: For every problem, your friend gets the idea of how to solve this problem at a uniformly random minute during the contest. Each of these is an independent random variable. You can only code one problem at a time, so there may be several problems queued up at any moment of time. You always prioritize coding the lowest numbered problems first. You do this minute-by-minute, so you will switch to coding a lower-numbered problem if your friend gets the idea for it before you\u2019re finished coding a higher-numbered problem, but you would prefer not to do this. Context switching is an expensive operation, even in the human brain!\n\nThe contest strategy can be modeled as follows for each minute:\n - For each problem that doesn\u2019t yet have an idea, your friend will get the idea to solve it with probability $1/(\\textrm{number of minutes remaining in contest})$. Your friend can get the idea to solve multiple problems in the same minute.\n - Among the problems that still need code time and your friend has gotten the solution idea, you will take the lowest numbered one and spend the next minute coding it (if no problem satisfies the condition, you do nothing at this step).\n\nYou would like to know the probability of these two events happening together:\n - Your team finishes coding all the problems by the end of the contest\n - For each problem, the time spent coding that problem is a contiguous interval\n\nLet $p$ be this probability, $n$ be the number of problems in the contest and $t$ be the number of minutes in the contest. It can be shown that $p \\cdot t^n$ is an integer. Output the value of $(p \\cdot t^n) \\pmod{998244353}$. Note that $998244353$ is a large prime.\n\n\n\n-----Input-----\nThe first line of input contains two space-separated integers $n$ ($1 \\leq n \\leq 10^5$) and $t$ ($1 \\leq t \\leq 10^8$), where there were $n$ problems in the contest, and the contest lasted $t$ minutes.\n\nEach of the next $n$ lines contains a single integer $x$ ($1 \\leq x \\leq 10^3$). These are the times to code each problem in minutes, in order. It is guaranteed that the sum of these times is less than or equal to $t$.\n\n-----Output-----\nOutput a single integer, which is $(p \\cdot t^n) \\pmod{998244353}$, where $p$ is the probability of the two events mentioned above happening together.\n\n-----Examples-----\nSample Input:\n3 5\n1\n2\n1\nSample Output:\n60\n\"\"\"\ndef code():"
}