{
    "id": "cmpl-4BVL0dJQKk0IRxeZllRozOnJd0ztz",
    "object": "text_completion",
    "created": 1638647418,
    "model": "davinci-codex:2021-08-03",
    "choices": [
        {
            "text": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(1, n):\n        if a[i] < a[i-1]:\n            count += 1\n            if a[i] < 0:\n                a[i] = (a[i] + m) % m\n            else:\n                a[i] = (a[i] + 1) % m\n\n    print(count)\n\n\nif __name__ == \"__main__\":\n    code()",
            "index": 0,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(n-1):\n        if a[i] > a[i+1]:\n            count += 1\n            for j in range(i+1, n):\n                a[j] = (a[j]+1) % m\n    print(count)\n\n\nif __name__ == '__main__':\n    code()",
            "index": 1,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not head:\n            return None\n        curr = head\n        while curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head",
            "index": 2,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n        if not head:\n            return None\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n                curr = prev.next\n            else:\n                prev, curr = prev.next, curr.next\n\n        return dummy.next",
            "index": 3,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        A,B,C = map(int, input().split())\n        if A**2 + B**2 == C**2:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
            "index": 4,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        a,b,c = map(int, input().split())\n        if a**2 + b**2 == c**2:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
            "index": 5,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, a, b = map(int, input().split())\n    x = []\n    y = []\n    for i in range(n):\n        x.append(int(input()))\n        y.append(int(input()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(x[i]-x[j]) + abs(y[i]-y[j]) == abs(a-b):\n                count += 1\n\n    print(count)",
            "index": 6,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, a, b = map(int, input().split())\n    x = []\n    y = []\n    for i in range(n):\n        x.append(int(input()))\n        y.append(int(input()))\n\n    # d[i][j] is the distance between pinholes i and j\n    d = [[0 for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = abs(x[i] - x[j]) + abs(y[i] - y[j])\n\n    # s[i][j] is the number of pairs of pinholes that can be pointed by the compass when it points at pinholes i and j\n    s = [[0 for i in range(n)] for j in range(n)]\n\n    # Base case: s[i][i] = 1 (the compass can point at one pinhole)\n    for i in range(n):\n        s[i][i] = 1\n\n    # Recursive case: s[i][j] = s[i][k] + s[k][j] + 1 (the compass can point at pinholes i and j if it can point at pinholes i and k, and then move the leg so that it points at pinholes k and j)\n    for l in range(1, n):  # l is the length of the legs of the compass\n        for i in range(0, n - l):  # The starting pinhole of the compass\n            j = i + l  # The ending pinhole of the compass\n\n            for k in range(i, j):  # The intermediate pinhole of the compass (the leg will be moved to this pinhole)\n                s[i][j] += s[i][k] * s[k+1][j]  # Add all possible ways to point at pinholes i and j from pinholes i and k\n\n            s[i][j] += 1  # Add one more way to point at pinholes i and j from pinholes i and j (the leg will be moved to this pinhole)\n\n    print(s[a-1][b-1])\n\n\nif __name__ == '__main__':\n    code()",
            "index": 7,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        s = input()\n        if len(s) == 1:\n            print(\"YES\")\n        elif len(s) == 2:\n            if s[0] == s[1]:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            flag = 0\n            for i in range(len(s)):\n                if s[i] != s[len(s)-1-i]:\n                    flag = 1\n                    break\n            if flag == 1:\n                print(\"NO\")\n            else:\n                print(\"YES\")",
            "index": 8,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        s = input()\n        if s == s[::-1]:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
            "index": 9,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        n = int(input())\n        print(n**2)\ncode()",
            "index": 10,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        n = int(input())\n        print(n**2)\ncode()",
            "index": 11,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        a = int(input())\n        print(a+2)\ncode()",
            "index": 12,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    T = int(input())\n    for i in range(T):\n        a = int(input())\n        print(a+2)\ncode()",
            "index": 13,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(q):\n        x, y = map(int, input().split())\n        if x == 0:\n            a[y] = n+1\n        else:\n            print(max(a[x:n-y]))\n\n\nif __name__ == \"__main__\":\n    code()",
            "index": 14,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(q):\n        x, y = map(int, input().split())\n        if x + y >= n:\n            print(n)\n        else:\n            print(max(a[x:n-y]))\n\n\nif __name__ == \"__main__\":\n    code()",
            "index": 15,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        a = int(input(), 7)\n        b = int(input(), 7)\n        l = int(input(), 7)\n        print(a % (b * l))\ncode()",
            "index": 16,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    t = int(input())\n    for i in range(t):\n        a = int(input())\n        b = int(input())\n        l = int(input())\n        print(a % (b * l))",
            "index": 17,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    h = int(input())\n    a = [int(i) for i in input().split()]\n    if len(a) != h + 1:\n        print(\"Wrong number of elements\")\n        return\n    if h == 2:\n        print(\"perfect\")\n        print(a[0], a[1])\n        print(a[0], a[1])\n        return\n\n    # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u044b \u0441 \u0432\u0435\u0440\u0448\u0438\u043d\u0430\u043c\u0438 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u0438\u043f\u0430 \u0434\u0435\u0440\u0435\u0432\u0430. \u0412\u0435\u0440\u0448\u0438\u043d\u044b \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u0447\u0438\u0441\u043b\u0443, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0431\u044b\u043b\u043e \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043e \u043f\u0440\u0438 \u0440\u0430\u0437\u0431\u0438\u0435\u043d\u0438\u0438.\n    # \u0412\u0435\u0440\u0448\u0438\u043d\u044b \u0441 \u0442\u0430\u043a\u0438\u043c \u0436\u0435 \u0447\u0438\u0441\u043b\u043e\u043c \u043e\u0431\u0440\u0430\u0437\u0443\u044e\u0442 \u043e\u0434\u043d\u043e \u0434\u0435\u0440\u0435\u0432\u043e.\n    tree_1 = []\n    tree_2 = []\n\n    # \u041f\u043e\u043a\u0430 \u0447\u0438\u0441\u043b\u043e, \u0441 \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u043c, \u043d\u0435 \u0440\u0430\u0432\u043d\u043e 1, \u0443\u043c\u0435\u043d\u044c\u0448\u0430\u0435\u043c \u0435\u0433\u043e, \u0443\u0434\u0430\u043b\u044f\u044f 1.\n    while a[-1] != 1:\n        for i in range(len(a)):\n            if a[i] % 2 == 0:\n                a[i] //= 2\n\n                # \u0415\u0441\u043b\u0438 \u044d\u0442\u043e \u0447\u0438\u0441\u043b\u043e - 1, \u0442\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0432 tree_1.\n                if a[i] == 1:\n                    tree_1.append(i)\n\n                # \u0415\u0441\u043b\u0438 \u044d\u0442\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 - 2, \u0442\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0432 tree_2.\n                elif a[i] == 2:\n                    tree_2.append(i)\n\n                break\n\n    # tree_1 - \"perfect\", tree_2 - \"ambiguous\" (\u043a\u043e\u043b-\u0432\u043e \"perfect\" > 1).\n    if len(tree_1) > 1:\n        print(\"perfect\")\n\n        # tree_1 - \"perfect\", tree_2 - \"ambiguous\".\n        for i in range(len(tree_1)):\n            print(*tree_1)\n\n        for i in range(len(tree_2)):\n            print(*tree_2)\n\n    else:\n        print(\"ambiguous\")\n\n        for i in range(len(tree_1)):\n            print(*tree_1)\n\n        for i in range(len(tree_2)):\n            print(*tree_2)",
            "index": 18,
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "text": "\n    h = int(input())\n    a = list(map(int, input().split()))\n    if len(a) != h + 1:\n        print(\"Wrong input\")\n        return\n    if len(set(a)) == 1:\n        print(\"perfect\")\n        return\n    for i in range(h):\n        if a[i] > 2 * h:\n            print(\"Wrong input\")\n            return\n\n    def dfs(v, p, d):\n        global res, a, h, g1, g2, vis1, vis2\n\n        if d == h:\n            return\n\n        if v in vis1:\n            if g1[v] != p:\n                res = False\n                return\n\n        else:\n            vis1.add(v)\n\n            g1[v] = p\n\n            for i in range(a[d]):\n                dfs(v + i + 1, v, d + 1)\n\n    def dfs2(v, p, d):\n        global res, a, h, g1, g2, vis1, vis2\n\n        if d == h:\n            return\n\n        if v in vis2:\n            if g2[v] != p:\n                res = False\n                return\n\n        else:\n            vis2.add(v)\n\n            g2[v] = p\n\n            for i in range(a[d]):\n                dfs2(v + i + 1, v, d + 1)\n\n    res = True\n\n    g1 = [0] * (h + 1)  # \u0434\u043b\u044f \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430 \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u043b-\u0432\u043e \u0432\u0435\u0440\u0448\u0438\u043d \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435 (\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 - \u0441\u0443\u043c\u043c\u0430)\n    g2 = [0] * (h + 1)  # \u0434\u043b\u044f \u0432\u0442\u043e\u0440\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430 \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043a\u043e\u043b-\u0432\u043e \u0432\u0435\u0440\u0448\u0438\u043d \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435 (\u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 - \u0441\u0443\u043c\u043c\u0430)\n\n    vis1 = set()  # \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0441\u0435\u0449\u0451\u043d\u043d\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d (\u0434\u043b\u044f 1-\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430)\n    vis2 = set()  # \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0441\u0435\u0449\u0451\u043d\u043d\u044b\u0445 \u0432\u0435\u0440\u0448\u0438\u043d (\u0434\u043b\u044f 2-\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430)\n\n    dfs(0, 0, 0)  # 0 - \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043d\u0430 root (\u043a\u043e\u0440\u0435\u043d\u044c), 0 - \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043d\u0430 0-\u044b\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c (\u043a\u043e\u0440\u0435\u043d\u044c)\n\n    if not res: print(\"ambiguous\")\n\n    else: print(\"perfect\")",
            "index": 19,
            "logprobs": null,
            "finish_reason": "stop"
        }
    ]
}