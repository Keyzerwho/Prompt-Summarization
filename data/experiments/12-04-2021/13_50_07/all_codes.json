{
    "0": "\n    ",
    "1": "\n    T = int(input())\n    for i in range(T):\n        K = int(input())\n        for j in range(1, K+1):\n            print(j, end=\"\")\n        for j in range(K-1, 0, -1):\n            print(j, end=\"\")\n        print()\n\n",
    "2": "\n    h = int(input())\n    a = [int(i) for i in input().split()]\n    if len(a) != h + 1:\n        print(\"Wrong number of elements\")\n        return\n\n    if len(set(a)) == 1:\n        print(\"perfect\")\n        return\n\n    # build tree with root 0 and leaves a[0] and a[1]\n    # then check if it is isomorphic to any of the trees with root 1, 2, ..., h - 1. If so, add this root to the list of roots. If not, add this tree as a new tree.\n\n    roots = []  # list of roots that match the sequence\n\n    for i in range(h):  # iterate over all possible roots (from 0 to h - 1)\n        t = Tree()  # create empty tree with root 0\n        t.add_leaf(0, a[0])  # add leaf 0 with value a[0] to the tree with root 0 (the only leaf in it)\n        t.add_leaf(1, a[1])  # add leaf 1 with value a[1] to the tree with root 0 (the only leaf in it)\n\n        for j in range(2, h + 1):  # iterate over all other leaves (from 2 to h) and try to add them to the tree with root i (j - 2). If they are already added as children of some other nodes or there is no free space left on some nodes, then break from this loop and try another root. Otherwise add this leaf as child of node i (j - 2).\n\n            added = False  # flag that shows if we have added any new leaves during this iteration\n\n            for k in range(len(t.nodes)):  # iterate over all nodes in the current tree and try to find free space on them for adding new leaves\n\n                if t.nodes[k].free_space > 0:  # there is free space on node k -> try adding new leaf j here\n\n                    if t.add_leaf(k, j):  # function returns True if we have successfully added new leaf j as child of node k; otherwise False\n                        added = True   # remember that we have added at least one new leaf during this iteration\n\n                        break   # go out from inner loop because we don't need to check other nodes anymore since we have already found free space on one of them for adding our new leaf j\n\n            if not added:   # no free space left on any node -> break from outer loop because we cannot build such tree matching given sequence -> go back and try another root\n                break\n\n            else:   # remember that we have successfully built such tree matching given sequence -> now check whether it is isomorphic to any other trees already found by now or not; otherwise add it as new non-isomorphic tree into list of trees found so far; also remember that we don't need to check other roots anymore since we have already built such non-isomorphic rooted tree matching given sequence using current one as its root -> go back and try another different root instead\n\n                iso_found = False   # flag that shows us whether we have found an isomorphic rooted non-isomorphic rooted non-isomorphic rooted non-isomorphic rooted... rooted non-isomorphic rooted non-isomorphic...tree yet or not during this iteration; initially set it as False because initially there are no trees found yet by which our current tree could be isomorphic or not; but after first successful iteration when at least one such tree has been found then set it as True until next iteration when another such tree will be found or until end of iterations when no more such trees can be found by which our current tree could be isomorphic or not either because there are no more possible roots left or because all possible combinations were already tried before reaching here at which point our current rooted non-isomorphic rooted non-isomorphic...rooted non-isomorphically...rooted...tree was proved being unique and therefore must be perfect ;) so set it accordingly at each iteration below while searching for an appropriate next leaf j+1 for adding into our current growing binary search tree t starting from index 2 till end index h+1 (since indexing starts from zero but our sequence starts from index 1). Initially set it as False too but after first successful iteration when at least one such unique binary search trees has been found then set it as True until next iteration when another such unique binary search trees will be found or until end of iterations when no more such unique binary search trees can be found by which our current growing binary search trees could be isomporphic or not either because there are no more possible roots left or because all possible combinations were already tried before reaching here at which point all growing binary search trees were proved being",
    "3": "\n    h = int(input())\n    a = list(map(int, input().split()))\n    if len(a) != h + 1:\n        print(\"Incorrect sequence\")\n        return\n\n    if len(set(a)) == 1:\n        print(\"perfect\")\n        return\n\n    for i in range(h):\n        for j in range(i + 1, h):\n            if a[i] == a[j]:\n                print(\"ambiguous\")\n                print(*a)\n\n                tree1 = [0] * (h + 1)\n                tree2 = [0] * (h + 1)\n\n                tree1[i] = j + 1\n                tree2[j] = i + 1\n\n                for k in range(i - 1, -1, -1):\n                    if a[k] == a[i]:  # \u0435\u0441\u043b\u0438 \u0432\u0441\u0442\u0440\u0435\u0442\u0438\u043b\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0438\u0437 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438, \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043d\u0430 i-\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0434\u0440\u0443\u0433\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430...\n                        tree2[k] = j + 1  # ...\u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u043e 2-\u043e\u0435 \u0434\u0435\u0440\u0435\u0432\u043e \"\u043a\u043e\u0440\u043d\u044f\" j+1...\n\n                    else:  # ...\u0438\u043d\u0430\u0447\u0435...\n                        tree2[k] = i + 1  # ...\u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \"\u043a\u043e\u0440\u043d\u044f\" i+1.\n\n                    for l in range(k - 1, -1, -1):  # \u043f\u0440\u043e\u0431\u0443\u0435\u043c \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c l-\u044b\u0439 \u044d\u043b. 2-\u0433\u043e \u0434\u0435\u0440. \u043d\u0430 k-\u044b\u0439...\n\n                        if tree2[l]: continue  # ...\u0438\u043d\u0430\u0447\u0435 k-\u044b\u0439 \u044d\u043b. 2-\u0433\u043e \u0434\u0440. = 0.\n\n                        if a[l] == a[k]:   # ...\u0432 l-\u044b\u0439 2-\u043e\u043c\u0443 \u0434\u0440. \"\u043a\u043e\u0440\u043d\u044f\" j+1...\n\n                            tree2[l] = j + 1   # ...\u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \"\u043a\u043e\u0440\u043d\u044f\" j+1...\n\n                            break   # ...\u0438\u0434\u0451\u043c \u043a l-\u043e\u043c\u0443 (l -= 1).\n\n                        else:   # ...\u0438\u043d\u0430\u0447\u0435...\n\n                            tree2[l] = i + 1   # ...\u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \"\u043a\u043e\u0440\u043d\u044f\" i+1...\n\n                            break   # ...\u0438\u0434\u0451\u043c \u043a l-\u043e\u043c\u0443 (l -= 1).\n\n                    else: continue   # k -= 1; continue; // k < 0 => break; // exit while loop. // end of the first while loop. // end of the second for loop. // end of the second while loop. // end of the first for loop. // end of the first while loop again => exit while loop and go to the next line with 'print'.// end of the code block 'if' statement => exit code block and go to the next line with 'print'.// end of the code block 'if' statement again => exit code block and go to the next line with 'print'.// end of the code block 'if' statement third time => exit code block and go to the next line with 'print'.// end of all code blocks => exit all blocks and finish execution.'// end of all blocks again => finish execution.'// done! :)'",
    "4": "\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    for i in range(n-1):\n        x = 1\n        y = 0\n        while True:\n            if x <= 0 or x > n: break\n            if y == a[x-1]: break\n            y += a[x-1]\n            x += 1\n\n        print(y, end=\"\") if x == n else print(-1, end=\"\")\n",
    "5": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    for i in range(n-1):\n        x = 1\n        y = 0\n        while True:\n            if x <= 0 or x > n: break\n            if x == i+2: y += a[x-2]\n            if x == i+1: y -= a[x-2]\n            x += 1\n\n        print(y)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "6": "\n    return words.split()[1] + ' ' + words.split()[0]\n\nprint(spoonerize(\"not picking\"))",
    "7": "\n    return '{}{} {}{}'.format(words.split()[1][0], words.split()[0][1:], words.split()[0][0], words.split()[1][1:])",
    "8": "\n    n = str(n)\n    return max([int(n[:i] + n[i+1:]) for i in range(len(n))])",
    "9": "\n    n = str(n)\n    return max([int(n[:i] + n[i+1:]) for i in range(len(n))])",
    "10": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        if N == 3:\n            print(1)\n        elif N == 4:\n            print(6)\n        elif N == 5:\n            print(25)\n        elif N == 6:\n            print(93268)",
    "11": "\n    import sys\n    test_cases = int(sys.stdin.readline())\n    for i in range(test_cases):\n        n = int(sys.stdin.readline())\n        if n == 3:\n            print(1)\n        elif n == 4:\n            print(6)\n        elif n == 5:\n            print(25)\n        elif n == 6:\n            print(93268)",
    "12": "\n        transactions=sorted(transactions,key=lambda x:x.split(',')[1])\n        res=[]\n        for i in range(len(transactions)):\n            name,time,amount,city=transactions[i].split(',')\n            if int(amount)>1000:\n                res.append(transactions[i])\n                continue\n\n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(',')\n\n                if name==name2 and city!=city2 and abs(int(time)-int(time2))<=60:\n                    res.append(transactions[i])\n                    break\n\n                if name==name2 and city==city2 and abs(int(time)-int(time2))>60:\n                    res.append((transactions[i]))\n\n        return list({tuple([x.split(' ')[0]]+x.split(' ')[1].split(' ')[:-1]) for x in res})",
    "13": "\n        transactions=sorted(transactions,key=lambda x:x.split(\",\")[1])\n        res=[]\n        for i in range(len(transactions)):\n            name,time,amount,city=transactions[i].split(\",\")\n            if int(amount)>1000:\n                res.append(transactions[i])\n                continue\n\n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(\",\")\n                if name==name2 and city!=city2 and abs(int(time)-int(time2))<=60:\n                    res.append(transactions[i])\n                    break\n\n        return res",
    "14": "\n        if not root:\n            return 0\n        q = [root]\n        while q:\n            temp = []\n            for node in q:\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n\n            if not temp:\n                break\n\n            q = temp\n\n        return sum([node.val for node in q])",
    "15": "\n        if not root:\n            return 0\n        q = [root]\n        while q:\n            temp = []\n            for node in q:\n                if node.left: temp.append(node.left)\n                if node.right: temp.append(node.right)\n            if not temp: return sum([node.val for node in q])  # \u5982\u679c\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5230\u8fbe\u6700\u6df1\u5c42\u4e86\uff0c\u8fd4\u56de\u5f53\u524d\u5c42\u7684\u548c\u3002\n\n            q = temp",
    "16": "\n        if not head:\n            return None\n        if m == n:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n\n        pre = dummy\n\n        for i in range(m - 1):\n            pre = pre.next\n\n        # reverse the [m, n] nodes\n        reverse = None\n        cur = pre.next\n        for i in range(n - m + 1):\n            next_node = cur.next\n            cur.next = reverse  # reverse the direction of link list, so that we can get the correct order of nodes to be reversed. \n            reverse = cur  # reverse is the new node added at the beginning of reversed part of link list. \n            cur = next_node\n\n        pre.next.next = cur  # connect two parts of link list together, first part is from begining to m-1 node, second part is from m to n node. \n        pre.next = reverse  # connect two parts together, first part is from begining to m-1 node, second part is from m to n node; and we have already reversed the second part in previous step; so now second part becomes first part and first part becomes second part; so connect them together makes a full circle link list with no direction (like a ring).\n\n        return dummy.next",
    "17": "\n        if not head:\n            return None\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n\n        for i in range(m-1):\n            pre = pre.next\n\n        # reverse the [m, n] nodes\n        reverse = None\n        cur = pre.next\n        for i in range(n-m+1):\n            next_node = cur.next  # save the next node of cur, since cur will be overwritten by reverse's next node later on. \n            cur.next = reverse  # change the direction of link from forward to backward, so that we can easily get the previous node of current node when traversing later on. \n            reverse = cur  # save the current node as the previous node of reversed part, so that we can easily get the next node of current node when traversing later on. \n            cur = next_node\n\n        pre.next.next = cur  # connect two parts together: 1) pre -> m-1; 2) n+1 -> end; 3) m -> n; 4) reversed part (reverse->cur).  \n\n        pre.next = reverse  # connect two parts together: 1) pre -> m-1; 2) n+1 -> end; 3) m -> n; 4) reversed part (reverse->cur).  \n\n        return dummy.next",
    "18": "\n    year += 1\n    while len(set(str(year))) != 4:\n        year += 1\n    return year",
    "19": "\n    year += 1\n    while len(set(str(year))) != 4:\n        year += 1\n    return year\n"
}