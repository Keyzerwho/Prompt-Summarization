{
    "0": "Python 3\n\"\"\"\n Matryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.The Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets.  When reassembling the sets, you must follow these rules:  - You can put a doll or a nested group of dolls only inside a larger doll.  - You can combine two groups of dolls only if they are adjacent in the row.  - Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups. Your time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group [1, 2, 6]\n-----Input----- The input consists of a single test case. A test case consists of two lines. The first line contains one integer $n$ ($1 \\le n \\le 500$) representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive. -----Output----- Display the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word impossible. -----Examples----- Sample Input: 7 1 2 3 2 4 1 3 Sample Output: 7\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nMatryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.The Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets. \n\nWhen reassembling the sets, you must follow these rules:\n - You can put a doll or a nested group of dolls only inside a larger doll.\n - You can combine two groups of dolls only if they are adjacent in the row.\n - Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups.\n\nYour time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group [1, 2, 6] with the group [4] is two, since you have to open the dolls with sizes 6 and 4. When combining group [1, 2, 5] with the group [3, 4], you need to perform three openings.\n\nWrite a program to calculate the minimum number of openings required to combine all disassembled matryoshka sets.\n\n-----Input-----\nThe input consists of a single test case. A test case consists of two lines. The first line contains one integer $n$ ($1 \\le n \\le 500$) representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive.\n\n-----Output-----\nDisplay the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word impossible.\n\n-----Examples-----\nSample Input:\n7\n1 2 3 2 4 1 3\nSample Output:\n7\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\n You are given a list of IOUs issued and settle them as much as possible by considering all cycles and reducing each debt in a cycle by the minimum amount of debt occurring in the cycle. After all cycles are considered and canceled, your app should output who owes whom how much. \n-----Input----- The input consists of a single test case. The first line contains two integers $n$ and $m$ ($1 \\le n \\le 100, 0 \\le m \\le 10000$), where $n$ denotes the number of friends and $m$ denotes the number of IOUs issued. Friends are numbered $0$ to $n-1$. This is followed by $m$ lines containing three integers $a$, $b$, $c$ ($0 \\le a < n, 0 \\le b < n, a \\ne b, 0 < c \\le 1000$) denoting an IOU given by friend $a$ to friend $b$ for $c$ dollars. Any friend $i$ holds at most one IOU from any friend $j$ ($i \\ne j$), but friend $i$ may hold an IOU from friend $j$ at the same time that friend $j$ holds an IOU from $i$. -----Output----- First, output a single number $p$, denoting the number of IOUs left after canceling all cycles. Then, on the following $p$ lines, output the IOUs that are left in the same form in which they appear in the input (e.g. using $3$ integers $a$, $b$, $c$ denoting that friend $a$ owes friend $b$ $c$ dollars). Do not include any IOUs fully canceled, i.e., all the IOUs you output must have $c > 0$. -----Examples----- Sample Input 1: 4 5 0 1 10 1 2 10 0 3 10 3 2 10 2 0 20 Sample Output 1: 0 Sample Input 2: 2 2 0 1 20 1 0 5 Sample Output 2: 1 0 1 15\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nYou are developing a new app intended to simplify expense-sharing among groups of friends. This app will allow them to keep track of who encountered an expense and how it should be shared with others through the form of IOUs. For instance, if Alice pays for a meal shared with Bob and Carol, and Bob\u2019s and Carol\u2019s shares were $\\$ 5$ and $\\$ 10$, respectively, then Bob would issue an IOU for $\\$ 5$ to Alice and Carol would issue an IOU for $\\$ 10$ to Alice.\n\nYour app will maintain a ledger of who owes whom. Note that cycles can occur: For instance, if Bob initially owes Alice $\\$ 10$ and later pays a $\\$ 5$ expense on behalf of Alice, Alice would issue an IOU for $\\$ 5$ to Bob. This IOU would then cancel out, or reduce, the IOU Alice holds from Bob from $\\$ 10$ to $\\$ 5$. It\u2019s also possible for cycles to involve more than $2$ people.\n\nYour app will be given a list of IOUs issued and settle them as much as possible by considering all cycles and reducing each debt in a cycle by the minimum amount of debt occurring in the cycle. After all cycles are considered and canceled, your app should output who owes whom how much. If there are multiple ways in which cancelation can occur, you may choose any of them as long as there are no cycles left at the end. However, you may not introduce IOUs between friends that never gave an IOU to each other, e.g., if Alice owes Bob money, and Bob owes the same amount to Carol, you cannot remove Bob from the picture and declare that Alice now owes Carol.\n\n-----Input-----\nThe input consists of a single test case. The first line contains two integers $n$ and $m$ ($1 \\le n \\le 100, 0 \\le m \\le 10000$), where $n$ denotes the number of friends and $m$ denotes the number of IOUs issued. Friends are numbered $0$ to $n-1$. This is followed by $m$ lines containing three integers $a$, $b$, $c$ ($0 \\le a < n, 0 \\le b < n, a \\ne b, 0 < c \\le 1000$) denoting an IOU given by friend $a$ to friend $b$ for $c$ dollars. Any friend $i$ holds at most one IOU from any friend $j$ ($i \\ne j$), but friend $i$ may hold an IOU from friend $j$ at the same time that friend $j$ holds an IOU from $i$.\n\n-----Output-----\nFirst, output a single number $p$, denoting the number of IOUs left after canceling all cycles. Then, on the following $p$ lines, output the IOUs that are left in the same form in which they appear in the input (e.g. using $3$ integers $a$, $b$, $c$ denoting that friend $a$ owes friend $b$ $c$ dollars). Do not include any IOUs fully canceled, i.e., all the IOUs you output must have $c > 0$.\n\n-----Examples-----\nSample Input 1:\n4 5\n0 1 10\n1 2 10\n0 3 10\n3 2 10\n2 0 20\nSample Output 1:\n0\n\nSample Input 2:\n2 2\n0 1 20\n1 0 5\nSample Output 2:\n1\n0 1 15\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\n For a permutation P[1... N] of integers from 1 to N, function f is defined as follows: $f(i, j) = \\left\\{\\begin{array}{ll}{P [ i ]} & {\\text{if} j = 1} \\\\{f(P [ i ], j - 1)} & {\\text{otherwise}} \\end{array} \\right.$ Let g(i) be the minimum positive integer j such that f(i, j) = i. We can show such j always exists. For given N, A, B, find a permutation P of integers from 1 to N such that for 1   i   N, g(i) equals either A or B. \n-----Input----- The only line contains three integers N, A, B (1 \u2264 N \u2264 10^6, 1 \u2264 A, B \u2264 N). -----Output----- If no such permutation exists, output -1. Otherwise, output a permutation of integers from 1 to N. -----Examples----- Input 9 2 5 Output 6 5 8 3 4 1 9 2 7 Input 3 2 1 Output 1 2 3  -----Note----- In the first example, g(1) = g(6) = g(7) = g(9) = 2 and g(2) = g(3) = g(4) = g(5) = g(8) = 5  In the second example, g(1) = g(2) = g(3) = 1\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nFor a permutation P[1... N] of integers from 1 to N, function f is defined as follows:\n\n $f(i, j) = \\left\\{\\begin{array}{ll}{P [ i ]} & {\\text{if} j = 1} \\\\{f(P [ i ], j - 1)} & {\\text{otherwise}} \\end{array} \\right.$ \n\nLet g(i) be the minimum positive integer j such that f(i, j) = i. We can show such j always exists.\n\nFor given N, A, B, find a permutation P of integers from 1 to N such that for 1 \u2264 i \u2264 N, g(i) equals either A or B.\n\n\n-----Input-----\n\nThe only line contains three integers N, A, B (1 \u2264 N \u2264 10^6, 1 \u2264 A, B \u2264 N).\n\n\n-----Output-----\n\nIf no such permutation exists, output -1. Otherwise, output a permutation of integers from 1 to N.\n\n\n-----Examples-----\nInput\n9 2 5\n\nOutput\n6 5 8 3 4 1 9 2 7\nInput\n3 2 1\n\nOutput\n1 2 3 \n\n\n-----Note-----\n\nIn the first example, g(1) = g(6) = g(7) = g(9) = 2 and g(2) = g(3) = g(4) = g(5) = g(8) = 5 \n\nIn the second example, g(1) = g(2) = g(3) = 1\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\n ```if:python Complete the function `get_issuer()` that will determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`. ``` ```if-not:python Complete the function `getIssuer()` that will determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`. ``` ```if:typescript Where `Issuer` is defined with the following enum type. ~~~typescript enum Issuer {   VISA = 'VISA',   AMEX = 'AMEX',   Mastercard = 'Mastercard',   Discover = 'Discover',   Unknown = 'Unknown', } ~~~ ``` ```markdown | Card Type  | Begins With          | Number Length | |------------|----------------------|---------------| | AMEX       | 34 or 37           | 15          | | Discover   | 6011             | 16          | | Mastercard | 51, 52, 53, 54 or 55 | 16           | | VISA      | 4             | 13 or 16      | ``` ```if:c,cpp **C/C++ note:** The return value in C is not\n-----Input----- The input consists of $2$ lines of $10$ entries each describing the partially filled plates. The first line describes the top row (burgers and slop), the second line describes the bottom row (sushi and drumstick). On each line, the first $2$ entries describe Salamander\u2019s plate, the next $2$ Yeti\u2019s, then Golem\u2019s, Imp\u2019s, and finally Kraken\u2019s. Each entry is either the underscore character _ describing an empty slot or a positive integer number $a$ ($0 < a \\le 200$) if it is already known. Entries are separated by single spaces. You may assume that each arrangement has at least one possible solution (that is, the partial information is not inconsistent). -----Output----- Output the number $n$ of distinct solutions for the puzzle given in the input! If there are infinitely many solutions, output \u201cmany\u201d! Note that although any given entries are guaranteed to be less than $200$, inferred entries must be positive integers, but they are not subject to a maximum. -----Examples----- Sample Input 1: _ 90 22 _ 6 _ _ _ _ 81 _ 40 _ _ _ 12 60 _ 90 _ Sample Output 1: 1 Sample Input 2: 85 55 _ 99 51 _ _ _ _ _ _ _ _ _ _ _ _ 85 63 153 Sample Output 2: 1 Sample Input 3: 160 _ _ 136 _ _ _ _ _ 170 _ _ _ _ 120 _ _ 144 _ _ Sample Output 3: 8640\n\"\"\"\ndef code():",
    "7": "Python 3\n\"\"\"\nTheta likes to play Lure of the Labyrinth, which is an online game that uses a compelling graphic novel storyline to engage middle grades students in mathematical thinking and problem-solving. To find lost pets, students have to infiltrate a world of monsters and solve puzzles! Implemented by a professional game studio, these puzzles are quite engaging and challenging.\n\nIn the manager\u2019s cafeteria, students are asked to practice proportions by serving $5$ monsters sitting at the table: Salamander, Yeti, Golem, Imp, and Kraken. Each monster wants some amount of burger, slop, sushi, and drumstick.\n\nThe amount of each item each monster wants on their plate is proportional to the amount of each of the other items that monster wants, and the proportionality ratio is the same for all monsters.\n\nFor instance, as shown in sample input $1$ and in the accompanying figure, if Golem (center) wants $6$ units of burger on his plate and $12$ units of drumstick, and Salamander (left) wants $40$ units of drumstick, then Salamander will want $20$ units of burger. Students practicing proportions will program the dispenser machine to release $20$ units of burger. Similarly, Kraken (right) wants $36$ units of drumstick because it has $81$ units of slop on its plate and Salamander has $40$ units of drumstick and $90$ units of slop. If the students compute all proportions in time, the monsters eat and a pet can be saved!\n\nAs students progress in the game and reach more difficult levels, fewer and fewer amounts are given, requiring more intuition and thinking to solve the puzzle.\n\nGive a set of partially filled plates, write a program that computes the number of distinct solutions that are consistent with it!\n\n-----Input-----\nThe input consists of $2$ lines of $10$ entries each describing the partially filled plates. The first line describes the top row (burgers and slop), the second line describes the bottom row (sushi and drumstick). On each line, the first $2$ entries describe Salamander\u2019s plate, the next $2$ Yeti\u2019s, then Golem\u2019s, Imp\u2019s, and finally Kraken\u2019s. Each entry is either the underscore character _ describing an empty slot or a positive integer number $a$ ($0 < a \\le 200$) if it is already known. Entries are separated by single spaces. You may assume that each arrangement has at least one possible solution (that is, the partial information is not inconsistent).\n\n-----Output-----\nOutput the number $n$ of distinct solutions for the puzzle given in the input! If there are infinitely many solutions, output \u201cmany\u201d! Note that although any given entries are guaranteed to be less than $200$, inferred entries must be positive integers, but they are not subject to a maximum.\n\n-----Examples-----\nSample Input 1:\n_ 90 22 _ 6 _ _ _ _ 81\n_ 40 _ _ _ 12 60 _ 90 _\nSample Output 1:\n1\n\nSample Input 2:\n85 55 _ 99 51 _ _ _ _ _\n_ _ _ _ _ _ _ 85 63 153\nSample Output 2:\n1\n\nSample Input 3:\n160 _ _ 136 _ _ _ _ _ 170\n_ _ _ _ 120 _ _ 144 _ _\nSample Output 3:\n8640\n\"\"\"\ndef code():",
    "8": "Python 3\n\"\"\"\n You are given a collection of $N$ non-empty strings, denoted by $S_1, S_2, \\ldots , S_ n$. Then you are given $N$-$1$ operations which you execute in the order they are given. The $i^{th}$ operation is has the following format: $a$$b$ ($1$-based indexing, without the quotes), which means that you have to make the following changes: - $S_ a = S_ a + S_ b$, i.e. concatenate $a^{th}$ string and $b^{th}$ string and store the result in $a^{th}$ string, - $S_ b$ = \"\", i.e. make the $b^{th}$ string empty, after doing the previous step. You are ensured that after the $i^{th}$ operation, there will be no future operation that will be accessing $S_ b$. Given these operations to join strings, print the last string that will remain at the end of this process. \n-----Input----- The first line contains an integer $N$ ($1 \\le N \\le 10^5$) denoting the number of strings given. Each of the next $N$ lines contains a string denoting the $S_ i$. All the characters in the string $S_ i$ are lowercase alphabets from \u2018a\u2019 to \u2018z\u2019. The total number of characters over all the strings is at most $10^6$, i.e $\\sum _{i = 1}^{N}|S_ i| \\leq 10^6$, where $|S_ i|$ denotes the length of the $i^{th}$ string. After these $N$ strings, each of the next $N$-$1$ lines contain two integers $a$ and $b$, such that $a \\neq b$ and $1 \\le a, b \\le N$ denoting the $i^{th}$ operation. -----Output----- Print the last string which remains at the end of the $N$-$1$ operations. -----Warning----- The I/O files are large. Please use fast I/O methods. -----Examples----- Sample Input: 4 cute cat kattis is 3 2 4 1 3 4 Sample Output: kattiscatiscute\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nYou are given a collection of $N$ non-empty strings, denoted by $S_1, S_2, \\ldots , S_ n$. Then you are given $N$-$1$ operations which you execute in the order they are given. The $i^{th}$ operation is has the following format: \u2018$a$$b$\u2019 ($1$-based indexing, without the quotes), which means that you have to make the following changes:\n - $S_ a = S_ a + S_ b$, i.e. concatenate $a^{th}$ string and $b^{th}$ string and store the result in $a^{th}$ string,\n - $S_ b$ = \"\", i.e. make the $b^{th}$ string empty, after doing the previous step.\n\nYou are ensured that after the $i^{th}$ operation, there will be no future operation that will be accessing $S_ b$. Given these operations to join strings, print the last string that will remain at the end of this process.\n\n-----Input-----\nThe first line contains an integer $N$ ($1 \\le N \\le 10^5$) denoting the number of strings given. Each of the next $N$ lines contains a string denoting the $S_ i$. All the characters in the string $S_ i$ are lowercase alphabets from \u2018a\u2019 to \u2018z\u2019. The total number of characters over all the strings is at most $10^6$, i.e $\\sum _{i = 1}^{N}|S_ i| \\leq 10^6$, where $|S_ i|$ denotes the length of the $i^{th}$ string. After these $N$ strings, each of the next $N$-$1$ lines contain two integers $a$ and $b$, such that $a \\neq b$ and $1 \\le a, b \\le N$ denoting the $i^{th}$ operation.\n\n-----Output-----\nPrint the last string which remains at the end of the $N$-$1$ operations.\n\n-----Warning-----\nThe I/O files are large. Please use fast I/O methods.\n\n-----Examples-----\nSample Input:\n4\ncute\ncat\nkattis\nis\n3 2\n4 1\n3 4\nSample Output:\nkattiscatiscute\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\n You are given an array of integers. In one step, you can change the sign of any number of elements in the array. Return the maximum sum of elements in the array.   \n-----Input----- The first line contains an integer n (2 \u2264 n \u2264 100). The second line contains (2\u00b7n - 1) integers \u2014 the array elements. The array elements do not exceed 1000 in their absolute value. -----Output----- In a single line print the answer to the problem \u2014 the maximum sum that Yaroslav can get. -----Examples----- Input 2 50 50 50 Output 150 Input 2 -1 -100 -1 Output 100 -----Note----- In the first sample you do not need to change anything. The sum of elements equals 150. In the second sample you need to change the sign of the first two elements. Then we get the sum of the elements equal to 100.\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nYaroslav has an array, consisting of (2\u00b7n - 1) integers. In a single operation Yaroslav can change the sign of exactly n elements in the array. In other words, in one operation Yaroslav can select exactly n array elements, and multiply each of them by -1.\n\nYaroslav is now wondering: what maximum sum of array elements can be obtained if it is allowed to perform any number of described operations?\n\nHelp Yaroslav.\n\n\n-----Input-----\n\nThe first line contains an integer n (2 \u2264 n \u2264 100). The second line contains (2\u00b7n - 1) integers \u2014 the array elements. The array elements do not exceed 1000 in their absolute value.\n\n\n-----Output-----\n\nIn a single line print the answer to the problem \u2014 the maximum sum that Yaroslav can get.\n\n\n-----Examples-----\nInput\n2\n50 50 50\n\nOutput\n150\n\nInput\n2\n-1 -100 -1\n\nOutput\n100\n\n\n\n-----Note-----\n\nIn the first sample you do not need to change anything. The sum of elements equals 150.\n\nIn the second sample you need to change the sign of the first two elements. Then we get the sum of the elements equal to 100.\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\n Given two positive integers $A$ and $B$, and $N$ integers with product $A$, and $M$ integers with product $B$, compute the greatest common divisor of $A$ and $B$. If the result is more than $9$ digits long, output only the last $9$ digits. \n-----Input----- The first line of input contains the positive integer $N$ ($1 \\le N \\le 1000$). The second line of input contains $N$ space-separated positive integers less than $1000000000$, whose product is the number $A$. The third line of input contains the positive integer $M$ ($1 \\le M \\le 1000$). The fourth line of input contains $M$ space-separated positive integers less than $1000000000$, whose product is the number $B$. -----Output----- The first and only line of output must contain the greatest common divisor of numbers $A$ and $B$. If the result is more than $9$ digits long, output only the last (least significant) $9$ digits. -----Examples----- Sample Input 1: 3 2 3 5 2 4 5 Sample Output 1: 10 Sample Input 2: 4 6 2 3 4 1 1 Sample Output 2: 1\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nMirko has received a homework assignment to compute the greatest common divisor of the two positive integers $A$ and $B$. Since the numbers are quite large, the teacher provided him with $N$ smaller integers whose product is $A$, and $M$ integers with product $B$.\n\nMirko would like to verify his result, so he has asked you to write a program to solve his problem. If the result is more than $9$ digits long, output only the last $9$ digits.\n\n-----Input-----\nThe first line of input contains the positive integer $N$ ($1 \\le N \\le 1000$).\n\nThe second line of input contains $N$ space-separated positive integers less than $1000000000$, whose product is the number $A$.\n\nThe third line of input contains the positive integer $M$ ($1 \\le M \\le 1000$).\n\nThe fourth line of input contains $M$ space-separated positive integers less than $1000000000$, whose product is the number $B$.\n\n-----Output-----\nThe first and only line of output must contain the greatest common divisor of numbers $A$ and $B$. If the result is more than $9$ digits long, output only the last (least significant) $9$ digits.\n\n-----Examples-----\nSample Input 1:\n3\n2 3 5\n2\n4 5\nSample Output 1:\n10\n\nSample Input 2:\n4\n6 2 3 4\n1\n1\nSample Output 2:\n1\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\n You are given a number X. You are also given a number m. You are asked to find the maximum number of blocks that can be added to the tower and the maximum X that results this number of blocks. \n-----Input----- The only line of the input contains one integer m (1 \u2264 m \u2264 10^15), meaning that Limak wants you to choose X between 1 and m, inclusive. -----Output----- Print two integers\u00a0\u2014 the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks. -----Examples----- Input 48 Output 9 42 Input 6 Output 6 6 -----Note----- In the first sample test, there will be 9 blocks if you choose X = 23 or X = 42. Limak wants to maximize X secondarily so you should choose 42. In more detail, after choosing X = 42 the process of building a tower is:  Limak takes a block with side 3 because it's the biggest block with volume not greater than 42. The remaining volume is 42 - 27 = 15.  The second added block has side 2, so the remaining volume is 15 - 8 = 7.  Finally, Limak adds 7 blocks with side 1, one by one.  So, there are 9 blocks in the tower. The total volume is is 3^3 + 2^3 + 7\u00b71^3 = 27 + 8 + 7 = 42.\n\"\"\"\ndef code():",
    "15": "Python 3\n\"\"\"\nLimak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length.\n\nA block with side a has volume a^3. A tower consisting of blocks with sides a_1, a_2, ..., a_{k} has the total volume a_1^3 + a_2^3 + ... + a_{k}^3.\n\nLimak is going to build a tower. First, he asks you to tell him a positive integer X\u00a0\u2014 the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn't exceed X.\n\nLimak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X.\n\nCan you help Limak? Find the maximum number of blocks his tower can have and the maximum X \u2264 m that results this number of blocks.\n\n\n-----Input-----\n\nThe only line of the input contains one integer m (1 \u2264 m \u2264 10^15), meaning that Limak wants you to choose X between 1 and m, inclusive.\n\n\n-----Output-----\n\nPrint two integers\u00a0\u2014 the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks.\n\n\n-----Examples-----\nInput\n48\n\nOutput\n9 42\n\nInput\n6\n\nOutput\n6 6\n\n\n\n-----Note-----\n\nIn the first sample test, there will be 9 blocks if you choose X = 23 or X = 42. Limak wants to maximize X secondarily so you should choose 42.\n\nIn more detail, after choosing X = 42 the process of building a tower is:  Limak takes a block with side 3 because it's the biggest block with volume not greater than 42. The remaining volume is 42 - 27 = 15.  The second added block has side 2, so the remaining volume is 15 - 8 = 7.  Finally, Limak adds 7 blocks with side 1, one by one. \n\nSo, there are 9 blocks in the tower. The total volume is is 3^3 + 2^3 + 7\u00b71^3 = 27 + 8 + 7 = 42.\n\"\"\"\ndef code():",
    "16": "Python 3\n\"\"\"\n For a given value of the coefficient A find the maximum n, such that \u00a0(n)\u00a0 \u00a0A\u00a0 rub(n).\n-----Input----- The input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A\u00a0($A = \\frac{p}{q}$,\u00a0$p, q \\leq 10^{4}, \\frac{1}{42} \\leq \\frac{p}{q} \\leq 42$). -----Output----- If such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes). -----Examples----- Input 1 1 Output 40 Input 1 42 Output 1 Input 6 4 Output 172\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nRikhail Mubinchik believes that the current definition of prime numbers is obsolete as they are too complex and unpredictable. A palindromic number is another matter. It is aesthetically pleasing, and it has a number of remarkable properties. Help Rikhail to convince the scientific community in this!\n\nLet us remind you that a number is called prime if it is integer larger than one, and is not divisible by any positive integer other than itself and one.\n\nRikhail calls a number a palindromic if it is integer, positive, and its decimal representation without leading zeros is a palindrome, i.e. reads the same from left to right and right to left.\n\nOne problem with prime numbers is that there are too many of them. Let's introduce the following notation: \u03c0(n)\u00a0\u2014 the number of primes no larger than n, rub(n)\u00a0\u2014 the number of palindromic numbers no larger than n. Rikhail wants to prove that there are a lot more primes than palindromic ones.\n\nHe asked you to solve the following problem: for a given value of the coefficient A find the maximum n, such that \u03c0(n) \u2264 A\u00b7rub(n).\n\n\n-----Input-----\n\nThe input consists of two positive integers p, q, the numerator and denominator of the fraction that is the value of A\u00a0($A = \\frac{p}{q}$,\u00a0$p, q \\leq 10^{4}, \\frac{1}{42} \\leq \\frac{p}{q} \\leq 42$).\n\n\n-----Output-----\n\nIf such maximum number exists, then print it. Otherwise, print \"Palindromic tree is better than splay tree\" (without the quotes).\n\n\n-----Examples-----\nInput\n1 1\n\nOutput\n40\n\nInput\n1 42\n\nOutput\n1\n\nInput\n6 4\n\nOutput\n172\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\n You are given a grid with some targets. For each column, a boomerang is thrown from the bottom of the column upwards. When the boomerang hits any target, it will bounce off, make a $90$ degree turn to the right and fly off in a straight line in its new direction. The boomerang can hit multiple targets and does not stop until it leaves the grid. \n-----Input----- The first line contains a single integer $n$ $(1 \\leq n \\leq 10^5)$.  The next line contains $n$ integers $a_1,a_2,\\ldots,a_n$ $(0 \\leq a_i \\leq 3)$. -----Output----- If no configuration of targets exist, print $-1$.  Otherwise, on the first line print a single integer $t$ $(0 \\leq t \\leq 2n)$: the number of targets in your configuration.   Then print $t$ lines with two spaced integers each per line. Each line should contain two integers $r$ and $c$ $(1 \\leq r,c \\leq n)$, where $r$ is the target's row and $c$ is the target's column. All targets should be different.   Every row and every column in your configuration should have at most two targets each.  -----Examples----- Input 6 2 0 3 0 1 1 Output 5 2 1 2 5 3 3 3 6 5 6 Input 1 0 Output 0 Input 6 3 2 2 2 1 1 Output -1 -----Note----- For the first test, the answer configuration is the same as in the picture from the statement.  For the second test, the boomerang is not supposed to hit anything, so we can place $0$ targets.  For the third test, the following configuration of targets matches the number of hits, but is not allowed as row $3$ has $4$ targets.   [Image]  It can be shown for this test case that no valid configuration of targets will result in the given number of target hits.\n\"\"\"\ndef code():",
    "19": "Python 3\n\"\"\"\nTo improve the boomerang throwing skills of the animals, Zookeeper has set up an $n \\times n$ grid with some targets, where each row and each column has at most $2$ targets each. The rows are numbered from $1$ to $n$ from top to bottom, and the columns are numbered from $1$ to $n$ from left to right. \n\n For each column, Zookeeper will throw a boomerang from the bottom of the column (below the grid) upwards. When the boomerang hits any target, it will bounce off, make a $90$ degree turn to the right and fly off in a straight line in its new direction. The boomerang can hit multiple targets and does not stop until it leaves the grid.\n\n  [Image] \n\nIn the above example, $n=6$ and the black crosses are the targets. The boomerang in column $1$ (blue arrows) bounces $2$ times while the boomerang in column $3$ (red arrows) bounces $3$ times.\n\n The boomerang in column $i$ hits exactly $a_i$ targets before flying out of the grid. It is known that $a_i \\leq 3$.\n\nHowever, Zookeeper has lost the original positions of the targets. Thus, he asks you to construct a valid configuration of targets that matches the number of hits for each column, or tell him that no such configuration exists. If multiple valid configurations exist, you may print any of them.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ $(1 \\leq n \\leq 10^5)$.\n\n The next line contains $n$ integers $a_1,a_2,\\ldots,a_n$ $(0 \\leq a_i \\leq 3)$.\n\n\n-----Output-----\n\nIf no configuration of targets exist, print $-1$.\n\n Otherwise, on the first line print a single integer $t$ $(0 \\leq t \\leq 2n)$: the number of targets in your configuration. \n\n Then print $t$ lines with two spaced integers each per line. Each line should contain two integers $r$ and $c$ $(1 \\leq r,c \\leq n)$, where $r$ is the target's row and $c$ is the target's column. All targets should be different. \n\n Every row and every column in your configuration should have at most two targets each. \n\n\n-----Examples-----\nInput\n6\n2 0 3 0 1 1\n\nOutput\n5\n2 1\n2 5\n3 3\n3 6\n5 6\n\nInput\n1\n0\n\nOutput\n0\n\nInput\n6\n3 2 2 2 1 1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nFor the first test, the answer configuration is the same as in the picture from the statement.\n\n For the second test, the boomerang is not supposed to hit anything, so we can place $0$ targets.\n\n For the third test, the following configuration of targets matches the number of hits, but is not allowed as row $3$ has $4$ targets.\n\n  [Image] \n\nIt can be shown for this test case that no valid configuration of targets will result in the given number of target hits.\n\"\"\"\ndef code():"
}