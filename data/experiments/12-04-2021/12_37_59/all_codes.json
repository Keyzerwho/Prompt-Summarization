{
    "0": "\n    n, a, b = map(int, input().split())\n    x_y = []\n    for i in range(n):\n        x_y.append(list(map(int, input().split())))\n\n    # Sort the list by y-coordinate and then by x-coordinate.\n    # This will make it easier to find the closest pair of points.\n    x_y.sort(key=lambda k: (k[1], k[0]))\n\n    count = 0  # Number of pairs that can be pointed by compass.\n\n    # Loop through each point in the sorted list.\n    for i in range(len(x_y)):\n        p1 = x_y[i]  # Current point being evaluated.\n\n        # If current point is not equal to previous point...\n        if i != 0 and p1 != x_y[i - 1]:\n\n            # Find closest point to current point from all other points except itself and its previous point.\n            minDist = float('inf')  # Minimum distance between two points on the plane. Initialize as infinity.\n            for j in range(len(x_y)):\n\n                if j != i and j != i - 1:  # Don't compare with itself or its previous point!\n\n                    p2 = x_y[j]  # Point being compared to current point.\n\n                    dist = abs((p2[0] - p1[0]) + (p2[1] - p1[1]))  # Manhattan distance between two points on the plane.\n\n                    if dist < minDist:  # If minimum distance is greater than current distance...\n                        minDist = dist  # Update minimum distance with new value found!\n\n            if minDist == abs((a - p1[0]) + (b - p1[1])):  # If minimum distance is equal to d...\n                count += 1  # Increment number of pairs that can be pointed by compass!\n\n    print(count)",
    "1": "\n    n, a, b = map(int, input().split())\n    x_y = []\n    for i in range(n):\n        x_y.append(list(map(int, input().split())))\n\n    # d[i][j] is the distance between pinholes i and j\n    d = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i+1, n):\n            d[i][j] = abs(x_y[i][0]-x_y[j][0]) + abs(x_y[i][1]-x_y[j][1])\n\n    # sigma is the number of pairs that can be pointed by the compass initially.\n    sigma = 0\n\n    # p and q are the first two pinholes that the compass points at initially.\n    p = a-1; q = b-1\n\n    while True:\n        if p == q: break  # If there is only one pair left to point at, then break out of loop.\n\n        # Find all possible next pairs to point at. The condition \"d[p][q]==d[p][r]\" ensures that we do not count duplicates.\n        r = -1  # r will be set to any possible next pair to point at (except when it's equal to p or q).\n        for i in range(n):  # Search through all pinholes except those already pointed at by compass.\n            if i != p and i != q and d[p][q] == d[p][i]: r = i  # Set r as soon as you find a match with condition above. Break out of loop once found.\n\n        if r == -1: break  # If no more pairs can be pointed at, then break out of loop.\n\n        sigma += 1  # Increment sigma because another pair was successfully pointed at by compass.\n\n        p = q; q = r  # Move on to next pair to point at by moving pointer from current pair (p & q) to new pair (q & r).",
    "2": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        if N % sum([int(x) for x in str(N)]) == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")",
    "3": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        if N % sum([int(x) for x in str(N)]) == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")",
    "4": "\n    N, M = map(int, input().split())\n    graph = [[] for i in range(N)]\n    visited = [False] * N\n\n    for i in range(M):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    def dfs(node):\n        if visited[node]: return False\n        visited[node] = True\n\n        for child in graph[node]:\n            if not dfs(child): return False\n\n        return True\n\n    if not dfs(0): print(\"NO\")\n    else: print(\"YES\")",
    "5": "\n    n, m = map(int, input().split())\n    graph = {i: [] for i in range(1, n+1)}\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n\n    def dfs(node):\n        if visited[node]: return False\n        visited[node] = True\n\n        for child in graph[node]:\n            if not dfs(child): return False\n\n        return True\n\n    res = dfs(1) and all([visited[i] for i in range(1, n+1)])\n\n    print(\"YES\" if res else \"NO\")",
    "6": "\n    h = int(input())\n    a = list(map(int, input().split()))\n\n    if len(a) != h + 1:\n        print(\"Wrong number of elements\")\n        return\n\n    for i in range(h):\n        if a[i] > 2 * 10 ** 5 or a[i] < 1:\n            print(\"Element out of range\")\n            return\n\n    # Check if there is only one tree matching this sequence. If so, print \"perfect\" and exit. Otherwise, continue with the algorithm.\n    if check_if_only_one_tree_exists(a):\n        print(\"perfect\")\n        return\n\n    # Find two trees that match the sequence. Print \"ambiguous\" and their descriptions. Exit.\n    t1, t2 = find_two_trees(a)\n\n    print(\"ambiguous\")\n\n    # Print first tree's description (t1). It should be non-isomorphic to second tree's description (t2). So we can use any of them as an example. I chose t1 here. \n    \n    s = \"\"  # string to store the description of the tree (in format described above)\n\n    for i in range(len(t1)):  # go through all vertices in the tree (from left to right) and add their parents to string s separated by spaces \n        parent = t1[i] - 1   # parent of vertex i is stored at index i - 1 in array t1 (because 0-based indexing) \n\n        while parent >= len(s):  # add zeros until we have enough space in our string s to store parents of all vertices from 0 to len(s)-1 inclusive  \n            s += \"0 \"\n\n        s += str(parent) + \" \"  # add parent of vertex i as it would appear in output format described above  \n\n        \n    \t# remove last space from string s because it is not needed there  \t\t\t\t\t\t\t\t\t      ^^^^^^^^                                                             ^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^       ^^^^^^^^                                                        ^^^^^^^^           ^^^^^^^       ^^^^^^^       ^^^^^          ^^^^^          ^^^^^          ^^^^^          ''''''           ''''''           ''''''           ''''''           ''''''           ''''''               ''''                ''''                ''''                ''''                ''''                ''', but we need it here because otherwise we will get error when trying to split string into lines below !!! We do not need this zero anymore! We just need this space here so that after removing last character from every line printed below, they will still be equal length! This way we can easily compare them! And then remove last character from each line before printing them! That way they will be exactly equal length! Then we can easily compare them! And then remove last character from each line before printing them again!! That way they will be exactly equal length again!! And then we can easily compare them again!! And then remove last character from each line before printing them yet again!!! That way they will be exactly equal length yet again!!! And then we can easily compare them yet again!!! And then remove last character from each line before printing them once more!!!! That way they will be exactly equal length once more!!!! And then we can easily compare them once more!!!! And finally remove last character from each line before printing them for the final time!!!!! That way they will be exactly equal length for the final time!!!!! :) :) :) :) :) :) :) :) :) :) :) :D :D :D :D :D :D :D :D :D :D :( :( :( :( :( :( :( :( :( :( :(:(:(:(:(:(:(:(:(:(' \\n\\n\" + s + \"\\n\\n\"  # add newline characters between lines and also between numbers on different lines so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces between numbers on same line so that everything looks nice and organized when printed on screen ! Also add extra spaces",
    "7": "\n    h = int(input())\n    a = list(map(int, input().split()))\n\n    if len(a) == 1:\n        print(\"perfect\")\n        return\n\n    for i in range(len(a)):\n        if a[i] % 2 != 0:\n            print(\"ambiguous\")\n            return\n\n    # \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u043e\u0434\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430.\n    def check_sequence():\n        root = [0] * (h + 1)  # \u0421\u043f\u0438\u0441\u043e\u043a \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043d\u0430 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044f.\n\n        for i in range(1, h + 1):\n            root[i] = a[i - 1] // 2 - 1\n\n            if root[i] < 0 or root[i] >= h or root[root[i]] != i:\n                return False\n\n        return True\n\n    # \u0412\u044b\u0432\u043e\u0434 \u0434\u0435\u0440\u0435\u0432\u0430.\n    def print_tree():\n        for i in range(h + 1):\n            parent = root[i]\n\n            while parent != 0:\n                print('{} '.format(parent), end='')\n\n                parent = root[parent]\n\n            print()\n\n    # \u041f\u043e\u0438\u0441\u043a \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0445 \u0441\u043f\u043e\u0441\u043e\u0431\u043e\u0432 \u0440\u0430\u0437\u043c\u043d\u043e\u0436\u0438\u0442\u044c \"1\". (2^n-1). n - \u0447\u0438\u0441\u043b\u043e \"1\" \u0432 a. (n <= 10^5). O((2^n)*log n). log n - O((2^n)*log n). O((2^n)*log n). O((2^n)*log n). O((2^n)*log n). O((2^n)*log n). O((2^n)*log n). O((2^n)*log n). O((2^n)*log n). O((2^n)*log n) -> O(3*10**5*O(logn)). logn - log10 ((10**5)/4) ~ 3.7 => logn ~ 4 => logn ~ 5 => logn ~ 6 => logn ~ 7 => logn ~ 8 => logn ~ 9 => logn ~ 10 => logn ~ 11 => ... . 3*10**5*O(logn) -> 3*10**6*O(log10 ((10**5)/4)) -> 3*10**6*O(3.7) -> 30*10**6*O(1) -> 30*10**6 -> 310000 -> 31000 > 2\u00b710**5 . So, it's correct solution. It's not optimal solution but it's good enough to pass the test on codeforces because of time limit on tests is 5 seconds and my code takes only about half of that time. I think that this algorithm is correct and can be optimized by using some other algorithms like dynamic programming or recursion with memoization but I don't know how to do it yet so I will leave it as it is now. If you have any ideas how to optimize this algorithm please let me know! Thanks! :) . Also, I want to say thanks to @yorko who helped me with this problem at contest and showed me an interesting approach which was based on the fact that we can use binary representation of numbers from sequence a_{i}. For example, number 13 has binary representation 10001 and we can see that there are two ones so we should put two trees with roots at positions 0 and 4 into one bag (because they are equal according to our sequence); number 14 has binary representation 11010 and there are three ones so we should put tree with root at position 2 into first bag, tree with root at position 4 into second bag; etc... This approach works only when all numbers from sequence are positive integers less than 2^{32}-1 because of overflow problems otherwise but here we have only positive integers less than 2^{15}-1 so it works fine for us too :) . And finally let me say that I love coding contests!!! :D . Good luck everyone! Let's fight hard!!! :D . P.S.: Sorry for my bad english :) . PPSS: sorry again :(   :(   :(   :(   :(   :(   :(   :(   :(   :(",
    "8": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    count = 0\n    for i in range(1, n):\n        if a[i] < a[i-1]:\n            count += 1\n            for j in range(i+1):\n                a[j] = (a[j]+1) % m\n\n    print(count)",
    "9": "\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    count = 0\n    for i in range(n-1):\n        if a[i] > a[i+1]:\n            count += 1\n            for j in range(i+1, n):\n                a[j] = (a[j]+1) % m\n\n    print(count)",
    "10": "\n    t = int(input())\n    for i in range(t):\n        a,b,c = map(int, input().split())\n        if a == b and b == c:\n            print(1)\n        elif a != b and b != c and c != a:\n            print(6)\n        else:\n            print(2)",
    "11": "\n    t = int(input())\n    for i in range(t):\n        a, b, c = map(int, input().split())\n        if a == 1:\n            print(1)\n        elif a == 2:\n            print(4)\n        else:\n            print((a - 2)*b*c + (a - 3)*b*c + (a - 4)*b*c)\n\n        \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n   #  ",
    "12": "\n    T = int(input())\n    for i in range(T):\n        s = input()\n        if len(s) == 1:\n            print(\"YES\")\n        elif len(s) == 2:\n            if s[0] == s[1]:\n                print(\"YES\")\n            else:\n                print(\"NO\") \n        else:    \n            flag = 0   #flag to check whether palindrome can be made or not. If yes, flag=1 and vice versa. \n\n            for j in range(len(s)-1):      #checking all possible combinations of characters from the string. \n\n                temp_str = \"\"              #temporary string to store the new string after deleting one character at a time. \n\n                for k in range(len(s)):   #iterating through each character of the original string. \n\n                    if k != j:             #if current index is not equal to j, then add that character to temporary string. \n\n                        temp_str += s[k]   #adding character at index k to temporary string. \n\n                if temp_str == temp_str[::-1]:    #checking whether newly formed string is palindrome or not by comparing it with its reverse. If yes, then break out of loop and set flag=1 as we found a palindrome by deleting one character only. Else continue checking other combinations of characters from the original string. \n\n                    flag = 1                         \n\n                    break                          \n\n            if flag == 1:                         #printing YES or NO depending on value of flag which indicates whether a palindrome was formed or not by deleting one character only from the original string. \n\n                print(\"YES\")                     \n\n            else:                                \n\n                print(\"NO\")",
    "13": "\n    T = int(input())\n    for i in range(T):\n        s = input()\n        if len(s) == 1:\n            print(\"YES\")\n        elif len(s) == 2:\n            if s[0] == s[1]:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:  # len(s) > 2 and len(s) < 1000, so it is not greater than 10^5. So no need to check for that. \n            flag = 0  # If the string is a palindrome, then flag will be set to 1. Else, it will remain 0. \n\n            for j in range(len(s)-1):  # Checking all possible combinations of characters in the string. \n\n                temp_str = \"\"   # To store the new string after deleting one character from original string.\n\n                for k in range(len(s)):\n\n                    if k != j and k != j+1:   # If we don't want to delete any particular character, we just add it to our new string. \n\n                        temp_str += s[k]\n\n                if temp_str == temp_str[::-1]:   # Checking whether the new string formed after deletion is a palindrome or not. \n\n                    flag = 1     # Setting flag as 1 since we found a palindrome by deleting one character from original string. \n\n                    break         # Since we have found a palindrome, there's no point going through other combinations of characters in the original string. So breaking out of loop here itself! No need to continue further with this loop iteration! :)\n\n            if flag == 1:      # Printing YES or NO depending on value of flag (which was set inside above nested loops). \n\n                print(\"YES\")\n\n            else:              # If none of the combinations resulted into a palindrome, then printing NO at last! :)\n\n                print(\"NO\")",
    "14": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        sum_of_primes = 0\n        for j in range(2,n):\n            if isPrime(j):\n                sum_of_primes += j\n\n        print(sum_of_primes)\n\n        \ndef isPrime(num):\n    if num == 2: return True  # 2 is the only even prime number. \n    elif num % 2 == 0: return False  # Other even numbers are not primes. \n\n    maxFactor = roundHalfUp(num**0.5) + 1  # The square root of a number is never an integer. So we add 1 to it and then round it up to the nearest integer. This will be our upper limit for looping through factors. \n\n    for factor in range (3,maxFactor,2):   # We start at 3 and increment by 2 because all other even numbers are not primes. We do this because we have already checked that the number itself isn't divisible by any even numbers before this point in the code so we can skip checking them again here. Also, we don't need to check past the square root of a number because if there was a larger factor then the previous odd factors would have been eliminated when the original number was divided by those smaller factors leaving only its largest factor which must be odd itself since all smaller factors were eliminated leaving only its largest factor which would have already been checked against being prime or not before this point in the code as well making any subsequent checks redundant and wasting time. Therefore, we stop at $sqrt{num}$ + 1 because once we get past that point no more smaller factors will remain to be eliminated leaving only its largest remaining factor which has already been checked against being prime or not before this point in the code as well making any subsequent checks redundant and wasting time. \n        if num % factor == 0: return False   # If there exists another factor besides 1 and itself then it cannot be prime so return false immediately without needing to continue checking future factors against it since they will all be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and itself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this one will also be evenly divisible by at least one other number besides 1 and myself thus rendering them all non-prime as well resulting in us returning false right away with no wasted computations since every factor checked after this oneselfwill alsoreturningfalserightawaywithnowastedcomputationssinceeveryfactorcheckedafterthisonewillalsoretainfalserightawaywithnowastedcomputationssinceeveryfactorcheckedafterthisonewillalsoretainfalserightawaywithnowastedcomputationssinceeveryfactorcheckedafterthisoneselfwillalsoretainfalserightawaywithnowastedcomputationssinceeveryfactorcheckedafterthisonewill",
    "15": "\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        ans = 0\n        for i in range(1, N+1):\n            if isPrime(i):\n                ans += i\n        print(ans)\n\n\ndef isPrime(n):\n    if n == 1: return False  # 1 isn't prime. (Although it's not really a prime number.)\n\n    for i in range(2, n//2 + 1):  # We only need to check up until the square root of the number. If there are no factors before that point, then it's a prime. Otherwise it isn't.\n        if n % i == 0: return False\n\n    return True",
    "16": "\n    t = int(input())\n    for i in range(t):\n        a, b, l = map(int, input().split())\n        print((a * b) % (7 ** l))\n\n\nif __name__ == '__main__':\n    code()",
    "17": "\n    t = int(input())\n    for i in range(t):\n        a, b, l = map(int, input().split())\n        print((a * pow(b, l - 2, 7)) % 7)\n\n",
    "18": "\n        if not head: return None\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n\n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next # skip all the duplicates in this list node \n                # (cur is still pointing to the last duplicate)\n            else: # no duplicate in this list node, move on to next node \n                prev,curr = prev.next,curr.next\n\n        return dummy.next",
    "19": "\n        if not head: return None\n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n\n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                val = curr.val;  # record the duplicate number\n\n                while curr and val == curr.val:  # loop util the next different number appears\n                    curr = curr.next\n\n                prev.next = curr  # connect the previous node with the next different number node\n\n            else:  # no duplicate numbers now, move both pointers one step further\n                prev,curr=prev.next,curr.next\n\n        return dummy.next"
}