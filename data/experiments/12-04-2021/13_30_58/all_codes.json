{
    "0": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        if n == 1:\n            print(0)\n        elif n == 2:\n            print(1)\n        else:\n            a, b = 0, 1\n            for i in range(n-2):\n                a, b = b, a+b\n\n            print(b)",
    "1": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        if n % 2 == 0:\n            print(n//2)\n        else:\n            print((n+1)//2)\n\n",
    "2": "\n        \n        pass\n\n\nif __name__ == '__main__':\n    assert Solution().minCameraCover(0) == 0",
    "3": "\n        # return self.dfs(root)\n        return self.bfs(root)\n\n    def dfs(self, root):\n        ",
    "4": "\n    return int(n**2*3.14)\n\nprint(points(2))",
    "5": "\n    return int(n**2*3.14)\n\nprint(points(2))",
    "6": "\n    n = int(input())\n    v = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        v.append((x, y))\n\n    # Find the smallest vector with non-zero magnitude.\n    min_v = None\n    for i in range(n):\n        if abs(v[i][0]) + abs(v[i][1]) > 0:\n            min_v = v[i]\n            break\n\n    # If there is no such vector, then all vectors have zero magnitude. The solution is trivial.\n    if min_v is None: return [1] * n\n\n    # Find the smallest vector with the same direction as min_v. This will be used to determine the sign of each move. \n    for i in range(n):\n        if (min_v[0] * v[i][0] + min_v[1] * v[i][1]) == 0:  # The dot product of these two vectors must be zero. \n            sign_vec = v[i]\n\n            # Determine the sign of each move by comparing the signs of their respective components. \n            signs = []  # 1 means positive and -1 means negative. \n            for j in range(n):  # For each vector... \n                signs.append(-1 if (sign_vec[0] * v[j][0] + sign_vec[1] * v[j][1]) < 0 else 1)\n\n            return signs",
    "7": "\n    n = int(input())\n    v = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        v.append((x, y))\n\n    # Find the vector with the largest magnitude.\n    max_mag = 0\n    for i in range(n):\n        mag = (v[i][0]**2 + v[i][1]**2)**0.5\n        if mag > max_mag:\n            max_mag = mag\n\n    # Find the vector with the smallest magnitude.\n    min_mag = max_mag + 1  # Set to a value larger than any of the vectors.\n    for i in range(n):\n        mag = (v[i][0]**2 + v[i][1]**2)**0.5\n        if mag < min_mag:\n            min_mag = mag\n\n    # If all of the vectors have magnitude less than 1.5*10^6, then we can just return all 1's as our solution.  This is because we know that any such sequence will satisfy |p| <= 1.5*10^6 where p is the final position after all moves are made.  If this is not true, then we need to find a vector with magnitude greater than 1.5*10^6 and subtract it from each vector before calculating |p| as described above.  This will ensure that |p| <= 1.5*10^6 after all moves are made and we can return a valid solution (all 1's).  We also need to make sure that we don't subtract this vector from any other vectors as doing so would result in a negative number which is not allowed by our constraints!\n\n    if min_mag < 1.5e6:  # All vectors have magnitude less than or equal to 1.5*10^6 so just return all ones as our solution! :)  We know that this satisfies |p| <= 1.5*10^6 after all moves are made because p is the final position after all moves are made and p has magnitude at most equal to |v| where v is any one of our vectors and |v| <= 1.5*10^6 since v was chosen from among those vectors with magnitude less than or equal to 1.5*10^6! :)   Since we know that |p| <= 1.5*10^6 after all moves are made, then it must be true that p has magnitude at most equal to 2e6 since otherwise there would be some vector v such that |v| > 2e6 and since p - v has magnitude at most equal to 2e6 - |v| which must be less than or equal to 2e6 since 2e6 > 2e6 - |v| >= 0! :)   Since we know that p has magnitude at most equal to 2e6, then it must be true that p has magnitude at most equal to 3e7 since otherwise there would be some vector v such that |v| > 3e7 and since p - v has magnitude at most equal to 3e7 - |v| which must be less than or equal to 3e7 since 3e7 > 3e7 - |v| >= 0! :)   Since we know that p has magnitude at most equal to 3e7, then it must be true that p has magnitude at most equal to 4e8 since otherwise there would be some vector v such that |v| > 4e8 and since p - v has magnitude at most equal to 4e8 - |v| which must be less than or equal to 4e8 since 4e8 > 4e8 - |v| >= 0! :)   Since we know that p has magnitude at most equal to 4e8, then it must be true that p has magnitude at least 500001 because otherwise there would be some vector v such tat |v| < 500001 and since p - v has magnitdue at least 500001 - (-1000001) >= 500001 >= 1000001 >= 0! :)   Since we know tat p has magnitdue at least 500001, then it must also have magnitdue at least 1000001 because otherwise there would be some vector v such tat 1000001 < abs(p-v) which means abs(p-v) < 1000001 which means abs(p-v) < 2000001 which means abs(2000001-abs(p-V)) < 2000001 which means abs(-2000001-abs(p-V)) < 2000001 which means abs(-2000001-(2000001-abs(p-V))) < 2000001 which means abs(-abs((2000001)-abs(p-V))) < 2000001 which means abs(-abs((2000001)-abs(",
    "8": "\n    database = Database()\n    return database.login(username, password)",
    "9": "\n    database = Database()\n    return database.login(username, password)",
    "10": "\n    if operator == '+':\n        return value1 + value2\n    elif operator == '-':\n        return value1 - value2\n    elif operator == '*':\n        return value1 * value2\n    else:\n        return int(value1 / value2)",
    "11": "\n    if operator == '+':\n        return value1 + value2\n    elif operator == '-':\n        return value1 - value2\n    elif operator == '*':\n        return value1 * value2\n    else:\n        return int(value1 / value2)",
    "12": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = [0]*n\n        for j in range(n):\n            l, r = map(int, input().split())\n            if (r-l+1)%2 == 0:\n                a[int((l+r)/2)-1] = j+1\n            else:\n                a[int((l+r-1)/2)-1] = j+1\n\n        print(*a)\n\n        \n\n    \n\n    \n\n    \n\n    \n\n        \n\n        \n\n        \n\n        \n\n        \n\n        ",
    "13": "\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = [0] * n\n        for j in range(n):\n            l, r = map(int, input().split())\n            if (r - l + 1) % 2 == 0:\n                a[l - 1] = a[r] = j + 1\n            else:\n                a[l - 1] = a[r - 1] = j + 1\n\n        print(*a)\n\n        \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        ",
    "14": "\n    n = int(input())\n    s = input()\n    count = 0\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            count += 1\n    print(count)\n\n",
    "15": "\n    n = int(input())\n    s = input()\n    count = 0\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            count += 1\n    print(count)",
    "16": "\n    t = int(input())\n    for i in range(t):\n        x, n = map(int, input().split())\n        print((n-1)//x*x*(x+1)//2)",
    "17": "\n    ",
    "18": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    count = 0\n    for i in range(n):\n        if a[i] == i + 1:\n            count += 1\n        else:\n            break\n\n    print(n - count)\n\n",
    "19": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    count = 0\n    for i in range(n):\n        if a[i] == i + 1:\n            count += 1\n        else:\n            break\n\n    print(n - count)\n\n"
}