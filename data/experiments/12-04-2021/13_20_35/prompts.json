{
    "0": "Python 3\n\"\"\"\nYou are given a set of n pens having red, blue, green, orange, and violet in color. Count a minimum number of pens that should be taken out from the set so that any two neighboring pens have different colors. \n\n-----Input:-----\n- \nThe first line contains t denoting the number of test cases.\n- \nThe first line of each test case will contain a single integer n.\n- \nThe second line of each test case will contain a string s.\n(s contains only 'R', 'B', 'G', 'O', and 'V' characters denoting red, blue, green, orange, and violet respectively)\n\n-----Output:-----\nFor each test case, print single line containing one integer - The minimum number of pens that need to be taken out.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq n \\leq 1000$\n\n-----Sample Input:-----\n2\n5\nRBBRG\n5\nRBGOV\n\n-----Sample Output:-----\n1\n0\n\n\"\"\"\ndef code():",
    "1": "Python 3\n\"\"\"\nYou are given a set of n pens, each of them can be red, blue, green, orange, and violet in color. Count a minimum number of pens that should be taken out from the set so that any two neighboring pens have different colors. Pens are considered to be neighboring if there are no other pens between them.\n\n-----Input:-----\n- \nThe first line contains t denoting the number of test cases.\n- \nThe first line of each test case will contain a single integer n.\n- \nThe second line of each test case will contain a string s.\n(s contains only 'R', 'B', 'G', 'O', and 'V' characters denoting red, blue, green, orange, and violet respectively)\n\n-----Output:-----\nFor each test case, print single line containing one integer - The minimum number of pens that need to be taken out.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq n \\leq 1000$\n\n-----Sample Input:-----\n2\n5\nRBBRG\n5\nRBGOV\n\n-----Sample Output:-----\n1\n0\n\n-----EXPLANATION:-----\nIn first test case, two blue pens are neighboring each other, if we take out any one of them then the string will be RBRG in which each pen has different neighbors.\nIn second test case, no pen needs to be taken out as each pen has different neighbors.\n\"\"\"\ndef code():",
    "2": "Python 3\n\"\"\"\nWrite a program to calculate the sum of all the digits of given integer N. \n\n-----Input-----\n\nThe first line contains an integer T, the total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, calculate the sum of digits of N, and display it in a new line.\n\n\n\n-----Example-----\nInput\n3 \n12345\n31203\n2123\nOutput\n15\n9\n8\n\"\"\"\ndef code():",
    "3": "Python 3\n\"\"\"\nYou're given an integer N. Write a program to calculate the sum of all the digits of N. \n\n-----Input-----\n\nThe first line contains an integer T, the total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, calculate the sum of digits of N, and display it in a new line.\n\n-----Constraints-----\n- 1 \u2264 T \u2264 1000\n- 1 \u2264 N \u2264 1000000\n\n-----Example-----\nInput\n3 \n12345\n31203\n2123\nOutput\n15\n9\n8\n\"\"\"\ndef code():",
    "4": "Python 3\n\"\"\"\nA tree having n nodes, numbered from 1 to n. Each node i has an initial value init_{i}, which is either 0 or 1. The root of the tree is node 1.\n\nOne can perform several operations on the tree and available type of operation is to pick a node x.\nRight after picking node x, the value of node x flips, the values of sons of x remain the same, the values of sons of sons of x flips, the values of sons of sons of sons of x remain the same and so on.\n\nThe goal is to get each node i to have value goal_{i}, which can also be only 0 or 1 by using minimum number of operations. \n\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5). Each of the next n - 1 lines contains two integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n; u_{i} \u2260 v_{i}) meaning there is an edge between nodes u_{i} and v_{i}. \n\nThe next line contains n integer numbers, the i-th of them corresponds to init_{i} (init_{i} is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goal_{i} (goal_{i} is either 0 or 1).\n\n\n-----Output-----\n\nIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer x_{i}, representing that you pick a node x_{i}.\n\n\n-----Examples-----\nInput\n10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n\nOutput\n2\n4\n7\n\"\"\"\ndef code():",
    "5": "Python 3\n\"\"\"\nIahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.\n\nThe game is played on a tree having n nodes, numbered from 1 to n. Each node i has an initial value init_{i}, which is either 0 or 1. The root of the tree is node 1.\n\nOne can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node x. Right after someone has picked node x, the value of node x flips, the values of sons of x remain the same, the values of sons of sons of x flips, the values of sons of sons of sons of x remain the same and so on.\n\nThe goal of the game is to get each node i to have value goal_{i}, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.\n\n\n-----Input-----\n\nThe first line contains an integer n (1 \u2264 n \u2264 10^5). Each of the next n - 1 lines contains two integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n; u_{i} \u2260 v_{i}) meaning there is an edge between nodes u_{i} and v_{i}. \n\nThe next line contains n integer numbers, the i-th of them corresponds to init_{i} (init_{i} is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goal_{i} (goal_{i} is either 0 or 1).\n\n\n-----Output-----\n\nIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer x_{i}, representing that you pick a node x_{i}.\n\n\n-----Examples-----\nInput\n10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n\nOutput\n2\n4\n7\n\"\"\"\ndef code():",
    "6": "Python 3\n\"\"\"\nYou are given n pairs of numbers where the first number is always smaller than the second number in a pair.\n\nA chain if formed when a pair (c, d) can follow another pair (a, b) if and only if b < c.\n\nFind the length of longest chain which can be formed. \n\nExample 1:\n\nInput: [[1,2], [2,3], [3,4]]\nOutput: 2\n\n\n\n\"\"\"\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:",
    "7": "Python 3\n\"\"\"\nYou are given n pairs of numbers where the first number is always smaller than the second number.\n\n\n\nNow, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion. \n\n\n\nGiven a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.\n\n\n\nExample 1:\n\nInput: [[1,2], [2,3], [3,4]]\nOutput: 2\nExplanation: The longest chain is [1,2] -> [3,4]\n\n\n\nNote:\n\nThe number of given pairs will be in the range [1, 1000].\n\"\"\"\nclass Solution:\n    def findLongestChain(self, pairs: List[List[int]]) -> int:",
    "8": "Python 3\n\"\"\"\nGiven an integer $n$. You have to arrange numbers from $1$ to $2n$, using each of them exactly once, on the circle, such that sum of every $n$ consecutive numbers on the circle must not differ more than by $1$.\n\n\n-----Input-----\n\nThe first and the only line contain one integer $n$ ($1 \\le n \\le 10^5$).\n\n\n-----Output-----\n\nIf there is no solution, output \"NO\" in the first line. \n\nIf there is a solution, output \"YES\" in the first line. In the second line output $2n$ numbers\u00a0\u2014 numbers from $1$ to $2n$ in the order they will stay in the circle. Each number should appear only once. If there are several solutions, you can output any of them.\n\n\n-----Examples-----\nInput\n3\n\nOutput\nYES\n1 4 5 2 3 6 \nInput\n4\n\nOutput\nNO\n\n\n\"\"\"\ndef code():",
    "9": "Python 3\n\"\"\"\nYou are given integer $n$. You have to arrange numbers from $1$ to $2n$, using each of them exactly once, on the circle, so that the following condition would be satisfied:\n\nFor every $n$ consecutive numbers on the circle write their sum on the blackboard. Then any two of written on the blackboard $2n$ numbers differ not more than by $1$.\n\nFor example, choose $n = 3$. On the left you can see an example of a valid arrangement: $1 + 4 + 5 = 10$, $4 + 5 + 2 = 11$, $5 + 2 + 3 = 10$, $2 + 3 + 6 = 11$, $3 + 6 + 1 = 10$, $6 + 1 + 4 = 11$, any two numbers differ by at most $1$. On the right you can see an invalid arrangement: for example, $5 + 1 + 6 = 12$, and $3 + 2 + 4 = 9$, $9$ and $12$ differ more than by $1$.\n\n [Image] \n\n\n-----Input-----\n\nThe first and the only line contain one integer $n$ ($1 \\le n \\le 10^5$).\n\n\n-----Output-----\n\nIf there is no solution, output \"NO\" in the first line. \n\nIf there is a solution, output \"YES\" in the first line. In the second line output $2n$ numbers\u00a0\u2014 numbers from $1$ to $2n$ in the order they will stay in the circle. Each number should appear only once. If there are several solutions, you can output any of them.\n\n\n-----Examples-----\nInput\n3\n\nOutput\nYES\n1 4 5 2 3 6 \nInput\n4\n\nOutput\nNO\n\n\n-----Note-----\n\nExample from the statement is shown for the first example. \n\nIt can be proved that there is no solution in the second example.\n\"\"\"\ndef code():",
    "10": "Python 3\n\"\"\"\nGiven a list of n points in one-dimensional space, find the number of ways to select 3 points such that the distance between any two is not greater than d.\n\n\n-----Input-----\n\nThe first line contains two integers: n and d (1 \u2264 n \u2264 10^5;\u00a01 \u2264 d \u2264 10^9). The next line contains n integers x_1, x_2, ..., x_{n}, their absolute value doesn't exceed 10^9 \u2014 the x-coordinates of the points in the list.\n\nIt is guaranteed that the coordinates of the points in the input strictly increase.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the number of groups of three points, where the distance between two farthest points doesn't exceed d.\n\nPlease do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n4 3\n1 2 3 4\n\nOutput\n4\n\nInput\n4 2\n-3 -2 -1 0\n\nOutput\n2\n\nInput\n5 19\n1 10 20 30 50\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample any group of three points meets our conditions.\n\nIn the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.\n\nIn the third sample only one group does: {1, 10, 20}.\n\"\"\"\ndef code():",
    "11": "Python 3\n\"\"\"\nLittle Petya likes points a lot. Recently his mom has presented him n points lying on the line OX. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed d.\n\nNote that the order of the points inside the group of three chosen points doesn't matter.\n\n\n-----Input-----\n\nThe first line contains two integers: n and d (1 \u2264 n \u2264 10^5;\u00a01 \u2264 d \u2264 10^9). The next line contains n integers x_1, x_2, ..., x_{n}, their absolute value doesn't exceed 10^9 \u2014 the x-coordinates of the points that Petya has got.\n\nIt is guaranteed that the coordinates of the points in the input strictly increase.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the number of groups of three points, where the distance between two farthest points doesn't exceed d.\n\nPlease do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n4 3\n1 2 3 4\n\nOutput\n4\n\nInput\n4 2\n-3 -2 -1 0\n\nOutput\n2\n\nInput\n5 19\n1 10 20 30 50\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample any group of three points meets our conditions.\n\nIn the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.\n\nIn the third sample only one group does: {1, 10, 20}.\n\"\"\"\ndef code():",
    "12": "Python 3\n\"\"\"\nThe lucky number of the sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence.\n\nYou've got a sequence of distinct positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l} + 1, ..., s_{r} as s[l..r] (1 \u2264 l < r \u2264 n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r].\n\nAll numbers in sequence s are distinct.\n\n\n-----Input-----\n\nThe first line contains integer n (1 < n \u2264 10^5). The second line contains n distinct integers s_1, s_2, ..., s_{n} (1 \u2264 s_{i} \u2264 10^9).\n\n\n-----Output-----\n\nPrint a single integer \u2014 the maximum lucky number among all lucky numbers of sequences s[l..r].\n\n\n-----Examples-----\nInput\n5\n5 2 1 4 3\n\nOutput\n7\n\nInput\n5\n9 8 3 5 7\n\nOutput\n15\n\n\n\"\"\"\ndef code():",
    "13": "Python 3\n\"\"\"\nBike loves looking for the second maximum element in the sequence. The second maximum element in the sequence of distinct numbers x_1, x_2, ..., x_{k} (k > 1) is such maximum element x_{j}, that the following inequality holds: $x_{j} \\neq \\operatorname{max}_{i = 1}^{k} x_{i}$.\n\nThe lucky number of the sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence.\n\nYou've got a sequence of distinct positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l} + 1, ..., s_{r} as s[l..r] (1 \u2264 l < r \u2264 n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r].\n\nNote that as all numbers in sequence s are distinct, all the given definitions make sence.\n\n\n-----Input-----\n\nThe first line contains integer n (1 < n \u2264 10^5). The second line contains n distinct integers s_1, s_2, ..., s_{n} (1 \u2264 s_{i} \u2264 10^9).\n\n\n-----Output-----\n\nPrint a single integer \u2014 the maximum lucky number among all lucky numbers of sequences s[l..r].\n\n\n-----Examples-----\nInput\n5\n5 2 1 4 3\n\nOutput\n7\n\nInput\n5\n9 8 3 5 7\n\nOutput\n15\n\n\n\n-----Note-----\n\nFor the first sample you can choose s[4..5] = {4, 3} and its lucky number is (4\u00a0xor\u00a03) = 7. You can also choose s[1..2].\n\nFor the second sample you must choose s[2..5] = {8, 3, 5, 7}.\n\"\"\"\ndef code():",
    "14": "Python 3\n\"\"\"\nYou are given N different numbers you want to make combinations of L different numbers. Create combinations so that:\n\nevery number is used atleast once\na number can only be repeated only if K other numbers have been used\n\nReturn the number of possible combinations. As the answer can be very large, return it modulo 10^9 + 7.\n\n\n\n\nExample 1:\nInput: N = 3, L = 3, K = 1\nOutput: 6\nExplanation: There are 6 possible combinations. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n\n\nExample 2:\nInput: N = 2, L = 3, K = 0\nOutput: 6\nExplanation: There are 6 possible combinations. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]\n\n\nExample 3:\nInput: N = 2, L = 3, K = 1\nOutput: 2\nExplanation: There are 2 possible combinations. [1, 2, 1], [2, 1, 2]\n\n\n\n\u00a0\nNote:\n\n0 <= K < N <= L <= 100\n\n\"\"\"\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:",
    "15": "Python 3\n\"\"\"\nYour music player contains N\u00a0different songs and she wants to listen to L (not necessarily different) songs during your trip. \u00a0You\u00a0create\u00a0a playlist so\u00a0that:\n\nEvery song is played at least once\nA song can only be played again only if\u00a0K\u00a0other songs have been played\n\nReturn the number of possible playlists.\u00a0 As the answer can be very large, return it modulo 10^9 + 7.\n\u00a0\n\n\n\nExample 1:\nInput: N = 3, L = 3, K = 1\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n\n\nExample 2:\nInput: N = 2, L = 3, K = 0\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]\n\n\nExample 3:\nInput: N = 2, L = 3, K = 1\nOutput: 2\nExplanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]\n\n\n\n\u00a0\nNote:\n\n0 <= K < N <= L <= 100\n\"\"\"\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:",
    "16": "Python 3\n\"\"\"\nYou are given a line of n gemstones, the i-th of which has color c_{i}. The goal is to destroy all the gemstones in the line.\n\nIn one second, exactly one continuous substring of colored gemstones is chosen that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again. \n\nWhat is the minimum number of seconds needed to destroy the entire line?\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 500)\u00a0\u2014 the number of gemstones.\n\nThe second line contains n space-separated integers, the i-th of which is c_{i} (1 \u2264 c_{i} \u2264 n)\u00a0\u2014 the color of the i-th gemstone in a line.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimum number of seconds needed to destroy the entire line.\n\n\n-----Examples-----\nInput\n3\n1 2 1\n\nOutput\n1\n\nInput\n3\n1 2 3\n\nOutput\n3\n\nInput\n7\n1 4 4 2 3 2 1\n\nOutput\n2\n\n\"\"\"\ndef code():",
    "17": "Python 3\n\"\"\"\nGenos recently installed the game Zuma on his phone. In Zuma there exists a line of n gemstones, the i-th of which has color c_{i}. The goal of the game is to destroy all the gemstones in the line as quickly as possible.\n\nIn one second, Genos is able to choose exactly one continuous substring of colored gemstones that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again. What is the minimum number of seconds needed to destroy the entire line?\n\nLet us remind, that the string (or substring) is called palindrome, if it reads same backwards or forward. In our case this means the color of the first gemstone is equal to the color of the last one, the color of the second gemstone is equal to the color of the next to last and so on.\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 \u2264 n \u2264 500)\u00a0\u2014 the number of gemstones.\n\nThe second line contains n space-separated integers, the i-th of which is c_{i} (1 \u2264 c_{i} \u2264 n)\u00a0\u2014 the color of the i-th gemstone in a line.\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the minimum number of seconds needed to destroy the entire line.\n\n\n-----Examples-----\nInput\n3\n1 2 1\n\nOutput\n1\n\nInput\n3\n1 2 3\n\nOutput\n3\n\nInput\n7\n1 4 4 2 3 2 1\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Genos can destroy the entire line in one second.\n\nIn the second sample, Genos can only destroy one gemstone at a time, so destroying three gemstones takes three seconds.\n\nIn the third sample, to achieve the optimal time of two seconds, destroy palindrome 4 4 first and then destroy palindrome 1 2 3 2 1.\n\"\"\"\ndef code():",
    "18": "Python 3\n\"\"\"\nYou are given an array of integers. You need to add these integers without repetition and generate two largest possible numbers of equal value. For example, if you have numbers 1, 2, and 3, you can add them together to make a sum of value 6.\nReturn the largest possible sum.\u00a0 If you cannot make two sums of equal value, return 0.\n\u00a0\nExample 1:\nInput: [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n\nExample 2:\nInput: [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n\n\nExample 3:\nInput: [1,2]\nOutput: 0\nExplanation: tow equal interers cannot be generated, so we return 0.\n\n\n\u00a0\nNote:\n\n0 <= rods.length <= 20\n1 <= rods[i] <= 1000\nThe sum of rods is at most 5000.\n\n\"\"\"\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:",
    "19": "Python 3\n\"\"\"\nYou are installing a billboard and want it to have the largest height.\u00a0 The billboard will have two steel supports, one on each side.\u00a0 Each steel support must be an equal height.\nYou have a collection of rods which can be welded together.\u00a0 For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation.\u00a0 If you cannot support the billboard, return 0.\n\u00a0\nExample 1:\nInput: [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n\nExample 2:\nInput: [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n\n\nExample 3:\nInput: [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0.\n\n\n\u00a0\nNote:\n\n0 <= rods.length <= 20\n1 <= rods[i] <= 1000\nThe sum of rods is at most 5000.\n\"\"\"\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:"
}