{
    "0": "\n    n = int(input())\n    d = [int(x) for x in input().split()]\n    if n == 2:\n        print(\"1 2\")\n        return\n\n    # Create a list of all possible edges.\n    edges = []\n    for i in range(n-1):\n        for j in range(i+1, n):\n            edges.append((i+1, j+1))\n\n    # Sort the list of edges by the sum of their distances.\n    edges.sort(key=lambda x: d[x[0]-1]+d[x[1]-1])\n\n    # Create a list of vertices that have not been used yet.\n    vertices = [i+1 for i in range(n)]\n\n    # Create a tree using the sorted list of edges.\n    tree = []  # List of tuples containing the edge and its distance. Each tuple is (u, v, d). u and v are vertices and d is distance between them.\n\n    while len(vertices) > 1:  # While there are still vertices that have not been used yet...\n\n        # Find an edge that connects two unconnected vertices and add it to the tree.\n        for e in edges:  # For each edge...\n\n            if e[0] in vertices and e[1] in vertices:  # If both endpoints are still available...\n\n                tree.append((e[0], e[1], d[e[0]-1]+d[e[1]-1]))  # Add it to the tree with its distance as its weight.\n\n                if e[0] in vertices:  # If one endpoint is no longer available...\n\n                    vertices.remove(e[0])  # Remove it from the list of available vertices.\n\n                if e[1] in vertices:  # If one endpoint is no longer available...\n\n                    vertices.remove(e[1])  # Remove it from the list of available vertices.\n\n                break  # Break out of this loop because we found an edge that works so we don't need to check any more edges! We can move on to the next vertex! :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :( :( :( :( :( :( :( :( :( :( :( :( :( :-( :-( :-( :-( :-( :-( :-( :-( :-( :-( :-( :-( :-< :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) :-) <:-) <:-) <:-) <:-) <:-) <:-) <:-) <:-) <:-) <:-) <:-) <;-) ;-) ;-) ;-) ;-) ;-) ;-) ;-) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) )))) ! ! ! ! ! ! ! ! ! ! ! ! ((((((((((((((((((((((((((())))))))))))))))))))))))))))\")",
    "1": "\n    n = int(input())\n    d = [int(x) for x in input().split()]\n    if n == 2:\n        print(\"1 2\")\n        return\n\n    # Create a list of all possible sums of the distances.\n    sums = []\n    for i in range(n-1):\n        for j in range(i+1, n):\n            sums.append(d[i]+d[j])\n\n    # Sort the list and remove duplicates.\n    sums.sort()\n    sums = list(set(sums))\n\n    # Find the smallest sum that is larger than the largest distance. If there is none, then no tree exists. Else, create a tree with that sum as the root and recursively call code().\n    if max(sums) > max(d):\n        print(-1)\n        return\n\n    else:  # There is a tree that exists with this root. Find it!\n\n        def find_tree():  # Recursive function to find the tree with root s as its root.\n\n            def find_children():  # Recursive function to find children of node u that satisfy the conditions given above. Returns True if children are found, False otherwise.\n\n                def check_children():  # Checks if children of node u satisfy conditions given above and returns True if they do, False otherwise. Also returns True if u has no children (u is a leaf).\n\n                    def check_sum():  # Checks if sum of distances from u to its children satisfies condition given above and returns True if it does, False otherwise. Also returns True if u has no children (u is a leaf).\n\n                        def check_distance():  # Checks if distance from u to its parent satisfies condition given above and returns True if it does, False otherwise. Also returns True if u has no parent (u is the root).\n\n                            def check_parent():  # Checks if parent of u satisfies condition given above and returns True if it does, False otherwise. Also returns True if u has no parent (u is the root).\n\n                                nonlocal s  # The value of s will be updated every time this function recursively calls itself so that each recursive call gets closer to finding a solution by decreasing s by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid checking values that are too small or too large because we know they won't work anyway without having to actually check them! This saves us time! We also update v every time this function recursively calls itself so that each recursive call gets closer to finding a solution by increasing v by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid checking values that are too small or too large because we know they won't work anyway without having to actually check them! This saves us time! We also update t every time this function recursively calls itself so that each recursive call gets closer to finding a solution by increasing t by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid checking values that are too small or too large because we know they won't work anyway without having to actually check them! This saves us time! We also update p every time this function recursively calls itself so that each recursive call gets closer to finding a solution by increasing p by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid checking values that are too small or too large because we know they won't work anyway without having to actually check them! This saves us time! We also update q every time this function recursively calls itself so that each recursive call gets closer to finding a solution by increasing q by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid checking values that are too small or too large because we know they won't work anyway without having to actually check them! This saves us time! We also update r every time this function recursively calls itself so that each recursive call gets closer to finding a solution by increasing r by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid checking values that are too small or too large because we know they won't work anyway without having to actually check them! This saves us time! We also update y every time this function recursively calls itself so that each recursive call gets closer to finding a solution by decreasing y by 1 until a solution is found or all possible values have been checked without success (in which case we return False). This way we can avoid",
    "2": "\n    # Write your code here\n    # To print results to the standard output you can use print\n    # Example: print \"Hello world!\"\n    \n    suffixes = []\n    \n    for i in range(len(s)):\n        suffixes.append(s[i:])\n\n    sum = 0\n\n    for suffix in suffixes:\n        sum += len(suffix) * len(suffix)\n\n    print sum",
    "3": "\n    # your code here\n    return 0",
    "4": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    for i in range(q):\n        l, r = map(int, input().split())\n        print(f(a[l-1:r]))\n\n\ndef f(b):\n    if len(b) == 1: return b[0]\n\n    m = len(b) // 2\n\n    xor_left = f([b[i] for i in range(m)])\n    xor_right = f([b[i] for i in range(m, len(b))])\n\n    return xor_left ^ xor_right\n\n\nif __name__ == '__main__':\n    code()",
    "5": "\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    for i in range(q):\n        l, r = map(int, input().split())\n        if l == 1:\n            print(a[r-1])\n        else:\n            print((a[r-1] ^ a[l-2]) + a[l-2])\n\n",
    "6": "\n    n, c, d = map(int, input().split())\n    fountains = []\n    for i in range(n):\n        b, p = map(int, input().split())\n        fountains.append((b, p))\n\n    # sort by cost\n    fountains.sort(key=lambda x: x[1])\n\n    # find the most expensive fountain that can be bought with coins and diamonds\n    max_beauty = 0\n    for i in range(n):\n        if fountains[i][1] <= c and fountains[i][1] <= d:\n            max_beauty = max(max_beauty, fountains[i][0])\n\n    print(max_beauty)\n\n\nif __name__ == \"__main__\":\n    code()",
    "7": "\n    n, c, d = map(int, input().split())\n    fountains = []\n    for i in range(n):\n        b, p = map(int, input().split())\n        if p <= c:\n            fountains.append((b, 'C'))\n        elif p <= d:\n            fountains.append((b, 'D'))\n\n    fountains.sort()\n\n    if len(fountains) == 0:\n        print(0)\n\n    elif len(fountains) == 1:\n        print(fountains[0][0])\n\n    else:\n        max_beauty = 0\n\n        for i in range(len(fountains)-1):\n            beauty1 = fountains[i][0] + fountains[i+1][0]\n\n            if fountains[i][1] == 'C':\n                cost1 = c + d - p + 1  # \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u044f\u0435\u043c 1 \u0438\u0437-\u0437\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043d\u0430 \u0440\u0430\u0432\u0435\u043d\u0441\u0442\u0432\u043e \u0432\u044b\u0448\u0435 (\u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c >=)\n\n            else:  # D-type fountain (cost is in diamonds)\n                cost1 = c + d - p + 2  # \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u044f\u0435\u043c 2 \u0438\u0437-\u0437\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u043d\u0430 \u0440\u0430\u0432\u0435\u043d\u0441\u0442\u0432\u043e \u0432\u044b\u0448\u0435 (\u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c >=)\n\n            for j in range(i+2, len(fountains)-1):  # i+2 because we already checked the first two elements of the list above (in the first for loop) and we don't need to check them again here. Also we need to check all elements from i+2 to the end of the list because we can build any number of pairs starting from the second element of the list. We can't build a pair starting from the first element of the list because it's not possible to build a fountain with beauty 0 (the first element of our sorted list). So we need at least two elements in our sorted list to be able to build a pair. Also we need to check all elements from i+2 to the end of our sorted list because there could be more pairs starting from our second element and ending somewhere before the end of our sorted list. For example let's consider this case: [3 5 C; 4 6 D; 5 7 C; 6 8 D]. In this case there are three pairs that can be built starting from our second element 4\u00a0\u2014\u00a05\u00a0\u2014\u00a07 and 6\u00a0\u2014\u00a08. The third pair is not possible because it would require building a fountain with beauty 7 which costs 6 diamonds while Arkady has only 5 diamonds. So we need to check all elements from i+2 to the end of our sorted list as well as all elements before i+2 but after i since they could be used as a second element in some other pair that starts with our second element 4 and ends somewhere before the end of our sorted list (for example [3 5 C; 4 6 D; 5 7 C; 6 8 D]). This way we will cover all cases where there are more than one pair that can be built starting from our second element 4 and ending somewhere before the end of our sorted list. Also note that when j reaches len(fountains)-1 then it means that there are no more pairs that can be built starting from our second element 4 so it's safe to break out of this inner for loop since further iterations won't change anything since no other pairs will have beauty > max_beauty at this point (they will have beauty < max_beauty). This is why there is no \"j < len(fountains)\" condition here like there was in code() function above where j was compared against n instead of len(fountains). Also note that when j reaches len(fountains)-1 then it means that there are no more pairs that can be built starting from our second element 4 so it's safe to break out of this inner for loop since further iterations won't change anything since no other pairs will have beauty > max_beauty at this point (they will have beauty < max_beauty). Also note that when j reaches len(fountains)-1 then it means that there are no more pairs that can be built starting from our second element 4 so it's safe to break out of this inner for loop since further iterations won't change anything since no other pairs will have beauty > max_beauty at this point (they will have beauty",
    "8": "\n        if n == 0:\n            return []\n        def generate(start, end):\n            if start > end:\n                return [None]\n            all_trees = []\n            for i in range(start, end+1):\n                left_trees = generate(start, i-1)\n                right_trees = generate(i+1, end)\n\n                for l in left_trees:\n                    for r in right_trees:\n                        curr_tree = TreeNode(i)\n                        curr_tree.left = l\n                        curr_tree.right = r\n\n                        all_trees.append(curr_tree)\n\n            return all_trees\n\n        return generate(1, n)",
    "9": "\n        if n == 0:\n            return []\n        def generate(start, end):\n            if start > end:\n                return [None]\n            all_trees = []\n            for i in range(start, end+1):  # pick up a root\n                # all possible left subtrees if i is choosen to be a root\n                left_trees = generate(start, i-1)\n\n                # all possible right subtrees if i is choosen to be a root\n                right_trees = generate(i+1, end)\n\n                # connect left and right subtrees to the root i\n                for l in left_trees:\n                    for r in right_trees:\n                        current_tree = TreeNode(i)\n                        current_tree.left = l\n                        current_tree.right = r  ### \u6ce8\u610f\u8fd9\u91cc\u662fr\uff0c\u4e0d\u662fl\uff0c\u56e0\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u662f\u53cd\u7684\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\n\n                        all_trees.append(current_tree)\n\n            return all_trees\n\n        return generate(1, n)",
    "10": "\n    return sorted(list(set(santas_list) & set(children)))",
    "11": "\n    return sorted(set(santas_list).intersection(children))",
    "12": "\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        S = input()\n        if N == 1:\n            print(\"Yes\")\n            continue\n        if S[0] in \"AEIOU\" and S[-1] in \"AEIOU\":\n            print(\"Yes\")\n            continue\n        for i in range(N-1):\n            if S[i] in \"AEIOU\" and S[i+1] in \"AEIOU\":\n                print(\"Yes\")\n                break\n        else:  # If the loop is not broken by break statement, then this else part will be executed. This is also a way to write an else statement.  https://stackoverflow.com/questions/9979970/why-does-python-use-else-after-for-and-while-loops#:~:text=The%20else%20clause%20is%20executed,the%20loop's%20else%20clause.&text=The%20else%20clause%2C%20if%2C%20or,not%20break%2C%20so%2C&text=The,it's%20executed.&text=If,loop's%20body.&text=If,the,loop's,body.&text=If,the,loop's,body.&text=If,the,loop's,body.,https://www.programiz.com/python-programming/break-continue#:~:text=The_break_statement_terminates_the,-It_breaks_out_of_the_closest_enclosing_for,-or_while_(but_not_try)_.&text=The_continue_statement,-It's__executed__when_(but__not__when)_.&text=The__else__clause,-is__executed__when_(but__not__when)_.&text=The__else__clause,-is__executed__when_(but__not__when)_.&text=The__else__clause,-is__executed__when_(but__not___if)_.&text=The____elif____statements,-are___executed___in___order.,https://www.tutorialspoint.com/python3/python3_loops.htm#:~:text=Python3_-_Loops_-_Else-,Python3_-_Loops_-_Else-,Python3_-_Loops_-_Else-,Python3_-_Loops_-_Else-,Python3_-_Loops_-_Else-.\n\n                print(\"Yes\")  # If the loop is not broken by break statement and it reaches the end of the loop then this else part will be executed as well because of the while loop structure (see above).\n\n                break  # This breaks out of the current loop (see above).\n\n        else:  # If the loop is not broken by break statement then this else part will be executed as well because of the while loop structure (see above).\n\n            print(\"No\")",
    "13": "\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        S = input()\n        vowels = ['A', 'E', 'I', 'O', 'U']\n        count = 0\n        for i in range(N):\n            if S[i] in vowels:\n                count += 1\n\n        if count >= 2:\n            print(\"Yes\")\n\n        else:\n            print(\"No\")",
    "14": "\n    return \"Special!!\" if all(int(i) in [0,1,2,3,4,5] for i in str(number)) else \"NOT!!\"\n\n#OR\n\ndef special_number(number):\n    return \"Special!!\" if all([int(i) in [0,1,2,3,4,5] for i in str(number)]) else \"NOT!!\"",
    "15": "\n    return \"Special!!\" if all(int(i) in [0,1,2,3,4,5] for i in str(number)) else \"NOT!!\"\n",
    "16": "\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        if N == 1:\n            print(\"NO\")\n            continue\n        count = 0\n        for j in range(1,N+1):\n            if N%j == 0:\n                count += 1\n\n        if count%2 == 0:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
    "17": "\n    for _ in range(int(input())):\n        n = int(input())\n        if n % 2 == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")",
    "18": "\n    if not words:\n        return {}\n    root = {}\n    for word in words:\n        current_dict = root\n        for letter in word:\n            current_dict = current_dict.setdefault(letter, {})\n        current_dict.setdefault(\"\", {})\n\n    return root",
    "19": "\n    pass"
}