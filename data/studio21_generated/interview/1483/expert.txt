 You are given a tree with $n$ leaves. Each leaf has length $l$. Each caterpillar has length $l$. Each caterpillar is on a leaf. Time progresses, and caterpillars eat leaves. We want to count the number of leaves that will be undamaged at the end of this eating spree. We assume adjacent leaves are a unit distance apart and the length of the caterpillars is also given in the same unit. For example suppose our branch had $20$ leaves (placed $1$ unit apart) and $3$ caterpillars of length $3, 2$ and $5$ units respectively
-----Input:----- The first line of the input contains two integers $N$ and $K$, where $N$ is the number of leaves and $K$ is the number of caterpillars. Lines $2,3,...,K+1$ describe the lengths of the $K$ caterpillars. Line $i+1$ ($1 \leq i \leq K$) contains a single integer representing the length of the $i^{th}$ caterpillar. -----Output:----- A line containing a single integer, which is the number of leaves left on the branch after all the caterpillars have finished their eating spree. -----Constraints:----- - $1 \leq N \leq 1000000000$. - $1 \leq K \leq 20$. - The length of the caterpillars lie between $1$ and $N$. - $50 \%$ of test cases will also satisfy $1 \leq N \leq 10000000$ and $1 \leq K \leq 16$. -----Sample Input:----- 20 3 3 2 5 -----Sample Output:----- 6 -----Hint:----- You may use $64$-bit integers (long long in C/C++) to avoid errors while multiplying large integers. The maximum value you can store in a $32$-bit integer is $2^{31}-1$, which is approximately $2 \cdot 10^9$. $64$-bit integers can store values greater than $10^{18}$.